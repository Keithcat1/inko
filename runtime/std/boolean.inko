#! The boolean type.
#!
#! Unlike other languages booleans are just regular (singleton) objects. There
#! are three boolean related types: `Boolean`, `True`, and `False`. `Boolean`
#! acts as the base object for `True` and `False` and mostly exists so code can
#! use a single type for booleans.

import std::conditional::Conditional
import std::conversion::ToString
import std::operators::(And, Or)

impl Boolean {
  ## Always returns `self`.
  def not -> Boolean {
    self
  }
}

impl True {
  ## Always returns `False`.
  def not -> Boolean {
    False
  }
}

impl False {
  ## Always returns `True`.
  def not -> Boolean {
    True
  }
}

impl Conditional for Boolean {
  def if_true!(R)(block: do -> R) -> ?R {
    Nil
  }

  def if_false!(R)(block: do -> R) -> ?R {
    Nil
  }

  def if!(R)(true: do -> R, false: do -> R) -> ?R {
    Nil
  }
}

impl Conditional for True {
  def if_true!(R)(block: do -> R) -> ?R {
    block.call
  }

  def if_false!(R)(block: do -> R) -> ?R {
    Nil
  }

  def if!(R)(true: do -> R, false: do -> R) -> ?R {
    true.call
  }
}

impl Conditional for False {
  def if_true!(R)(block: do -> R) -> ?R {
    Nil
  }

  def if_false!(R)(block: do -> R) -> ?R {
    block.call
  }

  def if!(R)(true: do -> R, false: do -> R) -> ?R {
    false.call
  }
}

impl And for True {
  def &&(other: Conditional) -> Boolean {
    other.if true: { True }, false: { False }
  }
}

impl Or for True {
  def ||(other: Conditional) -> Boolean {
    True
  }
}

impl And for False {
  def &&(other: Conditional) -> Boolean {
    False
  }
}

impl Or for False {
  def ||(other: Conditional) -> Boolean {
    other.if true: { True }, false: { False }
  }
}

impl ToString for Boolean {
  def to_string -> String {
    'Boolean'
  }
}

impl ToString for True {
  def to_string -> String {
    'True'
  }
}

impl ToString for False {
  def to_string -> String {
    'False'
  }
}
