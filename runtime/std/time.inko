#! Types and methods for dealing with time.
import std::conversion::(ToFloat, ToInteger)
import std::operators::(Add, Subtract)
import std::operators::(Smaller, Greater, GreaterOrEqual, SmallerOrEqual)
import std::time::raw::*

## The number to divide a value in nanoseconds by to convert it to seconds.
let NANOSEC_TO_SEC = 1_000_000_000.0

## The number to divide a value in milliseconds by to convert it to seconds.
let MILLISEC_TO_SEC = 1000.0

## A span of time measured in seconds.
##
## A `Duration` can be used to measure the span of time without having to worry
## about casting the time to different scales yourself. A `Duration` can be
## created using various scales such as seconds and milliseconds.
object Duration {
  ## Creates a new `Duration` from the given number of seconds.
  ##
  ## # Examples
  ##
  ## Creating a `Duration` using an `Integer`:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_seconds(10)
  ##
  ## Creating a `Duration` using a `Float`:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_seconds(10.5)
  def from_seconds(seconds: ToFloat) -> Self {
    new(seconds.to_float)
  }

  ## Creates a new `Duration` from the given number of milliseconds.
  ##
  ## # Examples
  ##
  ## Creating a `Duration` using an `Integer`:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_milliseconds(10)
  ##
  ## Creating a `Duration` using a `Float`:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_milliseconds(10.5)
  def from_milliseconds(milliseconds: ToFloat) -> Self {
    new(milliseconds.to_float / MILLISEC_TO_SEC)
  }

  ## Creates a new `Duration` from the given number of nanoseconds.
  ##
  ## # Examples
  ##
  ## Creating a `Duration` using an `Integer`:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_nanoseconds(10)
  ##
  ## Creating a `Duration` using a `Float`:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_nanoseconds(10.5)
  def from_nanoseconds(nanoseconds: ToFloat) -> Self {
    new(nanoseconds.to_float / NANOSEC_TO_SEC)
  }

  def init(seconds: Float) {
    let @seconds = seconds
  }

  ## Returns the duration in seconds.
  ##
  ## # Examples
  ##
  ## Getting the seconds in a `Duration`:
  ##
  ##     import std::time::Duration
  ##
  ##     let duration = Duration.from_seconds(5)
  ##
  ##     duration.as_seconds # => 5.0
  def as_seconds -> Float {
    @seconds
  }

  ## Returns the duration in milliseconds.
  ##
  ## # Examples
  ##
  ## Getting the milliseconds in a `Duration`:
  ##
  ##     import std::time::Duration
  ##
  ##     let duration = Duration.from_seconds(5)
  ##
  ##     duration.as_milliseconds # => 5000.0
  def as_milliseconds -> Float {
    @seconds * MILLISEC_TO_SEC
  }

  ## Returns the duration in nanoseconds.
  ##
  ## # Examples
  ##
  ## Getting the nanoseconds in a `Duration`:
  ##
  ##     import std::time::Duration
  ##
  ##     let duration = Duration.from_seconds(5)
  ##
  ##     duration.as_nanoseconds # => 5000000000.0
  def as_nanoseconds -> Float {
    @seconds * NANOSEC_TO_SEC
  }
}

impl ToInteger for Duration {
  ## Returns the number of seconds in the `Duration`.
  def to_integer -> Integer {
    @seconds.to_integer
  }
}

impl ToFloat for Duration {
  ## Returns the number of seconds in the `Duration`.
  def to_float -> Float {
    @seconds
  }
}

impl Add!(Self) for Duration {
  ## Adds two `Duration` objects together.
  ##
  ## # Examples
  ##
  ## Adding two `Duration` objects:
  ##
  ##     import std::time::Duration
  ##
  ##     let first = Duration.from_seconds(5)
  ##     let second = Duration.from_seconds(2)
  ##     let third = first + second
  ##
  ##     third.as_seconds # => 7.0
  def +(other: Self) -> Self {
    Duration.new(@seconds + other.as_seconds)
  }
}

impl Subtract!(Self) for Duration {
  ## Subtracts the given `Duration` from `self`.
  ##
  ## # Examples
  ##
  ## Subtracting a `Duration` from another `Duration`
  ##
  ##     import std::time::Duration
  ##
  ##     let first = Duration.from_seconds(5)
  ##     let second = Duration.from_seconds(2)
  ##     let third = first - second
  ##
  ##     third.as_seconds # => 3.0
  def -(other: Self) -> Self {
    Duration.new(@seconds - other.as_seconds)
  }
}

impl Smaller for Duration {
  ## Returns `True` if `self` is smaller than the given `Duration`.
  ##
  ## # Examples
  ##
  ## Comparing two `Duration` objects:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_seconds(5) < Duration.from_seconds(10) # => True
  def <(other: Self) -> Boolean {
    @seconds < other.as_seconds
  }
}

impl Greater for Duration {
  ## Returns `True` if `self` is greater than the given `Duration`.
  ##
  ## # Examples
  ##
  ## Comparing two `Duration` objects:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_seconds(5) > Duration.from_seconds(10) # => False
  def >(other: Self) -> Boolean {
    @seconds > other.as_seconds
  }
}

impl SmallerOrEqual for Duration {
  ## Returns `True` if `self` is smaller than or equal to the given `Duration`.
  ##
  ## # Examples
  ##
  ## Comparing two `Duration` objects:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_seconds(5) <= Duration.from_seconds(10) # => True
  ##     Duration.from_seconds(5) <= Duration.from_seconds(5)  # => True
  def <=(other: Self) -> Boolean {
    @seconds <= other.as_seconds
  }
}

impl GreaterOrEqual for Duration {
  ## Returns `True` if `self` is greater than or equal to the given `Duration`.
  ##
  ## # Examples
  ##
  ## Comparing two `Duration` objects:
  ##
  ##     import std::time::Duration
  ##
  ##     Duration.from_seconds(5) >= Duration.from_seconds(10) # => False
  ##     Duration.from_seconds(5) >= Duration.from_seconds(5)  # => True
  def >=(other: Self) -> Boolean {
    @seconds >= other.as_seconds
  }
}

## An object representing the current system time.
##
## A `Time` object represents the current system in seconds relative to the Unix
## epoch. Due to the use of the system clock an instance of `Time` can be
## influenced by time zone changes, clock adjustments, or leap seconds. If you
## need a monotonically increasing clock you should use `MonotonicTime` instead.
object Time {
  ## Returns a new `Time` representing the current time using the local
  ## timezone.
  ##
  ## The argument is a primitive DateTime object and should not be
  ## used/specified directly by code outside of the standard library.
  def new(time = _INKOC.time_system(False)) -> Self {
    time.prototype = self
    time as Time
  }

  ## Returns a new `Time` representing the current time using the local
  ## timezone.
  ##
  ## # Examples
  ##
  ## Getting the current time:
  ##
  ##     import std::time::Time
  ##
  ##     Time.now
  def now -> Self {
    new
  }

  ## Returns a new `Time` representing the current time using UTC as the
  ## timezone.
  ##
  ## # Examples
  ##
  ## Getting the current time:
  ##
  ##     import std::time::Time
  ##
  ##     Time.now_utc
  def now_utc -> Self {
    new(_INKOC.time_system(True))
  }

  ## Returns a new `Time` from a Unix timestamp using the local timezone.
  def from_timestamp(time: ToFloat) -> Self {
    new(_INKOC.time_from_seconds(time.to_float, False))
  }

  ## Returns a new `Time` from a Unix timestamp using UTC as the timezone.
  def from_utc_timestamp(time: ToFloat) -> Self {
    new(_INKOC.time_from_seconds(time.to_float, True))
  }

  ## Returns the hour of the day from 0 to 23.
  def hour -> Integer {
    _INKOC.time_get_value(self, HOUR)
  }

  ## Returns the minute of the hour from 0 to 59.
  def minute -> Integer {
    _INKOC.time_get_value(self, MINUTE)
  }

  ## Returns the second of the minute from 0 to 60.
  def second -> Integer {
    _INKOC.time_get_value(self, SEC)
  }

  ## Returns the fractional part of the second, in seconds.
  def sub_second -> Float {
    let nsec = _INKOC.time_get_value(self, SUB_SEC)

    nsec.to_float / NANOSEC_TO_SEC
  }

  ## Returns the year of the current time.
  def year -> Integer {
    _INKOC.time_get_value(self, YEAR)
  }

  ## Returns the month of the year from 1 to 12.
  def month -> Integer {
    _INKOC.time_get_value(self, MONTH)
  }

  ## Returns the day of the month from 1 to 31.
  def day -> Integer {
    _INKOC.time_get_value(self, DAY)
  }

  ## Returns the day of the week from 1 to 7.
  ##
  ## Per ISO 8601 the first day of the week starts on Monday, not Sunday.
  def day_of_week -> Integer {
    _INKOC.time_get_value(self, DAY_OF_WEEK)
  }

  ## Returns the day of the year from 1 to 366.
  def day_of_year -> Integer {
    _INKOC.time_get_value(self, DAY_OF_YEAR)
  }

  ## Returns `True` if Daylight Saving Time is active.
  def dst? -> Boolean {
    _INKOC.time_get_value(self, DST) == 1
  }

  ## Returns the offset in seconds relative to UTC.
  def utc_offset -> Integer {
    _INKOC.time_get_value(self, UTC_OFFSET)
  }

  ## Returns `True` if UTC is used.
  def utc? -> Boolean {
    utc_offset == 0
  }

  ## Returns the number of seconds since the Unix epoch in UTC.
  def seconds_since_epoch -> Integer {
    _INKOC.time_get_value(self, SEC_SINCE_EPOCH)
  }
}

impl ToInteger for Time {
  ## Returns the timestamp since the Unix epoch.
  def to_integer -> Integer {
    seconds_since_epoch
  }
}

impl ToFloat for Time {
  ## Returns the timestamp since the Unix epoch, the including fractional
  ## seconds.
  def to_float -> Float {
    seconds_since_epoch.to_float + sub_second
  }
}

impl Add!(ToFloat) for Time {
  ## Adds the given number of seconds to `self`, returning the result as a new
  ## `Time`.
  ##
  ## # Examples
  ##
  ## Adding a `Duration` to a `Time`:
  ##
  ##     import std::time::(Duration, Time)
  ##
  ##     Time.now + Duration.from_seconds(5)
  ##
  ## Adding an `Integer` to a `Time`:
  ##
  ##     import std::time::Time
  ##
  ##     Time.now + 5
  def +(other: ToFloat) -> Self {
    let timestamp = to_float + other.to_float

    utc?.if true: {
      Time.from_utc_timestamp(timestamp)
    }, false: {
      Time.from_timestamp(timestamp)
    }
  }
}

impl Subtract!(ToFloat) for Time {
  ## Subtracts the given number of seconds from `self`, returning the result as
  ## a new `Time`.
  ##
  ## # Examples
  ##
  ## Subtracting a `Duration` from a `Time`:
  ##
  ##     import std::time::(Duration, Time)
  ##
  ##     Time.now - Duration.from_seconds(5)
  ##
  ## Subtracting an `Integer` from a `Time`:
  ##
  ##     import std::time::Time
  ##
  ##     Time.now - 5
  def -(other: ToFloat) -> Self {
    let timestamp = to_float - other.to_float

    utc?.if true: {
      Time.from_utc_timestamp(timestamp)
    }, false: {
      Time.from_timestamp(timestamp)
    }
  }
}

impl Smaller for Time {
  ## Returns `True` if `self` is smaller than the given `Time`.
  ##
  ## # Examples
  ##
  ## Comparing two `Time` objects:
  ##
  ##     import std::time::Time
  ##
  ##     let before = Time.now
  ##     let after = before + 5
  ##
  ##     before < after # => True
  def <(other: Self) -> Boolean {
    to_float < other.to_float
  }
}

impl SmallerOrEqual for Time {
  ## Returns `True` if `self` is smaller than or equal to the given `Time`.
  ##
  ## # Examples
  ##
  ## Comparing two `Time` objects:
  ##
  ##     import std::time::Time
  ##
  ##     let before = Time.now
  ##     let after = before + 5
  ##
  ##     before <= after  # => True
  ##     before <= before # => True
  def <=(other: Self) -> Boolean {
    to_float <= other.to_float
  }
}

impl Greater for Time {
  ## Returns `True` if `self` is greater than the given `Time`.
  ##
  ## # Examples
  ##
  ## Comparing two `Time` objects:
  ##
  ##     import std::time::Time
  ##
  ##     let before = Time.now
  ##     let after = before + 5
  ##
  ##     after > before # => True
  def >(other: Self) -> Boolean {
    to_float > other.to_float
  }
}

impl GreaterOrEqual for Time {
  ## Returns `True` if `self` is greater than or equal to the given `Time`.
  ##
  ## # Examples
  ##
  ## Comparing two `Time` objects:
  ##
  ##     import std::time::Time
  ##
  ##     let before = Time.now
  ##     let after = before + 5
  ##
  ##     after >= before # => True
  ##     after >= after  # => True
  def >=(other: Self) -> Boolean {
    to_float >= other.to_float
  }
}

## A monotonically increasing clock.
##
## `MonotonicTime` objects represent the number of seconds relative to an
## unspecified epoch. Unlike a system clock a monotonic clock never decreases,
## making it useful for tasks such as measuring the execution time of a block of
## code.
object MonotonicTime {
  ## Returns a `MonotonicTime` representing the current time.
  ##
  ## # Examples
  ##
  ## Getting the current time:
  ##
  ##     import std::time::MonotonicTime
  ##
  ##     MonotonicTime.now
  def now -> Self {
    new
  }

  def init(time = _INKOC.time_monotonic) {
    let @time = time
  }
}

impl ToInteger for MonotonicTime {
  ## Returns the number of seconds since the epoch.
  def to_integer -> Integer {
    @time.to_integer
  }
}

impl ToFloat for MonotonicTime {
  ## Returns the number of seconds since the epoch.
  def to_float -> Float {
    @time
  }
}

impl Add!(ToFloat) for MonotonicTime {
  ## Adds the given number of seconds to `self`, returning the result as a new
  ## `MonotonicTime`.
  ##
  ## # Examples
  ##
  ## Adding a `Duration` to a `MonotonicTime`:
  ##
  ##     import std::time::(Duration, MonotonicTime)
  ##
  ##     MonotonicTime.new + Duration.from_seconds(5)
  ##
  ## Adding an `Integer` to a `MonotonicTime`:
  ##
  ##     import std::time::MonotonicTime
  ##
  ##     MonotonicTime.now + 5
  def +(other: ToFloat) -> Self {
    MonotonicTime.new(@time + other.to_float)
  }
}

impl Subtract!(ToFloat) for MonotonicTime {
  ## Subtracts the given number of seconds from `self`, returning the result as
  ## a new `MonotonicTime`.
  ##
  ## Subtracting a `Duration` from a `MonotonicTime`:
  ##
  ##     import std::time::(Duration, MonotonicTime)
  ##
  ##     MonotonicTime.new - Duration.from_seconds(5)
  ##
  ## Subtracting an `Integer` from a `MonotonicTime`:
  ##
  ##     import std::time::MonotonicTime
  ##
  ##     MonotonicTime.now - 5
  def -(other: ToFloat) -> Self {
    MonotonicTime.new(@time - other.to_float)
  }
}

impl Smaller for MonotonicTime {
  ## Returns `True` if `self` is smaller than the given `MonotonicTime`.
  ##
  ## # Examples
  ##
  ## Comparing two `MonotonicTime` objects:
  ##
  ##     import std::time::MonotonicTime
  ##
  ##     let before = MonotonicTime.now
  ##     let after = before + 5
  ##
  ##     before < after # => True
  def <(other: Self) -> Boolean {
    to_float < other.to_float
  }
}

impl SmallerOrEqual for MonotonicTime {
  ## Returns `True` if `self` is smaller than or equal to the given
  ## `MonotonicTime`.
  ##
  ## # Examples
  ##
  ## Comparing two `MonotonicTime` objects:
  ##
  ##     import std::time::MonotonicTime
  ##
  ##     let before = MonotonicTime.now
  ##     let after = before + 5
  ##
  ##     before <= after  # => True
  ##     before <= before # => True
  def <=(other: Self) -> Boolean {
    to_float <= other.to_float
  }
}

impl Greater for MonotonicTime {
  ## Returns `True` if `self` is greater than the given `MonotonicTime`.
  ##
  ## # Examples
  ##
  ## Comparing two `MonotonicTime` objects:
  ##
  ##     import std::time::MonotonicTime
  ##
  ##     let before = MonotonicTime.now
  ##     let after = before + 5
  ##
  ##     after > before # => True
  def >(other: Self) -> Boolean {
    to_float > other.to_float
  }
}

impl GreaterOrEqual for MonotonicTime {
  ## Returns `True` if `self` is greater than or equal to the given
  ## `MonotonicTime`.
  ##
  ## # Examples
  ##
  ## Comparing two `MonotonicTime` objects:
  ##
  ##     import std::time::MonotonicTime
  ##
  ##     let before = MonotonicTime.now
  ##     let after = before + 5
  ##
  ##     after >= before # => True
  ##     after >= after  # => True
  def >=(other: Self) -> Boolean {
    to_float >= other.to_float
  }
}
