#! Operations and types for manipulating filesystem objects.
#!
#! This module contains various types and methods that can be used for operating
#! on files stored in the local filesystem.
#!
#! Unlike many other languages there's no single "File" type to represent a
#! file, instead there are different types that are used based on the mode a
#! file is opened in. For example, when opening a file in read-only mode you
#! will be given a `ReadOnlyFile` object while opening a file in write-only mode
#! produces a `WriteOnlyFile` object.

import std::conversion::ToString
import std::fs::raw::(self, READ_ONLY, WRITE_ONLY, APPEND_ONLY, READ_WRITE, READ_APPEND)
import std::fs::path::(Path, ToPath)
import std::io::(Close, Error as IOError, Read, Seek, Size, Write)
import std::process

## Trait for returning the file path of a file object.
trait FilePath {
  def path -> Path
}

## A file that can only be used for read operations.
object ReadOnlyFile {
  def init(path: ToPath) !! IOError {
    let @path = path.to_path
    let @file = try raw.open(path: @path.to_string, mode: READ_ONLY)
  }
}

## A file that can only be used for write (or append) operations.
object WriteOnlyFile {
  def init(path: ToPath, append = False) !! IOError {
    let mode = append.if true: {
      APPEND_ONLY
    }, false: {
      WRITE_ONLY
    }

    let @path = path.to_path
    let @file = try raw.open(path: @path.to_string, mode: mode)
  }

  ## Removes this file from the filesystem.
  def remove !! IOError -> Nil {
    try ThisModule.remove(@path)
  }
}

## A file that can be used for both read and write operations.
object ReadWriteFile {
  def init(path: ToPath, append = False) !! IOError {
    let mode = append.if true: {
      READ_APPEND
    }, false: {
      READ_WRITE
    }

    let @path = path.to_path
    let @file = try raw.open(path: @path.to_string, mode: mode)
  }

  ## Removes this file from the filesystem.
  def remove !! IOError -> Nil {
    try ThisModule.remove(@path)
  }
}

impl Read for ReadOnlyFile, ReadWriteFile {
  def read !! IOError -> String {
    process.await {
      try _INKOC.file_read(@file) else (err) throw IOError.new(err as String)
    }
  }

  def read_exact(amount: Integer) !! IOError -> String {
    process.await {
      try {
        _INKOC.file_read_exact(@file, amount)
      } else (err) {
        throw IOError.new(err as String)
      }
    }
  }
}

impl Write for WriteOnlyFile, ReadWriteFile {
  def write(data: ToString) !! IOError -> Integer {
    process.await {
      try {
        _INKOC.file_write(@file, data.to_string)
      } else (err) {
        throw IOError.new(err as String)
      }
    }
  }

  def flush !! IOError -> Nil {
    process.await {
      try _INKOC.file_flush(@file) else (err) throw IOError.new(err as String)
    }
  }
}

impl Seek for ReadOnlyFile, WriteOnlyFile, ReadWriteFile {
  def seek(position: Integer) !! IOError -> Integer {
    process.await {
      try {
        _INKOC.file_seek(@file, position)
      } else (err) {
        throw IOError.new(err as String)
      }
    }
  }
}

impl Size for ReadOnlyFile, WriteOnlyFile, ReadWriteFile {
  def size !! IOError -> Integer {
    try ThisModule.size(@path)
  }
}

impl FilePath for ReadOnlyFile, WriteOnlyFile, ReadWriteFile {
  def path -> Path {
    @path
  }
}

impl Close for ReadOnlyFile, WriteOnlyFile, ReadWriteFile {
  def close -> Nil {
    _INKOC.drop(@file)
  }
}

## Removes the file for the given file path.
##
## # Examples
##
## Removing a file:
##
##     import std::fs::file
##
##     let handle = try! file.write_only('/tmp/test.txt')
##
##     try! handle.write('hello')
##     try! file.remove('/tmp/test.txt') # => Nil
def remove(path: ToPath) !! IOError -> Nil {
  try raw.remove(path.to_path.to_string)
}

## Copies a file from the source destination to the target destination,
## returning the number of copied bytes.
##
## # Examples
##
## Copying a file:
##
##     import std::fs::file
##
##     let handle = try! file.write_only('/tmp/test.txt')
##
##     try! handle.write('hello')
##     try! file.copy(from: '/tmp/test.txt', to: '/tmp/test2.txt')
def copy(from: ToPath, to: ToPath) !! IOError -> Integer {
  try raw.copy(from: from.to_path.to_string, to: to.to_path.to_string)
}

## Returns the file size (in bytes) of the given path.
##
## # Examples
##
## Getting the size of a path:
##
##     import std::fs::file
##
##     try! file.size('/dev/null') # => 0
def size(path: ToPath) !! IOError -> Integer {
  try raw.size(path.to_path.to_string)
}

## Opens a file that can only be used for reading data.
def read_only(path: ToPath) !! IOError -> ReadOnlyFile {
  try ReadOnlyFile.new(path)
}

## Opens a file that can only be used for writing data.
def write_only(path: ToPath) !! IOError -> WriteOnlyFile {
  try WriteOnlyFile.new(path)
}

## Opens a file that can only be used for appending data.
def append_only(path: ToPath) !! IOError -> WriteOnlyFile {
  try WriteOnlyFile.new(path: path, append: True)
}

## Opens a file that can be used for both reading and writing data.
def read_write(path: ToPath) !! IOError -> ReadWriteFile {
  try ReadWriteFile.new(path: path)
}

## Opens a file that can be used for both reading and appending data.
def read_append(path: ToPath) !! IOError -> ReadWriteFile {
  try ReadWriteFile.new(path: path, append: True)
}
