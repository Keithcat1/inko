#! Operations and types for manipulating filesystem objects.
#!
#! This module contains various types and methods that can be used for operating
#! on files stored in the local filesystem.
#!
#! Unlike many other languages there's no single "File" type to represent a
#! file, instead there are different types that are used based on the mode a
#! file is opened in. For example, when opening a file in read-only mode you
#! will be given a `ReadOnlyFile` object while opening a file in write-only mode
#! produces a `WriteOnlyFile` object.

import std::conversion::ToString
import std::fs::path::(Path, ToPath)
import std::fs::raw::(self, CREATED_AT, MODIFIED_AT, ACCESSED_AT, READ_ONLY)
import std::io::(Close, Error as IOError, Read, Seek, Size, Write)
import std::process
import std::time::SystemTime

## Trait for returning the file path of a file object.
trait FilePath {
  def path -> Path
}

## An object that allows the removal of an associated file on the filesystem.
trait Remove {}

## A file that can only be used for read operations.
object ReadOnlyFile {
  ## Returns a new `ReadOnlyFile`.
  ##
  ## # Examples
  ##
  ## Opening a file in read-only mode:
  ##
  ##     import std::fs::file::ReadOnlyFile
  ##
  ##     let handle = try! ReadOnlyFile.new('/dev/null')
  def new(path: ToPath) !! IOError -> Self {
    let conv_path = path.to_path
    let file = try {
      raw.open(path: conv_path.to_string, mode: READ_ONLY)
    } as ReadOnlyFile

    file.prototype = self
    file.init(conv_path)
    file
  }

  def init(path: Path) {
    let @path = path
  }
}

## A file that can only be used for write (or append) operations.
object WriteOnlyFile {
  ## Returns a new `WriteOnlyFile`.
  ##
  ## # Examples
  ##
  ## Opening a file in write-only mode:
  ##
  ##     import std::fs::file::WriteOnlyFile
  ##
  ##     let handle = try! WriteOnlyFile.new('/dev/null')
  def new(path: ToPath, append = False) !! IOError -> Self {
    let mode = raw.mode_for_write(append)
    let conv_path = path.to_path
    let file = try {
      raw.open(path: conv_path.to_string, mode: mode)
    } as WriteOnlyFile

    file.prototype = self
    file.init(conv_path)
    file
  }

  def init(path: Path) {
    let @path = path
  }
}

## A file that can be used for both read and write operations.
object ReadWriteFile {
  ## Returns a new `ReadWriteFile`.
  ##
  ## # Examples
  ##
  ## Opening a file for both reads and writes:
  ##
  ##     import std::fs::file::ReadWriteFile
  ##
  ##     let handle = try! ReadWriteFile.new('/dev/null')
  def new(path: ToPath, append = False) !! IOError -> Self {
    let mode = raw.mode_for_read_write(append)
    let conv_path = path.to_path
    let file = try {
      raw.open(path: conv_path.to_string, mode: mode)
    } as ReadWriteFile

    file.prototype = self
    file.init(conv_path)
    file
  }

  def init(path: Path) {
    let @path = path
  }
}

impl Read for ReadOnlyFile, ReadWriteFile {
  def read !! IOError -> String {
    process.await {
      try _INKOC.file_read(self) else (err) throw IOError.new(err as String)
    }
  }

  def read_exact(amount: Integer) !! IOError -> String {
    process.await {
      try {
        _INKOC.file_read_exact(self, amount)
      } else (err) {
        throw IOError.new(err as String)
      }
    }
  }
}

impl Write for WriteOnlyFile, ReadWriteFile {
  def write(data: ToString) !! IOError -> Integer {
    process.await {
      try {
        _INKOC.file_write(self, data.to_string)
      } else (err) {
        throw IOError.new(err as String)
      }
    }
  }

  def flush !! IOError -> Nil {
    process.await {
      try _INKOC.file_flush(self) else (err) throw IOError.new(err as String)
    }
  }
}

impl Seek for ReadOnlyFile, WriteOnlyFile, ReadWriteFile {
  def seek(position: Integer) !! IOError -> Integer {
    process.await {
      try {
        _INKOC.file_seek(self, position)
      } else (err) {
        throw IOError.new(err as String)
      }
    }
  }
}

impl Size for ReadOnlyFile, WriteOnlyFile, ReadWriteFile {
  def size !! IOError -> Integer {
    try ThisModule.size(@path)
  }
}

impl FilePath for ReadOnlyFile, WriteOnlyFile, ReadWriteFile {
  def path -> Path {
    @path
  }
}

impl Close for ReadOnlyFile, WriteOnlyFile, ReadWriteFile {
  def close -> Nil {
    _INKOC.drop(self)
  }
}

impl Remove for WriteOnlyFile, ReadWriteFile {
  ## Removes the file.
  def remove !! IOError -> Nil {
    try ThisModule.remove(@path)
  }
}

## Removes the file for the given file path.
##
## # Examples
##
## Removing a file:
##
##     import std::fs::file
##
##     let handle = try! file.write_only('/tmp/test.txt')
##
##     try! handle.write('hello')
##     try! file.remove('/tmp/test.txt') # => Nil
def remove(path: ToPath) !! IOError -> Nil {
  try raw.remove(path.to_path.to_string)
}

## Copies a file from the source destination to the target destination,
## returning the number of copied bytes.
##
## # Examples
##
## Copying a file:
##
##     import std::fs::file
##
##     let handle = try! file.write_only('/tmp/test.txt')
##
##     try! handle.write('hello')
##     try! file.copy(from: '/tmp/test.txt', to: '/tmp/test2.txt')
def copy(from: ToPath, to: ToPath) !! IOError -> Integer {
  try raw.copy(from: from.to_path.to_string, to: to.to_path.to_string)
}

## Returns the file size (in bytes) of the given path.
##
## # Examples
##
## Getting the size of a path:
##
##     import std::fs::file
##
##     try! file.size('/dev/null') # => 0
def size(path: ToPath) !! IOError -> Integer {
  try raw.size(path.to_path.to_string)
}

## Returns the creation time of a path.
def created_at(path: ToPath) !! IOError -> SystemTime {
  try raw.file_time(path.to_path.to_string, CREATED_AT)
}

## Returns the modification time of a path.
def modified_at(path: ToPath) !! IOError -> SystemTime {
  try raw.file_time(path.to_path.to_string, MODIFIED_AT)
}

## Returns the access time of a path.
def accessed_at(path: ToPath) !! IOError -> SystemTime {
  try raw.file_time(path.to_path.to_string, ACCESSED_AT)
}

## Opens a file that can only be used for reading data.
def read_only(path: ToPath) !! IOError -> ReadOnlyFile {
  try ReadOnlyFile.new(path)
}

## Opens a file that can only be used for writing data.
def write_only(path: ToPath) !! IOError -> WriteOnlyFile {
  try WriteOnlyFile.new(path)
}

## Opens a file that can only be used for appending data.
def append_only(path: ToPath) !! IOError -> WriteOnlyFile {
  try WriteOnlyFile.new(path: path, append: True)
}

## Opens a file that can be used for both reading and writing data.
def read_write(path: ToPath) !! IOError -> ReadWriteFile {
  try ReadWriteFile.new(path: path)
}

## Opens a file that can be used for both reading and appending data.
def read_append(path: ToPath) !! IOError -> ReadWriteFile {
  try ReadWriteFile.new(path: path, append: True)
}
