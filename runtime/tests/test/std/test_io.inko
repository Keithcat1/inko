import std::io::(Error, INVALID_INPUT, NOT_FOUND, Read, Write)
import std::os::NEWLINE
import std::test
import std::test::assert

class Reader {
  static def new -> Self {
    Self {}
  }
}

impl Read for Reader {
  def read_bytes(bytes: ByteArray, size = 0) -> Integer {
    let input = Array.new(105, 110, 107, 111)
    let max = size.positive?.if(true: { size }, false: { input.length })
    let mut index = 0

    while({ index < max }) {
      bytes.push(input[index])
      index += 1
    }

    max
  }
}

class Writer {
  @buffer: Array!(String)

  static def new -> Self {
    Self { @buffer = Array.new }
  }

  def buffer -> Array!(String) {
    @buffer
  }
}

impl Write for Writer {
  def write_bytes(bytes: ByteArray) -> Integer {
    0
  }

  def flush {}

  def write_string(string: String) -> Integer {
    @buffer.push(string)

    string.length
  }
}

test.group('std::io::Error.new') do (g) {
  g.test('Creating an Error for an error code') {
    let error = Error.new(NOT_FOUND)

    assert.equal(error.code, NOT_FOUND)
    assert.equal(error.message, 'The resource could not be found')
  }
}

test.group('std::io::Error.invalid_input') do (g) {
  g.test('Creating a custom Error for invalid input') {
    let error = Error.invalid_input('testing')

    assert.equal(error.code, INVALID_INPUT)
    assert.equal(error.message, 'testing')
  }
}

test.group('std::io::Read.read_string') do (g) {
  g.test('Reading all bytes into a String') {
    let reader = Reader.new
    let string = try! reader.read_string

    assert.equal(string, 'inko')
  }

  g.test('Reading a limited number of bytes into a String') {
    let reader = Reader.new
    let string = try! reader.read_string(size: 2)

    assert.equal(string, 'in')
  }
}

test.group('std::io::Write.print') do (g) {
  g.test('Printing a String') {
    let writer = Writer.new
    let written = try! writer.print('inko')

    assert.equal(written, 5)
    assert.equal(writer.buffer, Array.new('inko', "\n"))
  }
}
