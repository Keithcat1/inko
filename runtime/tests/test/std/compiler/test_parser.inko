import std::compiler::ast::blocks::*
import std::compiler::ast::body::Body
import std::compiler::ast::comments::*
import std::compiler::ast::control_flow::*
import std::compiler::ast::imports::Import
import std::compiler::ast::literals::*
import std::compiler::ast::node::Node
import std::compiler::ast::objects::*
import std::compiler::ast::operators::*
import std::compiler::ast::pattern_matching::*
import std::compiler::ast::send::*
import std::compiler::ast::types::*
import std::compiler::ast::variables::*
import std::compiler::parser::Parser
import std::conversion::ToString
import std::mirror::ObjectMirror
import std::test
import std::test::assert

def instance_of(node: Node, instance_of: Node) -> Boolean {
  ObjectMirror.new(node).instance_of?(instance_of)
}

def assert_instance_of(node: Node, instance_of: Node) {
  assert.true(instance_of(node, instance_of))
}

def parse(input: String) -> Body {
  let parser = Parser.new(input: input, file: 'test.inko')

  try! parser.parse
}

def parse_as!(T: Node)(input: ToString, type: T) -> T {
  let parser = Parser.new(input: input.to_string, file: 'test.inko')
  let nodes = try! parser.parse
  let node = nodes.children[0]

  assert_instance_of(node, type)

  node as T
}

def binary_send(operator: String) {
  let node = parse_as(input: `1 {operator} 2`, type: Send)

  assert.equal(node.message, operator)
  assert.equal(node.arguments.length, 1)

  let rec = node.receiver as IntegerLiteral
  let arg = node.arguments[0] as IntegerLiteral

  assert.equal(rec.value, '1')
  assert.equal(arg.value, '2')
}

def binary_assign_local(operator: String, message: String) {
  let node = parse_as(input: `foo {operator} 10`, type: AssignLocal)

  assert_instance_of(node.value, Send)

  let send = node.value as Send

  assert.equal(send.message, message)
  assert.equal(send.arguments.length, 1)

  assert_instance_of(send.receiver, Identifier)
  assert.equal((send.receiver as Identifier).name, 'foo')

  assert_instance_of(send.arguments[0], IntegerLiteral)
  assert.equal((send.arguments[0] as IntegerLiteral).value, '10')
}

def binary_assign_attribute(operator: String, message: String) {
  let node = parse_as(input: `@foo {operator} 10`, type: AssignAttribute)

  assert_instance_of(node.value, Send)

  let send = node.value as Send

  assert.equal(send.message, message)
  assert.equal(send.arguments.length, 1)

  assert_instance_of(send.receiver, Attribute)
  assert.equal((send.receiver as Attribute).name, '@foo')

  assert_instance_of(send.arguments[0], IntegerLiteral)
  assert.equal((send.arguments[0] as IntegerLiteral).value, '10')
}

test.group('Parsing import expressions') do (g) {
  g.test('Importing a module') {
    let node = parse_as(input: 'import foo', type: Import)

    assert.equal(node.location.column, 1)

    assert.equal(node.path[0].name, 'foo')
    assert.equal(node.path[0].location.column, 8)
  }

  g.test('Importing a child module') {
    let node = parse_as(input: 'import foo::bar', type: Import)

    assert.equal(node.path[0].name, 'foo')
    assert.equal(node.path[0].location.column, 8)

    assert.equal(node.path[1].name, 'bar')
    assert.equal(node.path[1].location.column, 13)
  }

  g.test('Importing a module that uses the same name as a keyword') {
    let node = parse_as(input: 'import import::where', type: Import)

    assert.equal(node.path[0].name, 'import')
    assert.equal(node.path[0].location.column, 8)

    assert.equal(node.path[1].name, 'where')
    assert.equal(node.path[1].location.column, 16)
  }

  g.test('Importing a single symbol') {
    let node = parse_as(input: 'import std::foo::(bar)', type: Import)

    assert.equal(node.symbols[0].name, 'bar')
    assert.false(node.symbols[0].import_self?)
    assert.equal(node.symbols[0].location.column, 19)
  }

  g.test('Importing a single symbol with an alias') {
    let node = parse_as(input: 'import std::foo::(bar as baz)', type: Import)

    assert.equal(node.symbols[0].name, 'bar')
    assert.false(node.symbols[0].import_self?)
    assert.equal(node.symbols[0].location.column, 19)

    assert.equal(node.symbols[0].alias.get.name, 'baz')
    assert.equal(node.symbols[0].alias.get.location.column, 26)
  }

  g.test('Importing an identifier aliased as a constant') {
    assert.panic { parse('import std::foo::(bar as Baz)') }
  }

  g.test('Importing a constant aliased as an identifier') {
    assert.panic { parse('import std::foo::(Baz as baz)') }
  }

  g.test('Importing multiple symbols') {
    let node = parse_as(input: 'import std::foo::(bar, baz)', type: Import)

    assert.equal(node.symbols[0].name, 'bar')
    assert.equal(node.symbols[0].location.column, 19)

    assert.equal(node.symbols[1].name, 'baz')
    assert.equal(node.symbols[1].location.column, 24)
  }

  g.test('Importing a module using the self keyword') {
    let node = parse_as(input: 'import std::(self)', type: Import)

    assert.equal(node.symbols[0].name, 'self')
    assert.equal(node.symbols[0].location.column, 14)
    assert.true(node.symbols[0].import_self?)
  }

  g.test('Importing a module itself using an identifier as the alias') {
    let node = parse_as(input: 'import std::(self as foo)', type: Import)

    assert.equal(node.symbols[0].name, 'self')
    assert.equal(node.symbols[0].location.column, 14)
    assert.true(node.symbols[0].import_self?)

    assert.equal(node.symbols[0].alias.get.name, 'foo')
    assert.equal(node.symbols[0].alias.get.location.column, 22)
  }

  g.test('Importing a module itself using a constant as the alias') {
    assert.panic { parse('import std::(self as Bar)') }
  }

  g.test('Importing a single symbol with a trailing comma') {
    let node = parse_as(input: 'import std::foo::(bar,)', type: Import)

    assert.equal(node.symbols[0].name, 'bar')
    assert.false(node.symbols[0].import_self?)
    assert.equal(node.symbols[0].location.column, 19)
  }

  g.test('Importing a wildcard') {
    let node = parse_as(input: 'import std::foo::*', type: Import)

    assert.true(node.import_all?)
    assert.true(node.symbols.empty?)
  }

  g.test('Importing a wildcard and specific symbols') {
    assert.panic { parse('import foo::(*, bar)') }
  }

  g.test('Importing a module using an invalid import path') {
    assert.panic { parse('import foo::') }
    assert.panic { parse('import foo::10') }
  }

  g.test('Importing a module with an invalid symbol list') {
    assert.panic { parse('import foo::(bar baz)') }
  }

  g.test('Importing a module with a symbol alias that is missing a name') {
    assert.panic { parse('import foo::(bar as)') }
  }

  g.test('Obtaining a module name from an import expression') {
    let node = parse_as(input: 'import std::foo::*', type: Import)
    let name = node.module_name

    assert.equal(name.components, Array.new('std', 'foo'))
  }
}

test.group('Parsing literls') do (g) {
  g.test('Parsing an integer literal') {
    let node = parse_as(input: '10', type: IntegerLiteral)

    assert.equal(node.value, '10')
    assert.equal(node.location.column, 1)
  }

  g.test('Parsing a float literal') {
    let node = parse_as(input: '10.5', type: FloatLiteral)

    assert.equal(node.value, '10.5')
    assert.equal(node.location.column, 1)
  }

  g.test('Parsing a string literal') {
    let node = parse_as(input: '"hello"', type: StringLiteral)

    assert.equal(node.value, 'hello')
    assert.equal(node.location.column, 1)
  }
}

test.group('Parsing object definitions') do (g) {
  g.test('Parsing an empty body') {
    let node = parse_as(input: 'object A {}', type: DefineObject)

    assert.equal(node.name, 'A')
    assert.true(node.body.children.empty?)
    assert.equal(node.body.location.column, 10)
  }

  g.test('Parsing an object definition with type parameters') {
    let node = parse_as(
      input: 'object A!(One: A, Two: B + C) {}',
      type: DefineObject
    )

    let params = node.type_parameters

    assert.equal(params.length, 2)

    assert.equal(params[0].name, 'One')
    assert.equal(params[0].location.column, 11)

    assert.equal(params[0].required_traits[0].name, 'A')
    assert.equal(params[0].required_traits[0].location.column, 16)

    assert.equal(params[1].name, 'Two')
    assert.equal(params[1].location.column, 19)

    assert.equal(params[1].required_traits[0].name, 'B')
    assert.equal(params[1].required_traits[0].location.column, 24)

    assert.equal(params[1].required_traits[1].name, 'C')
    assert.equal(params[1].required_traits[1].location.column, 28)
  }

  g.test('Parsing an invalid list of type parameters') {
    assert.panic { parse('object A!(Foo, {}') }
  }

  g.test('Parsing an object body without a closing curly brace') {
    assert.panic { parse('object A {') }
  }

  g.test('Parsing an object body with invalid child nodes') {
    assert.panic { parse('object A { 10 }') }
  }

  g.test('Parsing an object without a name') {
    assert.panic { parse('object {}') }
  }

  g.test('Parsing an object containing a method') {
    let node =
      parse_as(input: 'object A { def foo {} }', type: DefineObject)

    assert_instance_of(node.body.children[0], DefineMethod)
  }

  g.test('Parsing an object containing attribute definitions') {
    let node =
      parse_as(input: 'object A { @a: A @b: B }', type: DefineObject)

    assert.equal(node.body.children.length, 2)

    let attr1 = node.body.children[0] as DefineAttribute
    let attr2 = node.body.children[1] as DefineAttribute

    assert.equal(attr1.name, '@a')
    assert.equal((attr1.value_type as Constant).name, 'A')

    assert.equal(attr2.name, '@b')
    assert.equal((attr2.value_type as Constant).name, 'B')
  }

  g.test('Parsing an object defining a required method') {
    assert.panic { parse('object A { def foo }') }
  }
}

test.group('Parsing trait definitions') do (g) {
  g.test('Parsing an empty body') {
    let node = parse_as(input: 'trait A {}', type: DefineTrait)

    assert.equal(node.name, 'A')
    assert.true(node.body.children.empty?)
    assert.equal(node.body.location.column, 9)
  }

  g.test('Parsing a trait definition with type parameters') {
    let node = parse_as(
      input: 'trait A!(One: A, Two: B + C) {}',
      type: DefineTrait
    )

    let params = node.type_parameters

    assert.equal(params.length, 2)

    assert.equal(params[0].name, 'One')
    assert.equal(params[0].location.column, 10)

    assert.equal(params[0].required_traits[0].name, 'A')
    assert.equal(params[0].required_traits[0].location.column, 15)

    assert.equal(params[1].name, 'Two')
    assert.equal(params[1].location.column, 18)

    assert.equal(params[1].required_traits[0].name, 'B')
    assert.equal(params[1].required_traits[0].location.column, 23)

    assert.equal(params[1].required_traits[1].name, 'C')
    assert.equal(params[1].required_traits[1].location.column, 27)
  }

  g.test('Parsing a list of required traits') {
    let node = parse_as(input: 'trait A: B + C {}', type: DefineTrait)

    let traits = node.required_traits

    assert.equal(traits.length, 2)

    assert.equal(traits[0].name, 'B')
    assert.equal(traits[0].location.column, 10)

    assert.equal(traits[1].name, 'C')
    assert.equal(traits[1].location.column, 14)
  }

  g.test('Parsing an invalid list of type parameters') {
    assert.panic { parse('trait A!(Foo, {}') }
  }

  g.test('Parsing a trait body without a closing curly brace') {
    assert.panic { parse('trait A {') }
  }

  g.test('Parsing a trait body with invalid child nodes') {
    assert.panic { parse('trait A { 10 }') }
  }

  g.test('Parsing a trait without a name') {
    assert.panic { parse('trait {}') }
  }

  g.test('Parsing a trait containing a method') {
    let node =
      parse_as(input: 'trait A { def foo {} }', type: DefineTrait)

    assert_instance_of(node.body.children[0], DefineMethod)
  }

  g.test('Parsing a trait with a required method') {
    let node = parse_as(
      input: 'trait A { def foo(a: A) !! B -> C => D }',
      type: DefineTrait
    )

    let method = node.body.children[0] as DefineRequiredMethod
    let argument = method.arguments[0] as DefineRequiredArgument

    assert_instance_of(method, DefineRequiredMethod)
    assert_instance_of(argument, DefineRequiredArgument)

    assert.equal(method.name, 'foo')

    assert.equal(method.arguments.length, 1)
    assert.equal(argument.name, 'a')
    assert.equal((argument.value_type as Constant).name, 'A')

    assert.equal((method.throw_type.get as Constant).name, 'B')
    assert.equal((method.return_type.get as Constant).name, 'C')
    assert.equal((method.yield_type.get as Constant).name, 'D')
  }

  g.test('Parsing a trait containing a static method') {
    assert.panic { parse('trait A { static def foo {} }') }
  }

  g.test('Parsing a trait containing a static required method') {
    assert.panic { parse('trait A { static def foo }') }
  }

  g.test('Parsing a required method outside of a trait') {
    assert.panic { parse('def foo(a: Integer)') }
  }

  g.test('Parsing a trait that defines an attribute') {
    assert.panic { parse('trait A { @number: A }') }
  }
}

test.group('Parsing implementation blocks') do (g) {
  g.test('Reopening an object without type parameters') {
    let node = parse_as(input: 'impl A {}', type: ReopenObject)

    assert.equal(node.name.name, 'A')
    assert.equal(node.name.location.column, 6)

    assert.true(node.body.children.empty?)
  }

  g.test('Implementing a trait') {
    let node = parse_as(input: 'impl A for B {}', type: ImplementTrait)

    assert.equal(node.trait_name.name, 'A')
    assert.equal(node.trait_name.location.column, 6)

    assert.equal(node.object_name.name, 'B')
    assert.equal(node.object_name.location.column, 12)
  }

  g.test('Implementing a trait with type arguments') {
    let node = parse_as(input: 'impl A!(C) for B {}', type: ImplementTrait)

    assert.equal(node.trait_name.name, 'A')
    assert.equal((node.trait_name.type_arguments[0] as Constant).name, 'C')

    assert.equal(node.object_name.name, 'B')
    assert.true(node.object_name.type_arguments.empty?)
  }

  g.test('Implementing a trait with type parameter bounds') {
    let node =
      parse_as(input: 'impl A for B when C: D, E: F {}', type: ImplementTrait)

    let bounds = node.type_parameter_bounds

    assert.equal(bounds[0].name, 'C')
    assert.equal(bounds[0].required_traits[0].name, 'D')

    assert.equal(bounds[1].name, 'E')
    assert.equal(bounds[1].required_traits[0].name, 'F')
  }

  g.test('Reopening an object while specifying type parameters') {
    assert.panic { parse('impl Foo!(A) {}') }
  }

  g.test('Specifying object type parameters when implementing a trait') {
    assert.panic { parse('impl Foo for Bar!(A) {}') }
  }

  g.test('Reopening an object without closing the body') {
    assert.panic { parse('impl Foo {') }
  }

  g.test('Reopening an object with an invalid name') {
    assert.panic { parse('impl foo {}') }
  }

  g.test('Implementing a trait without closing the body') {
    assert.panic { parse('impl A for B {') }
  }

  g.test('Implementing a trait with an invalid name') {
    assert.panic { parse('impl a for B {}') }
  }

  g.test('Implementing a trait for an object with an invalid name') {
    assert.panic { parse('impl A for b {}') }
  }

  g.test('Implementing a trait with invalid type parameter bounds') {
    assert.panic { parse('impl A for B when C: {}') }
  }

  g.test('Implementing a trait while defining an attribute') {
    assert.panic { parse('impl A for B { @number: A }') }
  }

  g.test('Reopening an object while defining an attribute') {
    assert.panic { parse('impl A { @number: A }') }
  }

  g.test('Implementing a static method for a trait') {
    assert.panic { parse('impl A for B { static def foo {} }') }
  }

  g.test('Parsing an implementation block containing a method') {
    let node =
      parse_as(input: 'impl A { def foo {} }', type: ReopenObject)

    assert_instance_of(node.body.children[0], DefineMethod)
  }
}

test.group('Parsing comments') do (g) {
  g.test('Parsing comments with the comments option disabled') {
    let parser = Parser.new(input: '# Foo', file: 'test.inko')
    let node = try! parser.parse

    assert.true(node.children.empty?)
    assert.true(parser.comments.empty?)
  }

  g.test('Parsing a comment') {
    let parser =
      Parser.new(input: '# Foo', file: 'test.inko', parse_comments: True)

    let node = try! parser.parse

    assert.true(node.children.empty?)
    assert.equal(parser.comments.length, 1)

    let comment = parser.comments[0]

    assert.equal(comment.text, ' Foo')
    assert.equal(comment.location.column, 1)
    assert.equal(comment.location.line_range, 1..1)
  }

  g.test('Parsing a comment inside a list of message arguments') {
    let parser = Parser.new(
      input: "foo(\n# bar\n10)",
      file: 'test.inko',
      parse_comments: True
    )

    let exprs = try! parser.parse
    let send = exprs.children[0] as Send

    assert_instance_of(send, Send)
    assert_instance_of(send.arguments[0], IntegerLiteral)
    assert.equal(send.arguments.length, 1)

    let comment = parser.comments[0]

    assert.equal(comment.text, ' bar')
    assert.equal(comment.location.column, 1)
    assert.equal(comment.location.line_range, 2..2)
  }
}

test.group('Parsing binary expressions') do (g) {
  g.test('Parsing an OR expression') {
    binary_send(operator: '|')
  }

  g.test('Parsing an AND expression') {
    binary_send(operator: '&')
  }

  g.test('Parsing an XOR expression') {
    binary_send(operator: '^')
  }

  g.test('Parsing an addition expression') {
    binary_send(operator: '+')
  }

  g.test('Parsing an division expression') {
    binary_send(operator: '/')
  }

  g.test('Parsing a modulo expression') {
    binary_send(operator: '%')
  }

  g.test('Parsing a multiplication expression') {
    binary_send(operator: '*')
  }

  g.test('Parsing a power expression') {
    binary_send(operator: '**')
  }

  g.test('Parsing a subtraction expression') {
    binary_send(operator: '-')
  }

  g.test('Parsing an equality expression') {
    binary_send(operator: '==')
  }

  g.test('Parsing an unequality expression') {
    binary_send(operator: '!=')
  }

  g.test('Parsing a lower-than expression') {
    binary_send(operator: '<')
  }

  g.test('Parsing a lower-than-or-equal-to expression') {
    binary_send(operator: '<=')
  }

  g.test('Parsing a greater-than expression') {
    binary_send(operator: '>')
  }

  g.test('Parsing a greater-than-or-equal-to expression') {
    binary_send(operator: '>=')
  }

  g.test('Parsing a shift-left expression') {
    binary_send(operator: '<<')
  }

  g.test('Parsing a shift-right expression') {
    binary_send(operator: '>>')
  }

  g.test('Parsing an inclusive range') {
    binary_send(operator: '..')
  }

  g.test('Parsing an exclusive range') {
    binary_send(operator: '..')
  }

  g.test('Parsing a type cast expression') {
    let node = parse_as(input: '10 as B', type: TypeCast)
    let expr = node.expression as IntegerLiteral

    assert.equal(expr.value, '10')
    assert.equal((node.cast_to as Constant).name, 'B')
  }

  g.test('Parsing a type cast chain') {
    let cast1 = parse_as(input: '10 as B as C', type: TypeCast)
    let cast2 = cast1.expression as TypeCast
    let expr = cast2.expression as IntegerLiteral

    assert.equal(expr.value, '10')
    assert.equal((cast1.cast_to as Constant).name, 'C')
    assert.equal((cast2.cast_to as Constant).name, 'B')
  }
}

test.group('Parsing message send chains') do (g) {
  g.test('Sending a message to a receiver') {
    let node = parse_as(input: '10.foo', type: Send)
    let receiver = node.receiver as IntegerLiteral

    assert.equal(receiver.value, '10')
    assert.equal(node.message, 'foo')
    assert.true(node.arguments.empty?)
  }

  g.test('Sending a chain of messages') {
    let node = parse_as(input: '10.foo.bar', type: Send)
    let receiver = node.receiver as Send

    assert.equal(receiver.message, 'foo')
    assert.equal(node.message, 'bar')
    assert.true(node.arguments.empty?)

    assert.equal((receiver.receiver as IntegerLiteral).value, '10')
  }

  g.test('Sending a message with arguments') {
    let node = parse_as(input: '10.foo(20, 30)', type: Send)

    assert.equal(node.arguments.length, 2)
    assert.equal((node.arguments[0] as IntegerLiteral).value, '20')
    assert.equal((node.arguments[1] as IntegerLiteral).value, '30')
  }

  g.test('Sending a message with arguments followed by another message') {
    let node = parse_as(input: '10.foo(20, 30).bar', type: Send)

    assert.equal(node.message, 'bar')
    assert.equal(node.arguments.length, 0)
  }

  g.test('Sending a message with type arguments') {
    let node = parse_as(input: '10.foo!(A)', type: Send)

    assert.true(node.arguments.empty?)
    assert.equal(node.type_arguments.length, 1)
    assert.equal((node.type_arguments[0] as Constant).name, 'A')
  }

  g.test('Sending a message with a closure as the type argument') {
    let node = parse_as(input: '10.foo!(do (A, B) !! A -> B)', type: Send)

    assert.equal(node.type_arguments.length, 1)

    let closure = node.type_arguments[0] as ClosureType

    assert.equal(closure.arguments.length, 2)
    assert.equal((closure.arguments[0] as Constant).name, 'A')
    assert.equal((closure.arguments[1] as Constant).name, 'B')

    assert.equal((closure.throw_type.get as Constant).name, 'A')
    assert.equal((closure.return_type.get as Constant).name, 'B')
  }

  g.test('Sending a message with a lambda as the type argument') {
    let node = parse_as(input: '10.foo!(lambda (A, B) !! A -> B)', type: Send)

    assert.equal(node.type_arguments.length, 1)

    let closure = node.type_arguments[0] as LambdaType

    assert.equal(closure.arguments.length, 2)
    assert.equal((closure.arguments[0] as Constant).name, 'A')
    assert.equal((closure.arguments[1] as Constant).name, 'B')

    assert.equal((closure.throw_type.get as Constant).name, 'A')
    assert.equal((closure.return_type.get as Constant).name, 'B')
  }

  g.test('Sending a message with an optional type arguments') {
    let node = parse_as(input: '10.foo!(?A)', type: Send)

    assert.equal(node.type_arguments.length, 1)

    let arg = node.type_arguments[0] as OptionType
    let wrapped = arg.type as Constant

    assert.equal(arg.location.column, 9)
    assert.equal(wrapped.name, 'A')
    assert.equal(wrapped.location.column, 10)
  }

  g.test('Sending a message with type arguments and normal arguments') {
    let node = parse_as(input: '10.foo!(A)(20, 30)', type: Send)

    assert.equal(node.type_arguments.length, 1)
    assert.equal((node.type_arguments[0] as Constant).name, 'A')

    assert.equal(node.arguments.length, 2)
    assert.equal((node.arguments[0] as IntegerLiteral).value, '20')
    assert.equal((node.arguments[1] as IntegerLiteral).value, '30')
  }

  g.test('Using a binary operator as a message') {
    let node = parse_as(input: '10.<(20)', type: Send)

    assert.equal(node.message, '<')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Using a keyword as a message') {
    let node = parse_as(input: '10.object(20)', type: Send)

    assert.equal(node.message, 'object')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Using a constant as a message') {
    let node = parse_as(input: '10.Foo(20)', type: Send)

    assert.equal(node.message, 'Foo')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Using [] as a message') {
    let node = parse_as(input: '10.[](20)', type: Send)

    assert.equal(node.message, '[]')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Using []= as a message') {
    let node = parse_as(input: '10.[]=(20)', type: Send)

    assert.equal(node.message, '[]=')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Parsing a message chain with parentheses separated by whitespace') {
    let node = parse_as(input: '10.foo (20)', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
    assert.equal((node.arguments[0] as IntegerLiteral).value, '20')
  }

  g.test('Parsing a message chain using a keyword argument') {
    let node = parse_as(input: '10.foo(10, b: 20)', type: Send)

    assert.equal(node.arguments.length, 2)

    let arg1 = node.arguments[0] as IntegerLiteral
    let arg2 = node.arguments[1] as KeywordArgument

    assert.equal(arg1.value, '10')
    assert.equal(arg2.name.name, 'b')
    assert.equal((arg2.value as IntegerLiteral).value, '20')
  }

  g.test('Parsing a message chain followed by parentheses on a new line') {
    let nodes = parse(input: "10.foo\n(30)").children
    let send = nodes[0] as Send

    assert.equal(nodes.length, 2)
    assert.equal(send.message, 'foo')
    assert.true(send.arguments.empty?)
  }

  g.test('Parsing a message send chain that sets an attribute') {
    let node = parse_as(input: '10.foo.bar = 20', type: Send)
    let receiver = node.receiver as Send

    assert.equal(node.message, 'bar=')
    assert.equal(node.arguments.length, 1)
    assert.equal(receiver.message, 'foo')

    let argument = node.arguments[0] as IntegerLiteral

    assert.equal(argument.value, '20')
  }

  g.test('Parsing a message send chain that sets an attribute on a new line') {
    let node = parse_as(input: "10.foo.bar =\n20", type: Send)
    let receiver = node.receiver as Send

    assert.equal(node.message, 'bar=')
    assert.equal(node.arguments.length, 1)
    assert.equal(receiver.message, 'foo')

    let argument = node.arguments[0] as IntegerLiteral

    assert.equal(argument.value, '20')
  }

  g.test('Parsing a message chain with a basic closure outside parentheses') {
    let node = parse_as(input: '10.foo() {}', type: Send)

    assert.equal(node.arguments.length, 1)
    assert_instance_of(node.arguments[0], BasicClosure)
  }

  g.test('Parsing a message chain with a closure outside parentheses') {
    let node = parse_as(input: '10.foo() do {}', type: Send)

    assert.equal(node.arguments.length, 1)
    assert_instance_of(node.arguments[0], Closure)
  }

  g.test('Parsing a message chain using a closure as a receiver') {
    let node = parse_as(input: 'thing.foo { }.bar', type: Send)

    assert.equal(node.message, 'bar')
    assert_instance_of(node.receiver, Send)

    assert.equal((node.receiver as Send).message, 'foo')
    assert.equal((node.receiver as Send).arguments.length, 1)
  }

  g.test('Parsing a message chain with a lambda outside parentheses') {
    let node = parse_as(input: '10.foo() lambda {}', type: Send)

    assert.equal(node.arguments.length, 1)
    assert_instance_of(node.arguments[0], Lambda)
  }

  g.test('Parsing a message chain with parenthesis followed by a closure on a separate line') {
    let nodes = parse("10.foo()\n{}").children

    assert.equal(nodes.length, 2)
    assert.true((nodes[0] as Send).arguments.empty?)
  }

  g.test('Parsing a message chain followed by a comma') {
    assert.panic { parse('10.foo ,') }
  }

  g.test('Running out of input when parsing message names') {
    assert.panic { parse('10.') }
  }

  g.test('Parsing an invalid message name') {
    assert.panic { parse('10.=') }
  }

  g.test('Passing positional arguments after keyword arguments') {
    assert.panic { parse('foo(10, bar: 20, 30)') }
  }
}

test.group('Parsing message send chains without parentheses') do (g) {
  g.test('Sending a message with a bare closure argument') {
    let node = parse_as(input: '10.foo { 20 }', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Sending a message with a closure argument') {
    let node = parse_as(input: '10.foo do { 20 }', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Sending a message with a lambda argument') {
    let node = parse_as(input: '10.foo lambda { 20 }', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Sending a message with a block on a new line') {
    let nodes = parse("10.foo\n{ 20 }").children

    assert.equal(nodes.length, 2)

    let send = nodes[0] as Send

    assert.equal(send.message, 'foo')
    assert.equal(send.arguments.length, 0)
  }

  g.test('Sending a message followed by an integer literal') {
    let node = parse_as(input: '10.foo 20', type: Send)

    assert.true(node.arguments.empty?)
  }

  g.test('Sending a message followed by a binary operator') {
    assert.panic { parse('10.foo -') }
  }
}

test.group('Parsing grouped expressions') do (g) {
  g.test('Parsing a simple group') {
    let node = parse_as(input: '(10)', type: IntegerLiteral)

    assert.equal(node.value, '10')
    assert.equal(node.location.column, 2)
  }

  g.test('Parsing an invalid group') {
    assert.panic { parse('(10') }
  }
}

test.group('Parsing closures') do (g) {
  g.test('Parsing a basic closure') {
    let node = parse_as(input: '{ 10 }', type: BasicClosure)

    assert.equal(node.body.children.length, 1)

    let integer = node.body.children[0] as IntegerLiteral

    assert.equal(integer.value, '10')
    assert.equal(integer.location.column, 3)
  }

  g.test('Parsing a closure') {
    let node = parse_as(input: 'do { 10 }', type: Closure)

    assert.equal(node.body.children.length, 1)
    assert.true(node.arguments.empty?)
    assert.true(node.return_type.none?)
    assert.true(node.throw_type.none?)
  }

  g.test('Parsing a closure without explicitly typed arguments') {
    let node = parse_as(input: 'do (a, b) {}', type: Closure)
    let arg1 = node.arguments[0] as DefineUntypedArgument
    let arg2 = node.arguments[1] as DefineUntypedArgument

    assert_instance_of(arg1, DefineUntypedArgument)
    assert_instance_of(arg2, DefineUntypedArgument)

    assert.equal(arg1.name, 'a')
    assert.equal(arg2.name, 'b')
  }

  g.test('Parsing a closure with statically typed arguments') {
    let node = parse_as(input: 'do (a: A, b: B) {}', type: Closure)
    let arg1 = node.arguments[0] as DefineRequiredArgument
    let arg2 = node.arguments[1] as DefineRequiredArgument

    assert.equal(arg1.name, 'a')
    assert.equal((arg1.value_type as Constant).name, 'A')

    assert.equal(arg2.name, 'b')
    assert.equal((arg2.value_type as Constant).name, 'B')
  }

  g.test('Parsing a closure with a constant as the return type') {
    let node = parse_as(input: 'do -> A {}', type: Closure)

    assert.equal((node.return_type.get as Constant).name, 'A')
  }

  g.test('Parsing a closure with a closure as the return type') {
    let node = parse_as(input: 'do -> do -> A {}', type: Closure)
    let rtype = node.return_type.get as ClosureType

    assert.equal((rtype.return_type.get as Constant).name, 'A')
  }

  g.test('Parsing a closure with an optional type as the return type') {
    let node = parse_as(input: 'do -> ?A {}', type: Closure)
    let type = node.return_type.get as OptionType
    let wrapped = type.type as Constant

    assert.equal(type.location.column, 7)
    assert.equal(wrapped.name, 'A')
    assert.equal(wrapped.location.column, 8)
  }

  g.test('Parsing a closure with a constant as the throw type') {
    let node = parse_as(input: 'do !! A {}', type: Closure)

    assert.equal((node.throw_type.get as Constant).name, 'A')
  }

  g.test('Parsing a closure with a closure as the throw type') {
    let node = parse_as(input: 'do !! do !! A {}', type: Closure)
    let rtype = node.throw_type.get as ClosureType

    assert.equal((rtype.throw_type.get as Constant).name, 'A')
  }

  g.test('Parsing a closure with an optional type as the throw type') {
    let node = parse_as(input: 'do !! ?A {}', type: Closure)
    let type = node.throw_type.get as OptionType
    let wrapped = type.type as Constant

    assert.equal(type.location.column, 7)
    assert.equal(wrapped.name, 'A')
    assert.equal(wrapped.location.column, 8)
  }

  g.test('Parsing a closure with type parameters') {
    let node = parse_as(input: 'do !(A, B) {}', type: Closure)

    assert.equal(node.type_parameters.length, 2)
    assert.equal(node.type_parameters[0].name, 'A')
    assert.equal(node.type_parameters[1].name, 'B')
  }
}

test.group('Parsing lambdas') do (g) {
  g.test('Parsing a lambda') {
    let node = parse_as(input: 'lambda { 10 }', type: Lambda)

    assert.equal(node.body.children.length, 1)
    assert.true(node.arguments.empty?)
    assert.true(node.return_type.none?)
    assert.true(node.throw_type.none?)
  }

  g.test('Parsing a lambda without explicitly typed arguments') {
    let node = parse_as(input: 'lambda (a, b) {}', type: Lambda)
    let arg1 = node.arguments[0] as DefineUntypedArgument
    let arg2 = node.arguments[1] as DefineUntypedArgument

    assert_instance_of(arg1, DefineUntypedArgument)
    assert_instance_of(arg2, DefineUntypedArgument)

    assert.equal(arg1.name, 'a')
    assert.equal(arg2.name, 'b')
  }

  g.test('Parsing a lambda with statically typed arguments') {
    let node = parse_as(input: 'lambda (a: A, b: B) {}', type: Lambda)
    let arg1 = node.arguments[0] as DefineRequiredArgument
    let arg2 = node.arguments[1] as DefineRequiredArgument

    assert.equal(arg1.name, 'a')
    assert.equal((arg1.value_type as Constant).name, 'A')

    assert.equal(arg2.name, 'b')
    assert.equal((arg2.value_type as Constant).name, 'B')
  }

  g.test('Parsing a lambda with a constant as the return type') {
    let node = parse_as(input: 'lambda -> A {}', type: Lambda)

    assert.equal((node.return_type.get as Constant).name, 'A')
  }

  g.test('Parsing a lambda with a lambda as the return type') {
    let node = parse_as(input: 'lambda -> lambda -> A {}', type: Lambda)
    let rtype = node.return_type.get as LambdaType

    assert.equal((rtype.return_type.get as Constant).name, 'A')
  }

  g.test('Parsing a lambda with an optional type as the return type') {
    let node = parse_as(input: 'lambda -> ?A {}', type: Lambda)
    let type = node.return_type.get as OptionType
    let wrapped = type.type as Constant

    assert.equal(type.location.column, 11)
    assert.equal(wrapped.name, 'A')
    assert.equal(wrapped.location.column, 12)
  }

  g.test('Parsing a lambda with a constant as the throw type') {
    let node = parse_as(input: 'lambda !! A {}', type: Lambda)

    assert.equal((node.throw_type.get as Constant).name, 'A')
  }

  g.test('Parsing a lambda with a lambda as the throw type') {
    let node = parse_as(input: 'lambda !! lambda !! A {}', type: Lambda)
    let rtype = node.throw_type.get as LambdaType

    assert.equal((rtype.throw_type.get as Constant).name, 'A')
  }

  g.test('Parsing a lambda with an optional type as the throw type') {
    let node = parse_as(input: 'lambda !! ?A {}', type: Lambda)
    let type = node.throw_type.get as OptionType
    let wrapped = type.type as Constant

    assert.equal(type.location.column, 11)
    assert.equal(wrapped.name, 'A')
    assert.equal(wrapped.location.column, 12)
  }

  g.test('Parsing a lambda with type parameters') {
    let node = parse_as(input: 'lambda !(A, B) {}', type: Lambda)

    assert.equal(node.type_parameters.length, 2)
    assert.equal(node.type_parameters[0].name, 'A')
    assert.equal(node.type_parameters[1].name, 'B')
  }
}

test.group('Parsing attributes') do (g) {
  g.test('Parsing an attribute') {
    let node = parse_as(input: '@foo', type: Attribute)

    assert.equal(node.name, '@foo')
  }

  g.test('Re-assigning an attribute') {
    let node = parse_as(input: '@foo = 10', type: AssignAttribute)

    assert.equal(node.name.name, '@foo')
    assert.equal((node.value as IntegerLiteral).value, '10')
    assert.equal(node.location.column, 1)
  }

  g.test('Assigning an attribute variable using +=') {
    binary_assign_attribute(operator: '+=', message: '+')
  }

  g.test('Assigning an attribute variable using &=') {
    binary_assign_attribute(operator: '&=', message: '&')
  }

  g.test('Assigning an attribute variable using /=') {
    binary_assign_attribute(operator: '/=', message: '/')
  }

  g.test('Assigning an attribute variable using %=') {
    binary_assign_attribute(operator: '%=', message: '%')
  }

  g.test('Assigning an attribute variable using *=') {
    binary_assign_attribute(operator: '*=', message: '*')
  }

  g.test('Assigning an attribute variable using |=') {
    binary_assign_attribute(operator: '|=', message: '|')
  }

  g.test('Assigning an attribute variable using **=') {
    binary_assign_attribute(operator: '**=', message: '**')
  }

  g.test('Assigning an attribute variable using <<=') {
    binary_assign_attribute(operator: '<<=', message: '<<')
  }

  g.test('Assigning an attribute variable using >>=') {
    binary_assign_attribute(operator: '>>=', message: '>>')
  }

  g.test('Assigning an attribute variable using -=') {
    binary_assign_attribute(operator: '-=', message: '-')
  }

  g.test('Assigning an attribute variable using ^=') {
    binary_assign_attribute(operator: '^=', message: '^')
  }
}

test.group('Parsing constants') do (g) {
  g.test('Parsing a constant') {
    let node = parse_as(input: 'Foo', type: Constant)

    assert.equal(node.name, 'Foo')
    assert.true(node.type_arguments.empty?)
  }

  g.test('Parsing a constant with type arguments') {
    let node = parse_as(input: 'A!(B)', type: Constant)

    assert.equal(node.name, 'A')
    assert.equal(node.type_arguments.length, 1)
    assert.equal((node.type_arguments[0] as Constant).name, 'B')
  }
}

test.group('Parsing global variables') do (g) {
  g.test('Parsing a global identifier') {
    let node = parse_as(input: '::foo', type: Global)

    assert.equal(node.name, 'foo')
    assert.equal(node.location.column, 1)
  }

  g.test('Parsing a global constant') {
    let node = parse_as(input: '::Foo', type: Global)

    assert.equal(node.name, 'Foo')
    assert.equal(node.location.column, 1)
  }
}

test.group('Parsing variable definitions') do (g) {
  g.test('Defining an immutable local variable') {
    let node = parse_as(input: 'let number = 10', type: DefineLocalVariable)

    assert.true(node.value_type.none?)
    assert.false(node.mutable?)

    assert.equal(node.name.name, 'number')
    assert.equal((node.value as IntegerLiteral).value, '10')
    assert.equal(node.location.column, 1)
  }

  g.test('Defining an immutable constant variable') {
    let node = parse_as(input: 'let Number = 10', type: DefineConstant)

    assert.true(node.value_type.none?)

    assert.equal(node.name.name, 'Number')
    assert.equal((node.value as IntegerLiteral).value, '10')
    assert.equal(node.location.column, 1)
  }

  g.test('Defining a mutable local variable') {
    let node = parse_as(input: 'let mut number = 10', type: DefineLocalVariable)

    assert.true(node.value_type.none?)
    assert.true(node.mutable?)

    assert.equal(node.name.name, 'number')
    assert.equal((node.value as IntegerLiteral).value, '10')
  }

  g.test('Defining a mutable constant') {
    assert.panic { parse('let mut Number = 10') }
  }

  g.test('Parsing a constant definition inside another expression') {
    assert.panic { parse('{ let A = 10 }') }
  }

  g.test('Defining a local variable with an explicit value type') {
    let node = parse_as(input: 'let number: A = 10', type: DefineLocalVariable)

    assert_instance_of(node.value_type.get, Constant)
    assert.equal((node.value_type.get as Constant).name, 'A')
  }

  g.test('Defining a constant with an explicit value type') {
    let node = parse_as(input: 'let Number: A = 10', type: DefineConstant)

    assert_instance_of(node.value_type.get, Constant)
    assert.equal((node.value_type.get as Constant).name, 'A')
  }

  g.test('Defining a local variable without a value') {
    assert.panic { parse('let number =') }
  }
}

test.group('Parsing method definitions') do (g) {
  g.test('Parsing a simple method') {
    let node = parse_as(input: 'def foo { 10 }', type: DefineMethod)

    assert.equal(node.name, 'foo')
    assert.equal(node.body.children.length, 1)
    assert.false(node.static_method?)

    assert.true(node.arguments.empty?)
    assert.true(node.type_parameters.empty?)

    assert.true(node.return_type.none?)
    assert.true(node.throw_type.none?)
  }

  g.test('Parsing a method with statically typed arguments') {
    let node = parse_as(input: 'def foo(a: A, b: B) {}', type: DefineMethod)

    assert.equal(node.arguments.length, 2)

    let arg1 = node.arguments[0] as DefineRequiredArgument
    let arg2 = node.arguments[1] as DefineRequiredArgument

    assert.equal(arg1.name, 'a')
    assert.equal((arg1.value_type as Constant).name, 'A')

    assert.equal(arg2.name, 'b')
    assert.equal((arg2.value_type as Constant).name, 'B')
  }

  g.test('Parsing a method with a throw type') {
    let node = parse_as(input: 'def foo !! A {}', type: DefineMethod)

    assert.equal((node.throw_type.get as Constant).name, 'A')
  }

  g.test('Parsing a method with a return type') {
    let node = parse_as(input: 'def foo -> A {}', type: DefineMethod)

    assert.equal((node.return_type.get as Constant).name, 'A')
  }

  g.test('Parsing a method with a yield type') {
    let node = parse_as(input: 'def foo => A {}', type: DefineMethod)

    assert.equal((node.yield_type.get as Constant).name, 'A')
  }

  g.test('Parsing a method with a throw and return type') {
    let node = parse_as(input: 'def foo !! A -> B {}', type: DefineMethod)

    assert.equal((node.throw_type.get as Constant).name, 'A')
    assert.equal((node.return_type.get as Constant).name, 'B')
  }

  g.test('Parsing a method with type parameters') {
    let node = parse_as(input: 'def foo!(A, B) {}', type: DefineMethod)

    assert.equal(node.type_parameters.length, 2)
    assert.equal(node.type_parameters[0].name, 'A')
    assert.equal(node.type_parameters[1].name, 'B')
  }

  g.test('Parsing a static method when defining an object') {
    let node =
      parse_as(input: 'object A { static def foo {} }', type: DefineObject)

    let method = node.body.children[0] as DefineMethod

    assert.equal(method.name, 'foo')
    assert.true(method.static_method?)
  }

  g.test('Parsing a static method when reopening an object') {
    let node =
      parse_as(input: 'impl A { static def foo {} }', type: ReopenObject)

    let method = node.body.children[0] as DefineMethod

    assert.equal(method.name, 'foo')
    assert.true(method.static_method?)
  }

  g.test('Parsing a method with a rest argument') {
    let node = parse_as(input: 'def foo(*a: A) {}', type: DefineMethod)
    let arg = node.arguments[0] as DefineRestArgument

    assert_instance_of(arg, DefineRestArgument)

    assert.equal(arg.name, 'a')
    assert.equal((arg.value_type as Constant).name, 'A')
  }

  g.test('Parsing a method with an untyped rest argument') {
    assert.panic { parse('def foo(*a) {}') }
  }

  g.test('Parsing a method without argument types or default values') {
    assert.panic { parse('def foo(a) {}') }
  }

  g.test('Parsing a static module method') {
    assert.panic { parse('static def foo {}') }
  }

  g.test('Parsing a method with a rest argument with a default value') {
    assert.panic { parse('def foo(*a = 10) {}') }
  }
}

test.group('Reading and writing the index of of a value') do (g) {
  g.test('Accessing an index of a constant') {
    let node = parse_as(input: 'A[10]', type: Send)

    assert.equal(node.message, '[]')
    assert.equal(node.arguments.length, 1)

    assert.equal((node.receiver as Constant).name, 'A')
    assert.equal((node.arguments[0] as IntegerLiteral).value, '10')
  }

  g.test('Accessing an index of a message chain') {
    let node = parse_as(input: '10.bar[10]', type: Send)

    assert.equal(node.message, '[]')
    assert.equal(node.arguments.length, 1)

    assert.equal((node.receiver as Send).message, 'bar')
    assert.equal((node.arguments[0] as IntegerLiteral).value, '10')
  }

  g.test('Setting the value of an index of a constant') {
    let node = parse_as(input: 'A[10] = 20', type: Send)

    assert.equal(node.message, '[]=')
    assert.equal(node.arguments.length, 2)

    assert.equal((node.receiver as Constant).name, 'A')
    assert.equal((node.arguments[0] as IntegerLiteral).value, '10')
    assert.equal((node.arguments[1] as IntegerLiteral).value, '20')
  }

  g.test('Setting the value of an index of a message chain') {
    let node = parse_as(input: '10.bar[10] = 20', type: Send)

    assert.equal(node.message, '[]=')
    assert.equal(node.arguments.length, 2)

    assert.equal((node.receiver as Send).message, 'bar')
    assert.equal((node.arguments[0] as IntegerLiteral).value, '10')
    assert.equal((node.arguments[1] as IntegerLiteral).value, '20')
  }

  g.test('Setting the value of an index to the result of a message chain') {
    let node = parse_as(input: '10.bar[10] = 20.foo', type: Send)

    assert.equal(node.message, '[]=')

    assert_instance_of(node.arguments[1], Send)

    assert.equal((node.arguments[1] as Send).message, 'foo')
  }
}

test.group('Parsing return expressions') do (g) {
  g.test('Parsing a return without a value') {
    let node = parse_as(input: 'return', type: Return)

    assert.true(node.expression.none?)
  }

  g.test('Parsing a return with a value') {
    let node = parse_as(input: 'return 10', type: Return)

    assert_instance_of(node.expression.get, IntegerLiteral)
    assert.equal((node.expression.get as IntegerLiteral).value, '10')
  }

  g.test('Parsing a return followed by a value on a separate line') {
    let nodes = parse("return\n10").children

    assert.equal(nodes.length, 2)
    assert.true((nodes[0] as Return).expression.none?)
  }

  g.test('Parsing a return followed by a closing curly brace') {
    let node = parse_as(input: '{ return }', type: BasicClosure)

    assert.equal(node.body.children.length, 1)
    assert_instance_of(node.body.children[0], Return)
  }

  g.test('Parsing a return followed by a closing parenthesis') {
    let node = parse_as(input: '(return)', type: Return)

    assert.true(node.expression.none?)
  }

  g.test('Parsing a return followed by a comment') {
    let nodes = parse('return # foo').children

    assert.equal(nodes.length, 1)
    assert.true((nodes[0] as Return).expression.none?)
  }

  g.test('Parsing a return followed by a documentation comment') {
    let nodes = parse('return # foo').children

    assert.equal(nodes.length, 1)
    assert.true((nodes[0] as Return).expression.none?)
  }

  g.test('Parsing a return expression inside an index access expression') {
    let node = parse_as(input: '10[return]', type: Send)

    assert.equal(node.message, '[]')
    assert_instance_of(node.arguments[0], Return)
    assert.true((node.arguments[0] as Return).expression.none?)
  }

  g.test('Parsing a return expression that returns self') {
    let node = parse_as(input: 'return self', type: Return)

    assert_instance_of(node.expression.get, SelfObject)
  }

  g.test('Parsing a return expression that returns a pattern match') {
    let node = parse_as(input: 'return match(x) {}', type: Return)

    assert_instance_of(node.expression.get, Match)
  }

  g.test('Parsing a return expression that returns an identifier') {
    let node = parse_as(input: 'return foo', type: Return)

    assert_instance_of(node.expression.get, Identifier)
  }

  g.test('Parsing a return expression that returns a try expression') {
    let node = parse_as(input: 'return try foo', type: Return)

    assert_instance_of(node.expression.get, Try)
  }

  g.test('Parsing a return expression that returns a throw expression') {
    let node = parse_as(input: 'return throw foo', type: Return)

    assert_instance_of(node.expression.get, Throw)
  }

  g.test('Parsing a return followed by a dot') {
    assert.panic { parse('return .') }
  }

  g.test('Parsing a return followed by a binary operator') {
    assert.panic { parse('return +') }
  }
}

test.group('Parsing local return expressions') do (g) {
  g.test('Parsing a local return without a value') {
    let node = parse_as(input: 'local return', type: Return)

    assert.true(node.expression.none?)
    assert.true(node.local_return?)
    assert.equal(node.location.column, 1)
  }

  g.test('Parsing a local return with a value') {
    let node = parse_as(input: 'local return 10', type: Return)

    assert_instance_of(node.expression.get, IntegerLiteral)
    assert.equal((node.expression.get as IntegerLiteral).value, '10')
    assert.true(node.local_return?)
  }

  g.test('Parsing a local return followed by a value on a separate line') {
    let nodes = parse("local return\n10").children
    let ret = nodes[0] as Return

    assert.equal(nodes.length, 2)
    assert.true(ret.expression.none?)
    assert.true(ret.local_return?)
  }

  g.test('Parsing a local return followed by a closing curly brace') {
    let node = parse_as(input: '{ local return }', type: BasicClosure)
    let ret = node.body.children[0] as Return

    assert.equal(node.body.children.length, 1)
    assert.true(ret.local_return?)
    assert_instance_of(ret, Return)
  }

  g.test('Parsing a local return followed by a closing parenthesis') {
    let node = parse_as(input: '(local return)', type: Return)

    assert.true(node.expression.none?)
    assert.true(node.local_return?)
  }

  g.test('Parsing a local return followed by a comment') {
    let nodes = parse('local return # foo').children
    let ret = nodes[0] as Return

    assert.equal(nodes.length, 1)
    assert.true(ret.expression.none?)
    assert.true(ret.local_return?)
  }

  g.test('Parsing a local return followed by a documentation comment') {
    let nodes = parse('local return # foo').children
    let ret = nodes[0] as Return

    assert.equal(nodes.length, 1)
    assert.true(ret.expression.none?)
    assert.true(ret.local_return?)
  }

  g.test('Parsing a local return expression inside an index access expression') {
    let node = parse_as(input: '10[local return]', type: Send)
    let ret = node.arguments[0] as Return

    assert.equal(node.message, '[]')
    assert_instance_of(node.arguments[0], Return)
    assert.true(ret.expression.none?)
    assert.true(ret.local_return?)
  }

  g.test('Parsing a local return expression that returns self') {
    let node = parse_as(input: 'local return self', type: Return)

    assert_instance_of(node.expression.get, SelfObject)
    assert.true(node.local_return?)
  }

  g.test('Parsing a return expression that returns a pattern match') {
    let node = parse_as(input: 'local return match(x) {}', type: Return)

    assert_instance_of(node.expression.get, Match)
    assert.true(node.local_return?)
  }

  g.test('Parsing a return expression that returns an identifier') {
    let node = parse_as(input: 'local return foo', type: Return)

    assert_instance_of(node.expression.get, Identifier)
    assert.true(node.local_return?)
  }

  g.test('Parsing a return expression that returns a try expression') {
    let node = parse_as(input: 'local return try foo', type: Return)

    assert_instance_of(node.expression.get, Try)
    assert.true(node.local_return?)
  }

  g.test('Parsing a return expression that returns a throw expression') {
    let node = parse_as(input: 'local return throw foo', type: Return)

    assert_instance_of(node.expression.get, Throw)
    assert.true(node.local_return?)
  }

  g.test('Parsing a return followed by a dot') {
    assert.panic { parse('local return .') }
  }

  g.test('Parsing a return followed by a binary operator') {
    assert.panic { parse('local return +') }
  }
}

test.group('Parsing the self expression') do (g) {
  g.test('Parsing "self"') {
    let node = parse_as(input: 'self', type: SelfObject)

    assert.equal(node.location.column, 1)
  }
}

test.group('Parsing throw expressions') do (g) {
  g.test('Parsing a throw expression') {
    let node = parse_as(input: 'throw 10', type: Throw)

    assert.equal((node.expression as IntegerLiteral).value, '10')
    assert.false(node.local_throw?)
  }

  g.test('Parsing a local throw expression') {
    let node = parse_as(input: 'local throw 10', type: Throw)

    assert.equal((node.expression as IntegerLiteral).value, '10')
    assert.true(node.local_throw?)
    assert.equal(node.location.column, 1)
  }
}

test.group('Parsing try expressions') do (g) {
  g.test('Parsing a try without an else expression') {
    let node = parse_as(input: 'try 10', type: Try)

    assert.equal((node.expression as IntegerLiteral).value, '10')

    assert.true(node.error_variable.none?)
    assert.true(node.else_body.children.empty?)
  }

  g.test('Parsing a try with an identifier') {
    let node = parse_as(input: 'try foo', type: Try)

    assert.true((node.expression as Identifier).inside_try?)
  }

  g.test('Parsing a try with a global') {
    let node = parse_as(input: 'try ::foo', type: Try)

    assert.true((node.expression as Global).inside_try?)
  }

  g.test('Parsing a try with a message') {
    let node = parse_as(input: 'try foo()', type: Try)

    assert.true((node.expression as Send).inside_try?)
  }

  g.test('Parsing a try with an else expression') {
    let node = parse_as(input: 'try 10 else 20', type: Try)
    let else_expr = node.else_body

    assert.equal((node.expression as IntegerLiteral).value, '10')
    assert.equal((else_expr.children[0] as IntegerLiteral).value, '20')
  }

  g.test('Parsing a try with a multi-line else expression') {
    let node = parse_as(input: "try 10 else { 10\n20 }", type: Try)
    let else_expr = node.else_body

    assert.equal((node.expression as IntegerLiteral).value, '10')

    assert.equal((else_expr.children[0] as IntegerLiteral).value, '10')
    assert.equal((else_expr.children[1] as IntegerLiteral).value, '20')
  }

  g.test('Parsing a try with an error argument') {
    let node = parse_as(input: 'try 10 else (error) 20', type: Try)
    let else_expr = node.else_body

    assert.equal((node.expression as IntegerLiteral).value, '10')
    assert.equal(node.error_variable.get, 'error')
    assert.equal((else_expr.children[0] as IntegerLiteral).value, '20')
  }

  g.test('Parsing a try with multiple error arguments') {
    assert.panic { parse('try 10 else (a, b) 20') }
  }
}

test.group('Parsing local try expressions') do (g) {
  g.test('Parsing a local try without an else expression') {
    let node = parse_as(input: 'local try 10', type: Try)

    assert.equal((node.expression as IntegerLiteral).value, '10')

    assert.true(node.error_variable.none?)
    assert.true(node.else_body.children.empty?)
    assert.true(node.local_throw?)
    assert.equal(node.location.column, 1)
  }

  g.test('Parsing a local try with an identifier') {
    let node = parse_as(input: 'local try foo', type: Try)

    assert.true((node.expression as Identifier).inside_try?)
  }

  g.test('Parsing a local try with a global') {
    let node = parse_as(input: 'local try ::foo', type: Try)

    assert.true((node.expression as Global).inside_try?)
  }

  g.test('Parsing a local try with a message') {
    let node = parse_as(input: 'local try foo()', type: Try)

    assert.true((node.expression as Send).inside_try?)
  }

  g.test('Parsing a local try with an else expression') {
    let node = parse_as(input: 'local try 10 else 20', type: Try)
    let else_expr = node.else_body

    assert.equal((node.expression as IntegerLiteral).value, '10')
    assert.equal((else_expr.children[0] as IntegerLiteral).value, '20')
    assert.true(node.local_throw?)
  }

  g.test('Parsing a local try with a multi-line else expression') {
    let node = parse_as(input: "local try 10 else { 10\n20 }", type: Try)
    let else_expr = node.else_body

    assert.equal((node.expression as IntegerLiteral).value, '10')
    assert.equal((else_expr.children[0] as IntegerLiteral).value, '10')
    assert.equal((else_expr.children[1] as IntegerLiteral).value, '20')
    assert.true(node.local_throw?)
  }

  g.test('Parsing a local try with an error argument') {
    let node = parse_as(input: 'local try 10 else (error) 20', type: Try)
    let else_expr = node.else_body

    assert.equal((node.expression as IntegerLiteral).value, '10')
    assert.equal(node.error_variable.get, 'error')
    assert.equal((else_expr.children[0] as IntegerLiteral).value, '20')
    assert.true(node.local_throw?)
  }

  g.test('Parsing a local try with multiple error arguments') {
    assert.panic { parse('local try 10 else (a, b) 20') }
  }
}

test.group('Parsing try! expressions') do (g) {
  g.test('Parsing a try!') {
    let node = parse_as(input: 'try! 10', type: TryPanic)

    assert.equal((node.expression as IntegerLiteral).value, '10')
  }

  g.test('Parsing a try! with an identifier') {
    let node = parse_as(input: 'try! foo', type: TryPanic)

    assert.true((node.expression as Identifier).inside_try?)
  }

  g.test('Parsing a try! with a global') {
    let node = parse_as(input: 'try! ::foo', type: TryPanic)

    assert.true((node.expression as Global).inside_try?)
  }

  g.test('Parsing a try! with a message') {
    let node = parse_as(input: 'try! foo()', type: TryPanic)

    assert.true((node.expression as Send).inside_try?)
  }
}

test.group('Parsing identifiers') do (g) {
  g.test('Parsing an identifier') {
    let node = parse_as(input: 'foo', type: Identifier)

    assert.equal(node.name, 'foo')
  }

  g.test('Parsing an identifier with a basic closure argument') {
    let node = parse_as(input: 'foo {}', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Parsing an identifier with a closure argument') {
    let node = parse_as(input: 'foo do {}', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Parsing an identifier with a lambda argument') {
    let node = parse_as(input: 'foo lambda {}', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
  }

  g.test('Parsing an identifier with a closure as a receiver') {
    let node = parse_as(input: 'foo { }.bar', type: Send)

    assert.equal(node.message, 'bar')
    assert_instance_of(node.receiver, Send)

    assert.equal((node.receiver as Send).message, 'foo')
    assert.equal((node.receiver as Send).arguments.length, 1)
  }

  g.test('Parsing an identifier followed by parentheses') {
    let node = parse_as(input: 'foo(10, 20)', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 2)

    assert.equal((node.arguments[0] as IntegerLiteral).value, '10')
    assert.equal((node.arguments[1] as IntegerLiteral).value, '20')
  }

  g.test('Parsing an identifier with type arguments') {
    let node = parse_as(input: 'foo!(A, B)', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.type_arguments.length, 2)

    assert.equal((node.type_arguments[0] as Constant).name, 'A')
    assert.equal((node.type_arguments[1] as Constant).name, 'B')
  }

  g.test('Parsing an identifier with type arguments and regular arguments') {
    let node = parse_as(input: 'foo!(A, B)(10, 20)', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.type_arguments.length, 2)
    assert.equal(node.arguments.length, 2)

    assert.equal((node.type_arguments[0] as Constant).name, 'A')
    assert.equal((node.type_arguments[1] as Constant).name, 'B')

    assert.equal((node.arguments[0] as IntegerLiteral).value, '10')
    assert.equal((node.arguments[1] as IntegerLiteral).value, '20')
  }

  g.test('Parsing an identifier with a basic closure argument outside parentheses') {
    let node = parse_as(input: 'foo() {}', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
    assert_instance_of(node.arguments[0], BasicClosure)
  }

  g.test('Parsing an identifier with a closure argument outside parentheses') {
    let node = parse_as(input: 'foo() do {}', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
    assert_instance_of(node.arguments[0], Closure)
  }

  g.test('Parsing an identifier with a lambda argument outside parentheses') {
    let node = parse_as(input: 'foo() lambda {}', type: Send)

    assert.equal(node.message, 'foo')
    assert.equal(node.arguments.length, 1)
    assert_instance_of(node.arguments[0], Lambda)
  }

  g.test('Parsing an identifier with parenthesis followed by a closure on a separate line') {
    let nodes = parse("foo()\n{}").children

    assert.equal(nodes.length, 2)
    assert.true((nodes[0] as Send).arguments.empty?)
  }

  g.test('Assigning a local variable to a new value') {
    let node = parse_as(input: 'foo = 10', type: AssignLocal)

    assert.equal(node.name.name, 'foo')
    assert_instance_of(node.value, IntegerLiteral)
    assert.equal((node.value as IntegerLiteral).value, '10')
  }

  g.test('Assigning a local variable using +=') {
    binary_assign_local(operator: '+=', message: '+')
  }

  g.test('Assigning a local variable using &=') {
    binary_assign_local(operator: '&=', message: '&')
  }

  g.test('Assigning a local variable using /=') {
    binary_assign_local(operator: '/=', message: '/')
  }

  g.test('Assigning a local variable using %=') {
    binary_assign_local(operator: '%=', message: '%')
  }

  g.test('Assigning a local variable using *=') {
    binary_assign_local(operator: '*=', message: '*')
  }

  g.test('Assigning a local variable using |=') {
    binary_assign_local(operator: '|=', message: '|')
  }

  g.test('Assigning a local variable using **=') {
    binary_assign_local(operator: '**=', message: '**')
  }

  g.test('Assigning a local variable using <<=') {
    binary_assign_local(operator: '<<=', message: '<<')
  }

  g.test('Assigning a local variable using >>=') {
    binary_assign_local(operator: '>>=', message: '>>')
  }

  g.test('Assigning a local variable using -=') {
    binary_assign_local(operator: '-=', message: '-')
  }

  g.test('Assigning a local variable using ^=') {
    binary_assign_local(operator: '^=', message: '^')
  }
}

test.group('Parsing pattern matching expressions') do (g) {
  g.test('Parsing an empty pattern matching expressions') {
    let node = parse_as(input: 'match(10) {}', type: Match)

    assert.true(node.cases.empty?)
    assert.true(node.else_branch.none?)
  }

  g.test('Parsing a pattern match expression without an argument') {
    let node = parse_as(input: 'match {}', type: Match)

    assert.true(node.expression.none?)
    assert.true(node.cases.empty?)
    assert.true(node.else_branch.none?)
  }

  g.test('Parsing a pattern match expression with a single type case') {
    let node = parse_as(input: 'match(10) { as A -> { 10 } }', type: Match)

    assert.equal(node.cases.length, 1)
    assert_instance_of(node.cases[0], MatchType)

    let case = node.cases[0] as MatchType

    assert.equal((case.pattern as Constant).name, 'A')
    assert.true(case.guard.none?)
    assert.equal(case.body.children.length, 1)
  }

  g.test('Parsing a pattern match expression with a type guard') {
    let node =
      parse_as(input: 'match(10) { as A when B -> { 10 } }', type: Match)

    assert.equal(node.cases.length, 1)
    assert_instance_of(node.cases[0], MatchType)

    let case = node.cases[0] as MatchType

    assert.equal((case.pattern as Constant).name, 'A')
    assert.equal(case.body.children.length, 1)
    assert_instance_of(case.guard.get, Constant)
  }

  g.test('Parsing a pattern match expression with two type cases') {
    let node = parse_as(
      input: 'match(10) { as A -> { 10 } as B -> { 20 } }',
      type: Match
    )

    assert.equal(node.cases.length, 2)

    assert_instance_of(node.cases[0], MatchType)
    assert_instance_of(node.cases[1], MatchType)

    let case1 = node.cases[0] as MatchType
    let case2 = node.cases[1] as MatchType

    assert.equal((case1.pattern as Constant).name, 'A')
    assert.true(case1.guard.none?)
    assert.equal(case1.body.children.length, 1)

    assert.equal((case2.pattern as Constant).name, 'B')
    assert.true(case2.guard.none?)
    assert.equal(case2.body.children.length, 1)
  }

  g.test('Parsing a pattern match expression with an expression case') {
    let node = parse_as(input: 'match(10) { 10 -> { 10 } }', type: Match)

    assert.equal(node.cases.length, 1)
    assert_instance_of(node.cases[0], MatchExpressions)

    let case = node.cases[0] as MatchExpressions

    assert.equal(case.patterns.length, 1)
    assert.equal(case.body.children.length, 1)
  }

  g.test('Parsing a pattern match expression with an expression case and a guard') {
    let node = parse_as(input: 'match(10) { 10 when A -> { 10 } }', type: Match)

    assert.equal(node.cases.length, 1)
    assert_instance_of(node.cases[0], MatchExpressions)

    let case = node.cases[0] as MatchExpressions

    assert.equal(case.patterns.length, 1)
    assert.equal(case.body.children.length, 1)
    assert_instance_of(case.guard.get, Constant)
  }

  g.test('Parsing a pattern match expression with a multi-expression case') {
    let node = parse_as(input: 'match(10) { 10, 20 -> { 10 } }', type: Match)

    assert.equal(node.cases.length, 1)
    assert_instance_of(node.cases[0], MatchExpressions)

    let case = node.cases[0] as MatchExpressions

    assert.equal(case.patterns.length, 2)
    assert.equal(case.body.children.length, 1)
  }

  g.test('Parsing a pattern match expression with an "else" branch') {
    let node = parse_as(input: 'match(10) { else -> { 10 } }', type: Match)

    assert.true(node.cases.empty?)
    assert.false(node.else_branch.none?)
    assert.equal(node.else_branch.get.body.children.length, 1)
  }

  g.test('Parsing a pattern match expression with a variable binding') {
    let node = parse_as(input: 'match(let number = 10) {}', type: Match)

    assert.equal(node.binding.get.name, 'number')
  }

  g.test('Parsing a pattern match expression with all possible cases and a binding') {
    let input = "
      match(let number = 10) {
        as Integer when A -> { 10 }
        10 -> { 20 }
        else -> { 30 }
      }
    "

    let node = parse_as(input: input, type: Match)

    assert.equal(node.binding.get.name, 'number')
    assert.equal((node.expression.get as IntegerLiteral).value, '10')
    assert.equal(node.cases.length, 2)
    assert.false(node.else_branch.none?)
  }

  g.test('Parsing a pattern match expression with multiple "else" branches') {
    assert.panic { parse('match(10) { else -> {} else -> {} }') }
  }

  g.test('Parsing a pattern match expression without parentheses') {
    assert.panic { parse('match 10 {}') }
  }

  g.test('Parsing a type pattern matching case without an arrow') {
    assert.panic { parse('match(10) { as Integer {} }') }
  }

  g.test('Parsing an expression pattern matching case without an arrow') {
    assert.panic { parse('match(10) { 10 {} }') }
  }

  g.test('Parsing a match expression with an empty argument list') {
    assert.panic { parse('match() {}') }
  }

  g.test('Parsing a match expression that binds a variable without a value') {
    assert.panic { parse('match(let a = ) {}') }
  }

  g.test('Parsing a match expression with a generic type pattern') {
    assert.panic { parse('match(x) { as Array!(Integer) -> {} }') }
  }
}

test.group('Parsing object constructors') do (g) {
  g.test('Parsing an empty object constructor') {
    let node = parse_as(input: 'A {}', type: Constructor)

    assert.equal(node.name, 'A')
    assert.true(node.attributes.empty?)
  }

  g.test('Parsing an object constructor with one attribute') {
    let node = parse_as(input: 'A { @a = 10 }', type: Constructor)

    assert.equal(node.name, 'A')
    assert.equal(node.attributes.length, 1)

    let attr = node.attributes[0]

    assert.equal(attr.name, '@a')
    assert.equal(attr.location.column, 5)
    assert_instance_of(attr.value, IntegerLiteral)
  }

  g.test('Parsing an object constructor with multiple attributes') {
    let node = parse_as(input: 'A { @a = 10, @b = 20 }', type: Constructor)

    assert.equal(node.name, 'A')
    assert.equal(node.attributes.length, 2)

    let attr1 = node.attributes[0]
    let attr2 = node.attributes[1]

    assert.equal(attr1.name, '@a')
    assert.equal(attr1.location.column, 5)
    assert_instance_of(attr1.value, IntegerLiteral)

    assert.equal(attr2.name, '@b')
    assert.equal(attr2.location.column, 14)
    assert_instance_of(attr2.value, IntegerLiteral)
  }

  g.test('Parsing a Self constructor') {
    let node = parse_as(input: 'Self {}', type: Constructor)

    assert.equal(node.name, 'Self')
    assert.true(node.attributes.empty?)
  }

  g.test('Parsing an object constructor with an invalid attribute') {
    assert.panic { parse('A { a = 10 }') }
  }

  g.test('Parsing an object constructor with an attribute without a value') {
    assert.panic { parse('A { @a = }') }
  }

  g.test('Parsing an object constructor without a closing curly brace') {
    assert.panic { parse('A { @a = 10') }
  }
}

test.group('Parsing yield expressions') do (g) {
  g.test('Parsing a yield expression') {
    let node = parse_as(input: 'yield 10', type: Yield)

    assert.equal((node.expression as IntegerLiteral).value, '10')
  }

  g.test('Parsing a yield expression without a value') {
    assert.panic { parse('yield') }
  }
}
