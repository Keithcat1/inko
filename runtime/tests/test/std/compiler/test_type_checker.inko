import std::compiler::ast::blocks::*
import std::compiler::ast::body::Body
import std::compiler::ast::control_flow::*
import std::compiler::ast::literals::*
import std::compiler::ast::node::*
import std::compiler::ast::objects::*
import std::compiler::ast::operators::*
import std::compiler::ast::pattern_matching::*
import std::compiler::ast::send::*
import std::compiler::ast::types::(
  ClosureType as ClosureTypeNode, LambdaType as LambdaTypeNode
)
import std::compiler::ast::variables::*
import std::compiler::diagnostics::Diagnostics
import std::compiler::module_name::ModuleName
import std::compiler::module_parser::ParsedModule
import std::compiler::parser::Parser
import std::compiler::source_location::SourceLocation
import std::compiler::symbol_table::SymbolTable
import std::compiler::type_checker::*
import std::compiler::types::*
import std::mirror
import std::process
import std::test
import std::test::assert

def location -> SourceLocation {
  SourceLocation.new(file: 'test.inko', line_range: 1..1, column: 1)
}

def parse(input: String) -> Body {
  try! Parser.new(input: input, file: 'test.inko').parse
}

def parse_type(type: String) -> Node {
  let node = parse(`let x: {type} = 10`).children[0] as DefineLocalVariable

  node.value_type.get
}

def new_module(name: String) -> ModuleType {
  ModuleType.new(ModuleName.new(Array.new(name)))
}

def new_std_module(name: String) -> ModuleType {
  ModuleType.new(ModuleName.new(Array.new('std', name)))
}

def assert_instance_of(type: Type, instance_of: Type) {
  assert.true(mirror.reflect(type).instance_of?(instance_of))
}

def assert_object_instance(type: Type, instance_of: ClassType) {
  match(let matched = type) {
    as ClassInstance when matched.instance_of.same_object?(instance_of) -> {}
    else -> {
      process.panic(
        `Expected {matched.type_name} to be an instance of {instance_of.type_name}`
      )
    }
  }
}

def assert_trait_instance(type: Type, instance_of: TraitType) {
  assert_instance_of(type, TraitInstance)
  assert.equal((type as TraitInstance).instance_of, instance_of)
}

def setup_match_types(type_checker: TypeChecker, module: ModuleType) {
  let builtins = type_checker.builtins
  let op_mod = ModuleType.new(OPERATORS_MODULE)

  type_checker.add_module(op_mod)

  op_mod.define_constant(name: 'Boolean', type: builtins.boolean_type)
  module.define_constant(name: 'Boolean', type: builtins.boolean_type)
  module.define_constant(name: 'Integer', type: builtins.integer_type)
  module.define_constant(name: 'True', type: builtins.true_singleton)
  module.define_constant(name: 'Nil', type: builtins.nil_singleton)

  type_checker.check_module(
    module: op_mod,
    ast: parse('trait Match!(T) { def =~(other: T) -> Boolean }')
  )

  type_checker.check_module(
    module: module,
    ast: parse(
      '
      import std::operators::Match

      impl Match!(Integer) for Integer {
        def =~(other: Integer) -> Boolean { True }
      }
      '
    )
  )
}

class DummyPass {
  @type_checker: TypeChecker
  @module: ModuleType

  static def new -> Self {
    Self { @type_checker = TypeChecker.new, @module = new_module('foo') }
  }
}

impl TypePass for DummyPass {
  def type_checker -> TypeChecker {
    @type_checker
  }

  def module -> ModuleType {
    @module
  }
}

test.group('std::compiler::type_checker::TypePass.visit_constant') do (g) {
  g.test('Resolving a constant that does not exist') {
    let pass = DummyPass.new
    let node = parse_type('Foo') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant(node: node, types: scope)

    assert.true(type.error?)
    assert.true(node.resolved_type.get.error?)
    assert.true(pass.type_checker.diagnostics.errors?)
  }

  g.test('Resolving a constant that exists') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('Foo') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant(node: node, types: scope)

    assert.same_object(type, foo_type)
    assert.same_object(node.resolved_type.get, type)
    assert.false(pass.type_checker.diagnostics.errors?)
  }

  g.test('Resolving a non-existing constant with type arguments') {
    let pass = DummyPass.new
    let node = parse_type('Foo!(Bar)') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant(node: node, types: scope)

    assert.true(type.error?)
    assert.true(node.resolved_type.get.error?)
    assert.true(pass.type_checker.diagnostics.errors?)
  }

  g.test('Resolving an existing regular constant with type arguments') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')
    let bar_type = ClassType.new('Bar')

    pass.module.define_constant(name: foo_type.name, type: foo_type)
    pass.module.define_constant(name: bar_type.name, type: bar_type)

    let node = parse_type('Foo!(Bar)') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant(node: node, types: scope)

    assert.true(type.error?)
    assert.true(node.resolved_type.get.error?)
    assert.true(pass.type_checker.diagnostics.errors?)
  }

  g.test('Resolving an existing generic constant with type arguments') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')
    let bar_type = ClassType.new('Bar')
    let param = TypeParameterType.new('A')

    foo_type.type_parameters.define(name: 'A', type: param)
    pass.module.define_constant(name: foo_type.name, type: foo_type)
    pass.module.define_constant(name: bar_type.name, type: bar_type)

    let node = parse_type('Foo!(Bar)') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant(node: node, types: scope)

    assert_instance_of(type, ClassInstance)
    assert.same_object(node.resolved_type.get, type)
    assert.false(pass.type_checker.diagnostics.errors?)

    let obj_type = type as ClassInstance

    assert.same_object(obj_type.instance_of, foo_type)
    assert.equal(obj_type.type_parameter_types.length, 1)
    assert_object_instance(obj_type.type_parameter_types[param], bar_type)
  }

  g.test('Resolving an existing generic constant with an incorrect number of type arguments') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')
    let bar_type = ClassType.new('Bar')

    foo_type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
    foo_type.type_parameters.define(name: 'B', type: TypeParameterType.new('B'))

    pass.module.define_constant(name: foo_type.name, type: foo_type)
    pass.module.define_constant(name: bar_type.name, type: bar_type)

    let node = parse_type('Foo!(Bar)') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant(node: node, types: scope)

    assert.true(type.error?)
    assert.true(node.resolved_type.get.error?)
    assert.true(pass.type_checker.diagnostics.errors?)
  }
}

test.group('std::compiler::type_checker::TypePass.visit_constant_as_type') do (g) {
  g.test('Resolving the Never type') {
    let pass = DummyPass.new
    let node = parse_type('Never') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant_as_type(node: node, types: scope)

    assert_instance_of(type, NeverType)
    assert.same_object(node.resolved_type.get, type)
    assert.false(pass.type_checker.diagnostics.errors?)
  }

  g.test('Resolving the Self type') {
    let pass = DummyPass.new
    let node = parse_type('Self') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant_as_type(node: node, types: scope)

    assert_instance_of(type, SelfType)
    assert.same_object(node.resolved_type.get, type)
    assert.false(pass.type_checker.diagnostics.errors?)
  }

  g.test('Resolving the Never type with type arguments') {
    let pass = DummyPass.new
    let node = parse_type('Never!(Bar)') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant_as_type(node: node, types: scope)

    assert.true(type.error?)
    assert.true(node.resolved_type.get.error?)
    assert.true(pass.type_checker.diagnostics.errors?)
  }

  g.test('Resolving an existing generic constant without type arguments') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')

    foo_type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('Foo') as Constant
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_constant_as_type(node: node, types: scope)

    assert.true(type.error?)
    assert.true(node.resolved_type.get.error?)
    assert.true(pass.type_checker.diagnostics.errors?)
  }
}

test.group('std::compiler::type_checker::TypePass.visit_closure_type') do (g) {
  g.test('Defining a simple closure type') {
    let pass = DummyPass.new
    let node = parse_type('do') as ClosureTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_closure_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.true(type.arguments.empty?)
    assert.true(type.type_parameters.empty?)
    assert.true(type.throw_type.none?)
    assert_instance_of(type.return_type, AnyType)
  }

  g.test('Defining a closure type with valid argument types') {
    let foo_type = ClassType.new('Foo')
    let bar_type = ClassType.new('Bar')
    let pass = DummyPass.new

    pass.module.define_constant(name: foo_type.name, type: foo_type)
    pass.module.define_constant(name: bar_type.name, type: bar_type)

    let node = parse_type('do (Foo, Bar)') as ClosureTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_closure_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.equal(type.arguments.length, 2)

    let args = type.arguments.symbols
    let arg0 = args[0]
    let arg1 = args[1]

    assert.equal(arg0.name, '0')
    assert.equal(arg1.name, '1')

    assert_instance_of(arg0.type, ClassInstance)
    assert_instance_of(arg1.type, ClassInstance)

    assert.equal((arg0.type as ClassInstance).instance_of.name, 'Foo')
    assert.equal((arg1.type as ClassInstance).instance_of.name, 'Bar')
  }

  g.test('Defining a closure type with invalid argument types') {
    let pass = DummyPass.new
    let node = parse_type('do (Foo, Bar)') as ClosureTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_closure_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.equal(type.arguments.length, 2)

    let args = type.arguments.symbols
    let arg0 = args[0]
    let arg1 = args[1]

    assert.equal(arg0.name, '0')
    assert.equal(arg1.name, '1')

    assert.true(arg0.type.error?)
    assert.true(arg1.type.error?)
  }

  g.test('Defining a closure with a valid throw type') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('do !! Foo') as ClosureTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_closure_type(node: node, types: scope)
    let throws = type.throw_type.get

    assert.same_object(node.resolved_type.get, type)
    assert_instance_of(throws, ClassInstance)
    assert.same_object((throws as ClassInstance).instance_of, foo_type)
  }

  g.test('Defining a closure with an invalid throw type') {
    let pass = DummyPass.new
    let node = parse_type('do !! Foo') as ClosureTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_closure_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.true(type.throw_type.get.error?)
  }

  g.test('Defining a closure with a valid return type') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('do -> Foo') as ClosureTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_closure_type(node: node, types: scope)
    let returns = type.return_type

    assert.same_object(node.resolved_type.get, type)
    assert_instance_of(returns, ClassInstance)
    assert.same_object((returns as ClassInstance).instance_of, foo_type)
  }

  g.test('Defining a closure with an invalid return type') {
    let pass = DummyPass.new
    let node = parse_type('do -> Foo') as ClosureTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_closure_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.true(type.return_type.error?)
  }

  g.test('Defining a closure with type parameters') {
    let pass = DummyPass.new
    let foo_type = TraitType.new('Foo')

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('do !(A: Foo, B: Foo)') as ClosureTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_closure_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)

    let params = type.type_parameters.symbols
    let param0 = params[0]
    let param1 = params[1]

    assert.equal(param0.name, 'A')
    assert.equal(param1.name, 'B')

    assert.equal(param0.type.name, 'A')
    assert.equal(param1.type.name, 'B')

    assert.equal(param0.type.required_traits[0].instance_of, foo_type)
    assert.equal(param1.type.required_traits[0].instance_of, foo_type)
  }

  g.test('Defining a closure type with an uninitialised generic argument') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')

    foo_type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('do (Foo)') as ClosureTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_closure_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.true(type.arguments.symbols[0].type.error?)
  }
}

test.group('std::compiler::type_checker::TypePass.visit_lambda_type') do (g) {
  g.test('Defining a simple lambda type') {
    let pass = DummyPass.new
    let node = parse_type('fn') as LambdaTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_lambda_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.true(type.arguments.empty?)
    assert.true(type.type_parameters.empty?)
    assert.true(type.throw_type.none?)
    assert_instance_of(type.return_type, AnyType)
  }

  g.test('Defining a lambda type with valid argument types') {
    let foo_type = ClassType.new('Foo')
    let bar_type = ClassType.new('Bar')
    let pass = DummyPass.new

    pass.module.define_constant(name: foo_type.name, type: foo_type)
    pass.module.define_constant(name: bar_type.name, type: bar_type)

    let node = parse_type('fn (Foo, Bar)') as LambdaTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_lambda_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.equal(type.arguments.length, 2)

    let args = type.arguments.symbols
    let arg0 = args[0]
    let arg1 = args[1]

    assert.equal(arg0.name, '0')
    assert.equal(arg1.name, '1')

    assert_instance_of(arg0.type, ClassInstance)
    assert_instance_of(arg1.type, ClassInstance)

    assert.equal((arg0.type as ClassInstance).instance_of.name, 'Foo')
    assert.equal((arg1.type as ClassInstance).instance_of.name, 'Bar')
  }

  g.test('Defining a lambda type with invalid argument types') {
    let pass = DummyPass.new
    let node = parse_type('fn (Foo, Bar)') as LambdaTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_lambda_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.equal(type.arguments.length, 2)

    let args = type.arguments.symbols
    let arg0 = args[0]
    let arg1 = args[1]

    assert.equal(arg0.name, '0')
    assert.equal(arg1.name, '1')

    assert.true(arg0.type.error?)
    assert.true(arg1.type.error?)
  }

  g.test('Defining a lambda with a valid throw type') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('fn !! Foo') as LambdaTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_lambda_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)

    let throws = type.throw_type.get

    assert_instance_of(throws, ClassInstance)
    assert.same_object((throws as ClassInstance).instance_of, foo_type)
  }

  g.test('Defining a lambda with an invalid throw type') {
    let pass = DummyPass.new
    let node = parse_type('fn !! Foo') as LambdaTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_lambda_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.true(type.throw_type.get.error?)
  }

  g.test('Defining a lambda with a valid return type') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('fn -> Foo') as LambdaTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_lambda_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)

    let returns = type.return_type

    assert_instance_of(returns, ClassInstance)
    assert.same_object((returns as ClassInstance).instance_of, foo_type)
  }

  g.test('Defining a lambda with an invalid return type') {
    let pass = DummyPass.new
    let node = parse_type('fn -> Foo') as LambdaTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_lambda_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.true(type.return_type.error?)
  }

  g.test('Defining a lambda with type parameters') {
    let pass = DummyPass.new
    let foo_type = TraitType.new('Foo')

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('fn !(A: Foo, B: Foo)') as LambdaTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_lambda_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)

    let params = type.type_parameters.symbols
    let param0 = params[0]
    let param1 = params[1]

    assert.equal(param0.name, 'A')
    assert.equal(param1.name, 'B')

    assert.equal(param0.type.name, 'A')
    assert.equal(param1.type.name, 'B')

    assert.equal(param0.type.required_traits[0].instance_of, foo_type)
    assert.equal(param1.type.required_traits[0].instance_of, foo_type)
  }

  g.test('Defining a lambda type with an uninitialised generic argument') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')

    foo_type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let node = parse_type('fn (Foo)') as LambdaTypeNode
    let scope = TypeScope.new(pass.module)
    let type = pass.visit_lambda_type(node: node, types: scope)

    assert.same_object(node.resolved_type.get, type)
    assert.true(type.arguments.symbols[0].type.error?)
  }
}

test.group('std::compiler::type_checker::TypePass.visit_define_type_parameter') do (g) {
  g.test('Defining a type parameter') {
    let pass = DummyPass.new
    let foo_type = TraitType.new('Foo')

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let foo_node = Constant.new(name: 'Foo', location: location)
    let node = DefineTypeParameter
      .new(name: 'T', required_traits: Array.new(foo_node), location: location)

    let scope = TypeScope.new(pass.module)
    let table: SymbolTable!(TypeParameterType) = SymbolTable.new

    pass.visit_define_type_parameter(
      node: node,
      table: table,
      types: scope
    )

    let type = node.resolved_type.get

    assert.equal(type.required_traits[0].instance_of, foo_type)
    assert.equal(table['T'].type, type)
  }

  g.test('Defining an invalid type parameter') {
    let pass = DummyPass.new
    let foo_type = ClassType.new('Foo')

    pass.module.define_constant(name: foo_type.name, type: foo_type)

    let foo_node = Constant.new(name: 'Foo', location: location)
    let node = DefineTypeParameter
      .new(name: 'T', required_traits: Array.new(foo_node), location: location)

    let scope = TypeScope.new(pass.module)
    let table = SymbolTable.new

    pass.visit_define_type_parameter(node: node, table: table, types: scope)

    let type = node.resolved_type

    assert.true(node.resolved_type.none?)
    assert.true(type.none?)
    assert.true(pass.type_checker.diagnostics.errors?)
    assert.true(table.empty?)
  }
}

test.group('std::compiler::type_checker::TypeChecker.add_module') do (g) {
  g.test('Adding a module') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new

    type_checker.add_module(module)

    assert.same_object(type_checker.module(module.name).get, module)
  }
}

test.group('std::compiler::type_checker::TypeChecker.diagnostics') do (g) {
  g.test('Obtaining the diagnostics that have been produced') {
    assert.true(TypeChecker.new.diagnostics.empty?)
  }
}

test.group('std::compiler::type_checker::TypeChecker.check') do (g) {
  g.test('Type-checking a module and its dependencies') {
    let name = ModuleName.new(Array.new('main'))
    let ast = parse("import foo\nclass A {}")
    let foo_parsed = ParsedModule
      .new(name: ModuleName.new(Array.new('foo')), ast: parse('class A {}'))

    let type_checker = TypeChecker.new(dependencies: Array.new(foo_parsed))

    type_checker.check(name: name, ast: ast)

    let main_mod = type_checker.module(name).get
    let foo_mod = type_checker.module(foo_parsed.name).get

    assert.false(main_mod.constants.get('A').none?)
    assert.false(foo_mod.constants.get('A').none?)
    assert.false(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking imports') do (g) {
  g.test('Importing a single symbol') {
    let foo_mod = new_module('foo')
    let bar_mod = new_module('bar')
    let type_checker = TypeChecker.new
    let bar_type = ClassType.new('Bar')
    let node = parse('import foo::(Bar)')

    foo_mod.define_constant(name: bar_type.name, type: bar_type)
    type_checker.add_module(foo_mod)
    type_checker.check_module(module: bar_mod, ast: node)

    let imported = bar_mod.globals['Bar'].type

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(imported as ClassType, bar_type)
  }

  g.test('Importing a non-existing symbol') {
    let foo_mod = new_module('foo')
    let bar_mod = new_module('bar')
    let type_checker = TypeChecker.new
    let node = parse('import foo::(Bar)')

    type_checker.add_module(foo_mod)
    type_checker.check_module(module: bar_mod, ast: node)

    let imported = bar_mod.globals.get('Bar')

    assert.true(imported.none?)
    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Importing the same symbol twice') {
    let foo_mod = new_module('foo')
    let bar_mod = new_module('bar')
    let type_checker = TypeChecker.new
    let bar_type = ClassType.new('Bar')
    let node = parse('import foo::(Bar, Bar)')

    foo_mod.define_constant(name: bar_type.name, type: bar_type)
    type_checker.add_module(foo_mod)
    type_checker.check_module(module: bar_mod, ast: node)

    let imported = bar_mod.globals['Bar'].type

    assert.true(type_checker.diagnostics.errors?)
    assert.same_object(imported as ClassType, bar_type)
  }

  g.test('Importing two different symbols') {
    let foo_mod = new_module('foo')
    let bar_mod = new_module('bar')
    let type_checker = TypeChecker.new
    let node = parse('import foo::(Bar, Baz)')
    let bar_type = ClassType.new('Bar')
    let baz_type = ClassType.new('Baz')

    foo_mod.define_constant(name: bar_type.name, type: bar_type)
    foo_mod.define_constant(name: baz_type.name, type: baz_type)

    type_checker.add_module(foo_mod)
    type_checker.check_module(module: bar_mod, ast: node)

    let bar = bar_mod.globals['Bar'].type
    let baz = bar_mod.globals['Baz'].type

    assert.same_object(bar as ClassType, bar_type)
    assert.same_object(baz as ClassType, baz_type)
  }

  g.test('Importing a symbol with an alias') {
    let foo_mod = new_module('foo')
    let bar_mod = new_module('bar')
    let type_checker = TypeChecker.new
    let node = parse('import foo::(Bar as Baz)')
    let bar_type = ClassType.new('Bar')

    foo_mod.define_constant(name: bar_type.name, type: bar_type)
    type_checker.add_module(foo_mod)
    type_checker.check_module(module: bar_mod, ast: node)

    assert.true(bar_mod.globals.get('Bar').none?)
    assert.false(bar_mod.globals.get('Baz').none?)
  }

  g.test('Importing a module itself') {
    let foo_mod = new_module('foo')
    let bar_mod = new_module('bar')
    let node = parse('import foo::(self)')
    let type_checker = TypeChecker.new

    type_checker.add_module(foo_mod)
    type_checker.check_module(module: bar_mod, ast: node)

    let foo = bar_mod.globals['foo'].type

    assert.same_object(foo as ModuleType, foo_mod)
  }

  g.test('Importing a module using an alias') {
    let foo_mod = new_module('foo')
    let bar_mod = new_module('bar')
    let type_checker = TypeChecker.new
    let node = parse('import foo::(self as bar)')

    type_checker.add_module(foo_mod)
    type_checker.check_module(module: bar_mod, ast: node)

    assert.true(bar_mod.globals.get('foo').none?)
    assert.false(bar_mod.globals.get('bar').none?)
  }

  g.test('Importing all symbols of a module') {
    let foo_mod = new_module('foo')
    let bar_mod = new_module('bar')
    let type_checker = TypeChecker.new
    let node = parse('import foo::*')
    let bar_type = ClassType.new('Bar')
    let baz_type = ClassType.new('Baz')

    foo_mod.define_constant(name: bar_type.name, type: bar_type)
    foo_mod.define_constant(name: baz_type.name, type: baz_type)

    type_checker.add_module(foo_mod)
    type_checker.check_module(module: bar_mod, ast: node)

    let bar = bar_mod.globals['Bar'].type
    let baz = bar_mod.globals['Baz'].type

    assert.same_object(bar as ClassType, bar_type)
    assert.same_object(baz as ClassType, baz_type)
  }

  g.test('Importing a symbol from a non-existing module') {
    # Imports of undefined modules are already handled when recursively parsing
    # a module and its dependencies. As part of that process, diagnostics are
    # already produced. So instead of repeating that, we just panic.
    assert.panic {
      let module = new_module('bar')
      let type_checker = TypeChecker.new
      let node = parse('import foo::(Bar)')

      type_checker.check_module(module: module, ast: node)
    }
  }

  g.test('Importing an external function') {
    let foo_mod = new_module('foo')
    let bar_mod = new_module('bar')
    let type_checker = TypeChecker.new
    let bar_type = MethodType
      .new(name: 'bar', layout: BlockLayout.new(AnyType.new), external: True)

    let node = parse('import foo::(bar)')

    foo_mod.define_method(name: bar_type.name, type: bar_type)
    type_checker.add_module(foo_mod)
    type_checker.check_module(module: bar_mod, ast: node)

    assert.true(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking class definitions') do (g) {
  g.test('Defining an empty class') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let node = parse('class A {}')

    type_checker.check_module(module: module, ast: node)

    let type = module.constants['A'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(type, ClassType)
    assert_instance_of(node.children[0].resolved_type.get, ClassType)
  }

  g.test('Defining an empty generic class') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let foo_type = TraitType.new('Foo')
    let node = parse('class A!(T: Foo) {}')

    module.define_constant(name: foo_type.name, type: foo_type)
    type_checker.check_module(module: module, ast: node)

    let type = module.constants['A'].type

    assert_instance_of(type, ClassType)
    assert_instance_of(node.children[0].resolved_type.get, ClassType)

    let param = (type as ClassType).type_parameters['T'].type

    assert.false(type_checker.diagnostics.errors?)
    assert.equal(param.required_traits[0].instance_of, foo_type)
  }

  g.test('Defining a generic class with an invalid type parameter') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let node = parse('class A!(T: Foo) {}')

    type_checker.check_module(module: module, ast: node)

    let type = module.constants['A'].type

    assert.true(type_checker.diagnostics.errors?)
    assert_instance_of(type, ClassType)
    assert_instance_of(node.children[0].resolved_type.get, ClassType)
    assert.true((type as ClassType).type_parameters.get('T').none?)
  }

  g.test('Redefining an existing class') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let a_type = ClassType.new('A')
    let node = parse('class A {}')

    module.define_constant(name: a_type.name, type: a_type)
    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.same_object(module.constants['A'].type, a_type)
    assert_instance_of(node.children[0].resolved_type.get, ClassType)
  }
}

test.group('Type-checking trait definitions') do (g) {
  g.test('Defining a trait') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let node = parse('trait A {}')

    type_checker.check_module(module: module, ast: node)

    let type = module.constants['A'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(type, TraitType)
    assert_instance_of(node.children[0].resolved_type.get, TraitType)
  }

  g.test('Defining a generic trait') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let foo_type = TraitType.new('Foo')
    let node = parse('trait A!(T: Foo) {}')

    module.define_constant(name: foo_type.name, type: foo_type)
    type_checker.check_module(module: module, ast: node)

    let type = module.constants['A'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(type, TraitType)
    assert_instance_of(node.children[0].resolved_type.get, TraitType)

    let param = (type as ClassType).type_parameters['T'].type

    assert.equal(param.required_traits[0].instance_of, foo_type)
  }

  g.test('Defining a generic trait with an invalid type parameter') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let node = parse('trait A!(T: Foo) {}')

    type_checker.check_module(module: module, ast: node)

    let type = module.constants['A'].type

    assert.true(type_checker.diagnostics.errors?)
    assert_instance_of(type, TraitType)
    assert.same_object(node.children[0].resolved_type.get, type)
    assert.true((type as TraitType).type_parameters.get('T').none?)
  }

  g.test('Redefining an existing trait') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let a_type = TraitType.new('A')
    let node = parse('trait A {}')

    module.define_constant(name: a_type.name, type: a_type)
    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.same_object(module.constants['A'].type, a_type)
    assert_instance_of(node.children[0].resolved_type.get, TraitType)
  }
}

test.group('Type-checking attribute definitions') do (g) {
  g.test('Defining an attribute') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let foo_type = ClassType.new('Foo')
    let node = parse('class A { @foo: Foo }')
    let attr_node =
      (node.children[0] as DefineClass).body.children[0] as DefineAttribute

    module.define_constant(name: foo_type.name, type: foo_type)
    type_checker.check_module(module: module, ast: node)

    let obj = module.constants['A'].type as ClassType
    let attr = obj.attributes['@foo'].type

    assert_instance_of(attr.public_type, ClassInstance)
    assert_instance_of(attr.internal_type, ClassInstance)
    assert.same_object(attr_node.resolved_type.get, attr.internal_type)
    assert.same_object(
      (attr.internal_type as ClassInstance).instance_of,
      foo_type
    )
  }

  g.test('Defining an attribute as a type parameter') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let node = parse('class A!(T) { @foo: T }')
    let attr_node =
      (node.children[0] as DefineClass).body.children[0] as DefineAttribute

    type_checker.check_module(module: module, ast: node)

    let obj = module.constants['A'].type as ClassType
    let attr = obj.attributes['@foo'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(attr.internal_type, RigidTypeParameterType)
    assert_instance_of(attr.public_type, TypeParameterType)
    assert.same_object(attr_node.resolved_type.get, attr.internal_type)
  }

  g.test('Defining an attribute as a generic type containing a type parameter') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let node = parse('class A!(T) { @foo: List!(T) }')
    let list_type = ClassType.new('List')
    let list_param = TypeParameterType.new('A')

    list_type.type_parameters.define(name: 'A', type: list_param)
    module.globals.define(name: list_type.name, type: list_type)
    type_checker.check_module(module: module, ast: node)

    let obj = module.constants['A'].type as ClassType
    let attr = obj.attributes['@foo'].type.internal_type as ClassInstance

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(attr, ClassInstance)

    let list_param_type = attr.lookup_type_parameter_type(list_param).get
    let obj_param = obj.lookup_type_parameter('T').get.type

    assert_instance_of(list_param_type, RigidTypeParameterType)
    assert.same_object(
      (list_param_type as RigidTypeParameterType).type,
      obj_param
    )
  }

  g.test('Defining an attribute with an invalid type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let node = parse('class A { @foo: Foo }')
    let attr_node =
      (node.children[0] as DefineClass).body.children[0] as DefineAttribute

    type_checker.check_module(module: module, ast: node)

    let obj = module.constants['A'].type as ClassType
    let attr = obj.attributes['@foo'].type

    assert.true(type_checker.diagnostics.errors?)
    assert.true(attr.public_type.error?)
    assert.true(attr.internal_type.error?)
    assert.true(attr_node.resolved_type.get.error?)
  }
}

test.group('Type-checking local variable definitions') do (g) {
  g.test('Defining a local variable') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let a = 10')

    type_checker.check_module(module: module, ast: body)

    let symbol = body.variable_scope.symbols['a']
    let let_node = body.children[0] as DefineLocalVariable

    assert.false(type_checker.diagnostics.errors?)

    assert.false(symbol.mutable?)
    assert.false(symbol.type.error?)

    assert.same_object(let_node.resolved_type.get, symbol.type)
    assert.same_object(
      let_node.resolved_type.get,
      let_node.value.resolved_type.get
    )
  }

  g.test('Defining a local variable with an invalid value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let a = Foo')

    type_checker.check_module(module: module, ast: body)

    let symbol = body.variable_scope.symbols['a']
    let let_node = body.children[0] as DefineLocalVariable

    assert.true(type_checker.diagnostics.errors?)

    assert.false(symbol.mutable?)
    assert.true(symbol.type.error?)

    assert.same_object(let_node.resolved_type.get, symbol.type)
    assert.same_object(
      let_node.resolved_type.get,
      let_node.value.resolved_type.get
    )
  }

  g.test('Defining a local variable with an explicit type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let a: Any = 10')

    type_checker.check_module(module: module, ast: body)

    let symbol = body.variable_scope.symbols['a']
    let let_node = body.children[0] as DefineLocalVariable

    assert.false(type_checker.diagnostics.errors?)

    assert.false(symbol.mutable?)
    assert.false(symbol.type.error?)

    assert.same_object(let_node.resolved_type.get, symbol.type)
    assert.same_object(
      let_node.resolved_type.get,
      let_node.value_type.get.resolved_type.get
    )
    assert_instance_of(let_node.resolved_type.get, AnyType)
  }

  g.test('Defining a local variable with an incompatible value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let a: String = 10')

    module
      .define_constant(name: 'String', type: type_checker.builtins.string_type)

    type_checker.check_module(module: module, ast: body)

    let symbol = body.variable_scope.symbols['a']
    let let_node = body.children[0] as DefineLocalVariable

    assert.true(type_checker.diagnostics.errors?)

    assert.false(symbol.mutable?)
    assert.false(symbol.type.error?)

    assert.same_object(let_node.resolved_type.get, symbol.type)
    assert.same_object(
      let_node.resolved_type.get,
      let_node.value_type.get.resolved_type.get
    )

    assert_object_instance(
      let_node.resolved_type.get,
      type_checker.builtins.string_type
    )
  }

  g.test('Defining a local variable with an undefined explicit type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let a: Object = 10')

    type_checker.check_module(module: module, ast: body)

    let symbol = body.variable_scope.symbols['a']
    let let_node = body.children[0] as DefineLocalVariable

    assert.true(type_checker.diagnostics.errors?)

    assert.false(symbol.mutable?)
    assert.true(symbol.type.error?)

    assert.same_object(let_node.resolved_type.get, symbol.type)
    assert.same_object(
      let_node.resolved_type.get,
      let_node.value_type.get.resolved_type.get
    )
  }

  g.test('Defining a local variable with Self as the explicit type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let a: Self = 10')

    type_checker.check_module(module: module, ast: body)

    let symbol = body.variable_scope.symbols['a']
    let let_node = body.children[0] as DefineLocalVariable

    assert.true(type_checker.diagnostics.errors?)

    assert.false(symbol.mutable?)
    assert.true(symbol.type.error?)

    assert.same_object(let_node.resolved_type.get, symbol.type)
    assert.true(let_node.resolved_type.get.error?)
  }

  g.test('Defining an already existing local variable') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let a = 10')
    let a_type = type_checker.builtins.float_type.new_instance

    body.variable_scope.symbols.define(name: 'a', type: a_type)

    type_checker.check_module(module: module, ast: body)

    let symbol = body.variable_scope.symbols['a']
    let let_node = body.children[0] as DefineLocalVariable

    assert.true(type_checker.diagnostics.errors?)
    assert.same_object(symbol.type, a_type)

    assert.false(let_node.resolved_type.same_object?(symbol.type))
    assert.same_object(
      let_node.resolved_type.get,
      let_node.value.resolved_type.get
    )
  }
}

test.group('Type-checking literals') do (g) {
  g.test('Type-checking an integer literal') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('10')

    type_checker.check_module(module: module, ast: body)

    assert_object_instance(
      body.children[0].resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Type-checking a float literal') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('10.5')

    type_checker.check_module(module: module, ast: body)

    assert_object_instance(
      body.children[0].resolved_type.get,
      type_checker.builtins.float_type
    )
  }

  g.test('Type-checking a string literal') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('"foo"')

    type_checker.check_module(module: module, ast: body)

    assert_object_instance(
      body.children[0].resolved_type.get,
      type_checker.builtins.string_type
    )
  }
}

test.group('Type-checking constant references') do (g) {
  g.test('Referring to an undefined constant') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('Foo')
    let node = body.children[0] as Constant

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.symbol.none?)
    assert.true(body.children[0].resolved_type.get.error?)
  }

  g.test('Referring to a defined constant') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('Foo')
    let node = body.children[0] as Constant
    let foo_type = type_checker.builtins.string_type.new_instance

    module.define_constant(name: 'Foo', type: foo_type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.symbol.get.type, foo_type)
    assert.same_object(body.children[0].resolved_type.get, foo_type)
  }
}

test.group('Type-checking method definitions') do (g) {
  g.test('Defining a method without arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo {}')

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)

    let method = module.methods['foo'].type as MethodType

    assert_instance_of(method, MethodType)
    assert.same_object(body.children[0].resolved_type.get, method)
    assert.true(method.arguments.empty?)
  }

  g.test('Defining a method with invalid statically typed arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(a: A, b: B) {}')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)

    let method = module.methods['foo'].type as MethodType

    assert.true(method.arguments['a'].type.error?)
    assert.true(method.arguments['b'].type.error?)
  }

  g.test('Defining a method with valid statically typed arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(a: String, b: Integer) {}')

    module
      .define_constant(name: 'String', type: type_checker.builtins.string_type)

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType
    let a_type = method.arguments['a'].type
    let b_type = method.arguments['b'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(a_type, type_checker.builtins.string_type)
    assert_object_instance(b_type, type_checker.builtins.integer_type)
  }

  g.test('Defining a method with a default argument value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(a = 10) {}')

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType
    let a_type = method.arguments['a'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(a_type, type_checker.builtins.integer_type)
  }

  g.test('Defining a method with a default argument value and a compatible explicit type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(a: Any = 10) {}')

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType
    let a_type = method.arguments['a'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(a_type, AnyType)
  }

  g.test('Defining a method with a default argument value and an incompatible explicit type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(a: Float = 10) {}')

    module.define_constant(name: 'Float', type_checker.builtins.float_type)

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType
    let a_type = method.arguments['a'].type

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(a_type, type_checker.builtins.float_type)
  }

  g.test('Defining a method with a statically typed rest argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(*a: Integer) {}')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType
    let arg = method.arguments['a'].type as ClassInstance

    assert.false(type_checker.diagnostics.errors?)
    assert.true(method.rest_argument?)
    assert_object_instance(arg, type_checker.builtins.integer_type)
  }

  g.test('Defining a method with an invalid throw type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo !! Integer {}')

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.true(type_checker.diagnostics.errors?)
    assert.true(method.throw_type.get.error?)
  }

  g.test('Defining a method with a valid throw type that never throws') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo !! Integer {}')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(
      method.throw_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Defining a method with a valid throw type that throws') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo !! Integer { throw 10 }')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      method.throw_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Defining a method with an invalid return type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo -> Integer {}')

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.true(type_checker.diagnostics.errors?)
    assert.true(method.return_type.error?)
  }

  g.test('Defining a method with a return value that does not return') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo -> Integer {}')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(
      method.return_type,
      type_checker.builtins.integer_type
    )
  }

  g.test('Defining a method without an explicit return type that returns') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo { 10 }')

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(method.return_type, type_checker.builtins.nil_type)
  }

  g.test('Defining a method with a valid explicit return type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo -> Integer { return 10 }')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      method.return_type,
      type_checker.builtins.integer_type
    )
  }

  g.test('Defining a method with an invalid explicit return type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo -> Integer { return 10.5 }')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(type_checker.diagnostics.length, 1)
  }

  g.test('Defining a method with a valid implicit return type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo -> Integer { 10 }')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method with an invalid implicit return type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo -> Integer { 10.5 }')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method with valid type parameters') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo!(A, B: ToInteger) {}')
    let trait_type = TraitType.new('ToInteger')

    module
      .define_constant(name: 'ToInteger', type: TraitInstance.new(trait_type))

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.false(type_checker.diagnostics.errors?)
    assert.equal(method.type_parameters.length, 2)

    assert.true(method.type_parameters['A'].type.required_traits.empty?)

    assert_trait_instance(
      method.type_parameters['B'].type.required_traits[0],
      trait_type
    )
  }

  g.test('Defining a method with invalid type parameters') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo!(A, B: ToInteger) {}')

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(method.type_parameters.length, 1)

    assert.true(method.type_parameters['A'].type.required_traits.empty?)
    assert.true(method.type_parameters.get('B').none?)
  }

  g.test('Defining a method with its type arguments used as method bounds') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo!(T) when T: ToString {}')
    let trait_type = TraitType.new('ToString')

    module.define_constant(name: 'ToString', trait_type)

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type

    assert.true(type_checker.diagnostics.errors?)
    assert.true(method.type_parameter_bounds.empty?)
  }

  g.test('Defining a method with duplicate type parameter bounds') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait1 = TraitType.new('ToString')
    let trait2 = TraitType.new('ToInteger')
    let body =
      parse('class A!(T) { def foo when T: ToString, T: ToInteger {} }')

    module.define_constant(name: 'ToString', trait1)
    module.define_constant(name: 'ToInteger', trait2)

    type_checker.check_module(module: module, ast: body)

    let a_obj = module.constants['A'].type as ClassType
    let param = a_obj.type_parameters['T'].type
    let method = a_obj.instance_methods['foo'].type
    let bounds = method.type_parameter_bounds[param]

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(bounds.length, 1)
    assert.equal(bounds[0].instance_of, trait1)
  }

  g.test('Defining a method with an argument type used in a method bound') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class A!(T) { def foo(a: T) when T: ToString {} }')
    let trait_type = TraitType.new('ToString')

    module.define_constant(name: 'ToString', trait_type)

    type_checker.check_module(module: module, ast: body)

    let a_obj = module.constants['A'].type as ClassType
    let method = a_obj.instance_methods['foo'].type as MethodType
    let arg_type = method.arguments['a'].type as TypeParameterType

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(arg_type, TypeParameterType)

    assert.equal(arg_type.name, 'T')
    assert.true(arg_type.required_traits.empty?)
  }

  g.test('Defining a method with a throw type used in a method bound') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body =
      parse('class A!(T) { def foo(a: T) !! T when T: ToString { throw a } }')

    let trait_type = TraitType.new('ToString')

    module.define_constant(name: 'ToString', trait_type)

    type_checker.check_module(module: module, ast: body)

    let a_obj = module.constants['A'].type as ClassType
    let method = a_obj.instance_methods['foo'].type as MethodType
    let ttype = method.throw_type.get as TypeParameterType

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(ttype, TypeParameterType)

    assert.equal(ttype.name, 'T')
    assert.true(ttype.required_traits.empty?)
  }

  g.test('Defining a method with a return type used in a method bound') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class A!(T) { def foo -> T when T: ToString {} }')
    let trait_type = TraitType.new('ToString')

    module.define_constant(name: 'ToString', trait_type)

    type_checker.check_module(module: module, ast: body)

    let a_obj = module.constants['A'].type as ClassType
    let method = a_obj.instance_methods['foo'].type as MethodType
    let rtype = method.return_type as TypeParameterType

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(rtype, TypeParameterType)

    assert.equal(rtype.name, 'T')
    assert.true(rtype.required_traits.empty?)
  }

  g.test('Defining a module method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(a: Self) {} def foo {}')

    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(method.arguments.length, 1)
  }

  g.test('Defining a module method that already exists') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(a: Self) {}')
    let method_type =
      MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

    module.define_method(name: 'foo', type: method_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.same_object(module.methods['foo'].type, method_type)
  }

  g.test('Defining a module method with the same name as an imported constant') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(a: Self) {}')

    module.globals.define(name: 'foo', type: ClassType.new('Foo'))
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.false(module.methods.get('foo').none?)
  }

  g.test('Defining a default method with the same name as a required method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('trait Foo { def foo def foo {} }')

    type_checker.check_module(module: module, ast: body)

    let trait_type = body.children[0].resolved_type.get as TraitType

    assert.true(type_checker.diagnostics.errors?)
    assert.true(trait_type.default_methods.empty?)
  }

  g.test('Defining a required method with the same name as a default method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('trait Foo { def foo {} def foo }')

    type_checker.check_module(module: module, ast: body)

    let trait_type = body.children[0].resolved_type.get as TraitType

    assert.true(type_checker.diagnostics.errors?)
    assert.true(trait_type.required_methods.empty?)
  }

  g.test('Defining a required method with a default argument value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('trait Foo { def foo(a = 10) }')

    type_checker.check_module(module: module, ast: body)

    let trait_type = body.children[0].resolved_type.get as TraitType
    let method = trait_type.required_methods['foo'].type

    assert.true(type_checker.diagnostics.errors?)

    assert_object_instance(
      method.arguments['a'].type,
      type_checker.builtins.integer_type
    )
  }

  g.test('Defining a method in an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('class A { def foo -> Integer { 10 } }')
    let object_node = body.children[0] as DefineClass
    let method_node = object_node.body.children[0] as DefineMethod
    let int_node = method_node.body.children[0] as IntegerLiteral

    module.define_constant(name: 'Integer', type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(int_node.resolved_type.get, int_type)
  }

  g.test('Defining a method in a trait') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('trait A { def foo -> Integer { 10 } }')
    let object_node = body.children[0] as DefineTrait
    let method_node = object_node.body.children[0] as DefineMethod
    let int_node = method_node.body.children[0] as IntegerLiteral

    module.define_constant(name: 'Integer', type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(int_node.resolved_type.get, int_type)
  }

  g.test('Defining a method in a trait implementation') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('impl A for B { def foo -> Integer { 10 } }')
    let object_node = body.children[0] as ImplementTrait
    let method_node = object_node.body.children[0] as DefineMethod
    let int_node = method_node.body.children[0] as IntegerLiteral

    module.define_constant(name: 'Integer', type: int_type)
    module.define_constant(name: 'A', type: TraitType.new('A'))
    module.define_constant(name: 'B', type: ClassType.new('B'))

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(int_node.resolved_type.get, int_type)
  }

  g.test('Defining a method when reopening an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('impl Integer { def foo -> Integer { 10 } }')
    let object_node = body.children[0] as ImplementTrait
    let method_node = object_node.body.children[0] as DefineMethod
    let int_node = method_node.body.children[0] as IntegerLiteral

    module.define_constant(name: 'Integer', type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(int_node.resolved_type.get, int_type)
  }

  g.test('Defining a method in an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class Foo { def foo {} }')

    type_checker.check_module(module: module, ast: body)

    let obj_type = body.children[0].resolved_type.get as ClassType

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(obj_type, ClassType)

    assert.false(obj_type.instance_methods.get('foo').none?)
  }

  g.test('Redefining a method in an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class Foo { def foo(a: Self) {} def foo {} }')

    type_checker.check_module(module: module, ast: body)

    let foo_type = module.constants['Foo'].type as ClassType
    let method = foo_type.instance_methods['foo'].type

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(method.arguments.length, 1)
  }

  g.test('Defining an instance method with the same name as a static method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class Foo { static def foo {} def foo {} }')

    type_checker.check_module(module: module, ast: body)

    let foo_type = module.constants['Foo'].type as ClassType

    assert.true(type_checker.diagnostics.errors?)
    assert.false(foo_type.static_methods.get('foo').none?)
    assert.true(foo_type.instance_methods.get('foo').none?)
  }

  g.test('Defining a static method with the same name as an instance method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class Foo { def foo {} static def foo {} }')

    type_checker.check_module(module: module, ast: body)

    let foo_type = module.constants['Foo'].type as ClassType

    assert.true(type_checker.diagnostics.errors?)
    assert.true(foo_type.static_methods.get('foo').none?)
    assert.false(foo_type.instance_methods.get('foo').none?)
  }

  g.test('Defining an instance method with an argument depending on the "self" type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class Foo { def foo(a = self) {} }')

    type_checker.check_module(module: module, ast: body)

    let obj_type = module.constants['Foo'].type as ClassType
    let method = obj_type.instance_methods['foo'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(method.arguments['a'].type, obj_type)
  }

  g.test('Defining a static method with an argument depending on the "self" type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class Foo { static def foo(a = self) {} }')

    type_checker.check_module(module: module, ast: body)

    let obj_type = module.constants['Foo'].type as ClassType
    let method = obj_type.static_methods['foo'].type

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(method.arguments['a'].type, obj_type)
  }

  g.test('Defining a method inside a trait') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('trait Foo { def foo {} }')

    type_checker.check_module(module: module, ast: body)

    let trait_type = body.children[0].resolved_type.get as TraitType

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(trait_type, TraitType)

    assert.false(trait_type.default_methods.get('foo').none?)
  }

  g.test('Defining a default method with an argument depending on the "self" type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('trait Foo { def foo(a = self) {} }')

    type_checker.check_module(module: module, ast: body)

    let trait_type = module.constants['Foo'].type as TraitType
    let method = trait_type.default_methods['foo'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_trait_instance(method.arguments['a'].type, trait_type)
  }

  g.test('Referring to a method argument in its body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo(a: Integer) { a }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let method = body.children[0] as DefineMethod
    let lvar = method.body.children[0] as Identifier

    assert_object_instance(lvar.resolved_type.get, int_type)
    assert.false(type_checker.diagnostics.errors?)
  }

  g.test('Referring to a method rest argument in its body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let ary_type = type_checker.builtins.array_type
    let body = parse('def foo(*a: Integer) { a }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let method = body.children[0] as DefineMethod
    let lvar = method.body.children[0] as Identifier

    let param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    let type = lvar.resolved_type.get

    assert_object_instance(type, ary_type)
    assert_object_instance(type.lookup_type_parameter_type(param).get, int_type)
    assert.false(type_checker.diagnostics.errors?)
  }

  g.test('Defining a static method that returns self when the return type is Self') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('impl Integer { static def foo -> Self { self } }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    # Here `self` is `Integer` itself, but `-> Self` means "returns an
    # _instance_ of Integer".
    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method that returns self when the return type is Self') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('impl Integer { def foo -> Self { self } }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method that yields') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo => Integer { yield 10 }')
    let node = body.children[0] as DefineMethod

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let method = module.methods['foo'].type as MethodType

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(method.yield_type.get, int_type)
    assert_object_instance(node.body.children[0].resolved_type.get, int_type)
  }

  g.test('Defining a required method with a yield type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('trait A { def foo => Integer }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let ttype = module.constants['A'].type as TraitType
    let mtype = ttype.required_methods['foo'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(mtype.yield_type.get, int_type)
  }

  g.test('Defining a method with a yield type that never yields') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo => Integer {}')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method that yields without a yield type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo { yield 10 }')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method that yields an invalid type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo => Integer { yield 10.5 }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method with a yield type that returns a value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse(
      'def foo => Integer {
        yield 10
        return 10
      }'
    )

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method with a yield type that returns without a value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo => Integer { yield 10 return }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method with both a return and yield type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo -> Integer => Integer { yield 10 }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining a method using a required class type parameter argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class A!(T) { def foo(arg: T) {} }')
    let obj_node = body.children[0] as DefineClass
    let meth_node = obj_node.body.children[0] as DefineMethod
    let arg_node = meth_node.arguments[0] as DefineRequiredArgument

    type_checker.check_module(module: module, ast: body)

    let body_vars = meth_node.body.variable_scope
    let obj_type = module.constants['A'].type
    let param = obj_type.lookup_type_parameter('T').get.type
    let lvar = body_vars.symbols['arg'].type

    assert.same_object(arg_node.resolved_type.get, param)
    assert_instance_of(lvar, RigidTypeParameterType)
    assert.same_object((lvar as RigidTypeParameterType).type, param)
  }

  g.test('Defining a method using a required method type parameter argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo!(T)(arg: T) {}')
    let meth_node = body.children[0] as DefineMethod
    let arg_node = meth_node.arguments[0] as DefineRequiredArgument

    type_checker.check_module(module: module, ast: body)

    let body_vars = meth_node.body.variable_scope
    let meth_type = module.methods['foo'].type
    let param = meth_type.lookup_type_parameter('T').get.type
    let lvar = body_vars.symbols['arg'].type

    assert.same_object(arg_node.resolved_type.get, param)
    assert_instance_of(lvar, RigidTypeParameterType)
    assert.same_object((lvar as RigidTypeParameterType).type, param)
  }

  g.test('Defining a method using an optional method type parameter argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo!(T)(arg: T = 10) {}')
    let meth_node = body.children[0] as DefineMethod
    let arg_node = meth_node.arguments[0] as DefineOptionalArgument

    type_checker.check_module(module: module, ast: body)

    let body_vars = meth_node.body.variable_scope
    let meth_type = module.methods['foo'].type
    let param = meth_type.lookup_type_parameter('T').get.type
    let lvar = body_vars.symbols['arg'].type

    assert.same_object(arg_node.resolved_type.get, param)
    assert_instance_of(lvar, RigidTypeParameterType)
    assert.same_object((lvar as RigidTypeParameterType).type, param)
  }

  g.test('Defining a method using a rest method type parameter argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo!(T)(*arg: T) {}')
    let meth_node = body.children[0] as DefineMethod
    let arg_node = meth_node.arguments[0] as DefineRestArgument

    type_checker.check_module(module: module, ast: body)

    let body_vars = meth_node.body.variable_scope
    let meth_type = module.methods['foo'].type
    let param = meth_type.lookup_type_parameter('T').get.type
    let lvar = body_vars.symbols['arg'].type

    let arg_node_type = arg_node.resolved_type.get
    let ary_param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    let lvar_param_type = lvar.lookup_type_parameter_type(ary_param).get

    assert.same_object(arg_node_type, param)
    assert_object_instance(lvar, type_checker.builtins.array_type)
    assert_instance_of(lvar_param_type, RigidTypeParameterType)
    assert.same_object((lvar_param_type as RigidTypeParameterType).type, param)
  }

  g.test('Referring to an class type parameter in a method body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class A!(T) { def foo { T } }')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Referring to a trait type parameter in a method body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('trait A!(T) { def foo { T } }')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Referring to a method type parameter in a method body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo!(T) { T }')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Referring to a type in a method body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let ary_type = ClassType.new('Array')
    let body = parse('def foo { Array }')
    let meth_node = body.children[0] as DefineMethod
    let const_node = meth_node.body.children[0] as Constant

    module.define_constant(name: ary_type.name, type: ary_type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(const_node.resolved_type.get, ary_type)
  }

  g.test('Referring to a generic type using type arguments in a method body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let foo_type = ClassType.new('Foo')
    let ary_type = ClassType.new('Array')
    let ary_param = TypeParameterType.new('T')

    ary_type.type_parameters.define(name: ary_param.name, type: ary_param)

    let body = parse('def foo { Array!(Foo) }')
    let meth_node = body.children[0] as DefineMethod
    let const_node = meth_node.body.children[0] as Constant

    module.define_constant(name: ary_type.name, type: ary_type)
    module.define_constant(name: foo_type.name, type: foo_type)
    type_checker.check_module(module: module, ast: body)

    let const_type = const_node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(const_type, ary_type)
    assert_object_instance(
      const_type.lookup_type_parameter_type(ary_param).get,
      foo_type
    )
  }
}

test.group('Type-checking constant definitions') do (g) {
  g.test('Defining a constant') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let A = 10')

    type_checker.check_module(module: module, ast: body)

    let type = module.constants['A'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, type_checker.builtins.integer_type)
  }

  g.test('Defining an already defined constant') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let A = 10')

    module.define_constant(
      name: 'A',
      type: ClassInstance.new(type_checker.builtins.float_type)
    )

    type_checker.check_module(module: module, ast: body)

    let type = module.constants['A'].type

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(type, type_checker.builtins.float_type)
  }

  g.test('Defining a constant with the same name as an imported constant') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('let A = 10')

    module.globals.define(
      name: 'A',
      type: ClassInstance.new(type_checker.builtins.float_type)
    )

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(module.constants.get('A').none?)

    assert_object_instance(
      module.globals['A'].type,
      type_checker.builtins.float_type
    )
  }
}

test.group('Type-checking trait implementations') do (g) {
  g.test('Implementing a trait') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('ToString')
    let obj_type = ClassType.new('Number')

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl ToString for Number {}')
    let impl_node = node.children[0] as ImplementTrait

    type_checker.check_module(module: module, ast: node)

    let implementation = obj_type.implemented_traits[trait_type]

    assert_instance_of(impl_node.class_name.resolved_type.get, ClassType)
    assert_instance_of(impl_node.trait_name.resolved_type.get, TraitInstance)

    assert.same_object(impl_node.class_name.resolved_type.get, obj_type)
    assert.true(
      (impl_node.trait_name.resolved_type.get as TraitInstance)
        .instance_of == trait_type
    )

    assert.equal(implementation.type.instance_of, trait_type)
    assert.true(implementation.bounds.empty?)
    assert.false(type_checker.diagnostics.errors?)
  }

  g.test('Implementing a trait with type parameter bounds') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('ToString')
    let obj_type = ClassType.new('Number')
    let type_param = TypeParameterType.new('A')

    obj_type.type_parameters.define(name: 'A', type: type_param)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl ToString for Number when A: ToString {}')

    type_checker.check_module(module: module, ast: node)

    let implementation = obj_type.implemented_traits[trait_type]
    let bounds = implementation.bounds[type_param]

    assert.equal(bounds.length, 1)
    assert.equal(bounds[0].instance_of, trait_type)
  }

  g.test('Implementing a trait with duplicate type parameter bounds') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('ToString')
    let obj_type = ClassType.new('Number')
    let type_param = TypeParameterType.new('A')

    obj_type.type_parameters.define(name: 'A', type: type_param)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node =
      parse('impl ToString for Number when A: ToString, A: ToString {}')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
  }

  g.test('Implementing a trait with type parameter bounds and a custom method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('ToString')
    let obj_type = ClassType.new('Number')
    let type_param = TypeParameterType.new('A')

    obj_type.type_parameters.define(name: 'A', type: type_param)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl ToString for Number when A: ToString { def foo {} }')

    type_checker.check_module(module: module, ast: node)

    let method = obj_type.instance_methods['foo'].type
    let bounds = method.type_parameter_bounds[type_param]

    assert.equal(bounds.length, 1)
    assert.equal(bounds[0].instance_of, trait_type)
  }

  g.test('Implementing a trait with type parameter bounds and a default method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('ToString')
    let obj_type = ClassType.new('Number')
    let type_param = TypeParameterType.new('A')
    let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

    obj_type.type_parameters.define(name: 'A', type: type_param)
    trait_type.default_methods.define(name: 'foo', type: foo)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl ToString for Number when A: ToString {}')

    type_checker.check_module(module: module, ast: node)

    let method = obj_type.instance_methods['foo'].type

    assert.true(method.type_parameter_bounds.empty?)
  }

  g.test('Implementing a non-existing trait') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('Number')

    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl ToString for Number {}')
    let impl_node = node.children[0] as ImplementTrait

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(impl_node.trait_name.resolved_type.get.error?)
    assert.true(obj_type.implemented_traits.empty?)
  }

  g.test('Implementing a trait for a non-existing object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('ToString')

    module.define_constant(name: trait_type.name, type: trait_type)

    let node = parse('impl ToString for Number {}')
    let impl_node = node.children[0] as ImplementTrait

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(impl_node.class_name.resolved_type.get.error?)
    assert.true(impl_node.trait_name.resolved_type.none?)
  }

  g.test('Implementing a trait with type parameter bounds for a non-generic object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('ToString')
    let obj_type = ClassType.new('Number')

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl ToString for Number when A: ToString {}')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
  }

  g.test('Implementing a trait with invalid bounds requirements') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('ToString')
    let obj_type = ClassType.new('Number')
    let type_param = TypeParameterType.new('A')

    obj_type.type_parameters.define(name: 'A', type: type_param)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl ToString for Number when A: Kittens {}')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
  }

  g.test('Defining a method with bounds that overwrite the bounds of a trait implementation') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait1 = TraitType.new('ToString')
    let trait2 = TraitType.new('ToInteger')
    let obj_type = ClassType.new('A')
    let type_param = TypeParameterType.new('T')

    obj_type.type_parameters.define(name: type_param.name, type: type_param)

    module.define_constant(name: trait1.name, type: trait1)
    module.define_constant(name: trait2.name, type: trait2)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse(
      'impl ToString for A when T: ToString { def foo when T: ToInteger {} }'
    )

    type_checker.check_module(module: module, ast: node)

    let method = obj_type.instance_methods['foo'].type
    let bounds = method.type_parameter_bounds[type_param]

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(bounds.length, 1)
    assert.equal(bounds[0].instance_of, trait1)
  }

  g.test('Implementing a generic trait without the required type arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let type_param = TypeParameterType.new('A')

    trait_type.type_parameters.define(name: type_param.name, type: type_param)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer {}')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
  }

  g.test('Implementing a trait with unmet requirements') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let method_type =
      MethodType.new(name: '+', layout: BlockLayout.new(NeverType.new))

    trait_type.required_methods.define(name: '+', type: method_type)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer {}')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
  }

  g.test('Implementing a trait with an unimplemented dependency') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('Integer')
    let trait1 = TraitType.new('Sub')
    let trait2 = TraitType
      .new(name: 'Add', required_traits: Array.new(TraitInstance.new(trait1)))

    module.define_constant(name: trait1.name, type: trait1)
    module.define_constant(name: trait2.name, type: trait2)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer {}')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
  }

  g.test('Implementing a trait with all requirements met') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let method_type = MethodType.new(
      name: '+',
      layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
    )

    trait_type.required_methods.define(name: '+', type: method_type)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer { def + {} }')

    type_checker.check_module(module: module, ast: node)

    let implementation = obj_type.implemented_traits[trait_type]

    assert.false(type_checker.diagnostics.errors?)
    assert.false(obj_type.implemented_traits.empty?)
    assert.equal(implementation.type.instance_of, trait_type)
  }

  g.test('Implementing a trait with all dependencies implemented') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('Integer')
    let trait1 = TraitType.new('Sub')
    let trait2 = TraitType
      .new(name: 'Add', required_traits: Array.new(TraitInstance.new(trait1)))

    module.define_constant(name: trait1.name, type: trait1)
    module.define_constant(name: trait2.name, type: trait2)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Sub for Integer {} impl Add for Integer {}')

    type_checker.check_module(module: module, ast: node)

    let implementation = obj_type.implemented_traits[trait2]

    assert.false(type_checker.diagnostics.errors?)
    assert.false(obj_type.implemented_traits.empty?)
    assert.equal(implementation.type.instance_of, trait2)
  }

  g.test('Implementing a trait that implements a required method incorrectly') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let plus = MethodType.new(
      name: '+',
      layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
    )

    plus.define_required_argument(
      name: 'a',
      type: type_checker.builtins.integer_type.new_instance
    )

    trait_type.required_methods.define(name: '+', type: plus)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer { def + {} }')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
  }

  g.test('Implementing a trait that provides default methods') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let plus = MethodType.new(name: '+', layout: BlockLayout.new(NeverType.new))

    trait_type.default_methods.define(name: '+', type: plus)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer {}')

    type_checker.check_module(module: module, ast: node)

    assert.same_object(obj_type.instance_methods['+'].type, plus)
  }

  g.test('Redefining a default method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let plus = MethodType.new(
      name: '+',
      layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
    )

    trait_type.default_methods.define(name: '+', type: plus)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer { def + {} }')

    type_checker.check_module(module: module, ast: node)

    let custom_plus = obj_type.instance_methods['+'].type

    assert.false(type_checker.diagnostics.errors?)
    assert.false(custom_plus.same_object?(plus))
  }

  g.test('Incorrectly redefining a default method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let plus = MethodType.new(
      name: '+',
      layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
    )

    trait_type.default_methods.define(name: '+', type: plus)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)
    module
      .define_constant(name: 'NilType', type: type_checker.builtins.nil_type)

    let node = parse('impl Add for Integer { def +(a: Integer) {} }')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
  }

  g.test('Implementing a trait that requires a method that is already implemented') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let trait_plus = MethodType.new(
      name: '+',
      layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
    )

    let obj_plus = MethodType.new(
      name: '+',
      layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
    )

    trait_type.required_methods.define(name: '+', type: trait_plus)
    obj_type.instance_methods.define(name: '+', type: obj_plus)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer { def + {} }')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
    assert.same_object(obj_type.instance_methods['+'].type, obj_plus)
  }

  g.test('Implementing a trait with a default method compatible with an existing method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let trait_plus =
      MethodType.new(name: '+', layout: BlockLayout.new(AnyType.new))

    let obj_plus =
      MethodType.new(name: '+', layout: BlockLayout.new(AnyType.new))

    trait_type.default_methods.define(name: '+', type: trait_plus)
    obj_type.instance_methods.define(name: '+', type: obj_plus)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer {}')

    type_checker.check_module(module: module, ast: node)

    assert.false(type_checker.diagnostics.errors?)
    assert.false(obj_type.implemented_traits.empty?)
    assert.same_object(obj_type.instance_methods['+'].type, obj_plus)
  }

  g.test('Implementing a trait with a default method incompatible with an existing method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let trait_plus =
      MethodType.new(name: '+', layout: BlockLayout.new(NeverType.new))

    let obj_plus =
      MethodType.new(name: '+', layout: BlockLayout.new(obj_type.new_instance))

    trait_type.default_methods.define(name: '+', type: trait_plus)
    obj_type.instance_methods.define(name: '+', type: obj_plus)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer {}')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(obj_type.implemented_traits.empty?)
    assert.same_object(obj_type.instance_methods['+'].type, obj_plus)
  }

  g.test('Defining a method with an argument depending on a required method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Bla')
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
    )

    trait_type.required_methods.define(name: foo.name, type: foo)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)
    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    let node = parse(
      'impl Add for Bla { def foo -> Integer { 10 } def bar(a = foo) {} }'
    )

    type_checker.check_module(module: module, ast: node)

    let bar = obj_type.instance_methods['bar'].type

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      bar.arguments['a'].type,
      type_checker.builtins.integer_type
    )
  }

  g.test('Defining a method with an argument depending on a default method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(type_checker.builtins.nil_singleton)
    )

    foo.return_type = type_checker.builtins.integer_type.new_instance

    trait_type.default_methods.define(name: 'foo', type: foo)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer { def bar(a = foo) {} }')

    type_checker.check_module(module: module, ast: node)

    let bar = obj_type.instance_methods['bar'].type

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(obj_type.instance_methods['foo'].type, foo)
    assert_object_instance(
      bar.arguments['a'].type,
      type_checker.builtins.integer_type
    )
  }

  g.test('Defining a method with an argument depending on the "self" type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(type_checker.builtins.nil_singleton)
    )

    foo.return_type = type_checker.builtins.integer_type.new_instance

    trait_type.default_methods.define(name: 'foo', type: foo)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer { def bar(a = self) {} }')

    type_checker.check_module(module: module, ast: node)

    let bar = obj_type.instance_methods['bar'].type

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(obj_type.instance_methods['foo'].type, foo)
    assert_object_instance(bar.arguments['a'].type, obj_type)
  }

  g.test('Redefining a static method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let obj_type = ClassType.new('Integer')
    let foo = MethodType.new(name: 'foo', static_method: True)

    obj_type.static_methods.define(name: 'foo', type: foo)

    module.define_constant(name: trait_type.name, type: trait_type)
    module.define_constant(name: obj_type.name, type: obj_type)

    let node = parse('impl Add for Integer { def foo {} }')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.same_object(obj_type.static_methods['foo'].type, foo)
    assert.true(obj_type.instance_methods.empty?)
    assert.true(obj_type.implemented_traits.empty?)
  }
}

test.group('Type-checking reopened types') do (g) {
  g.test('Reopening a non-existing type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let node = parse('impl A {}')

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Reopening a trait') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let trait_type = TraitType.new('Add')
    let node = parse('impl A {}')

    module.define_constant(name: trait_type.name, type: trait_type)

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Reopening the instance of an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('String')
    let node = parse('impl A {}')

    module.define_constant(name: 'A', type: obj_type.new_instance)

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Reopening a module') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let node = parse('impl A {}')

    module.define_constant(name: 'A', type: module)

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining an instance method when reopening an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let a_type = ClassType.new('A')
    let node = parse('impl A { def foo {} }')

    module.define_constant(name: a_type.name, type: a_type)

    type_checker.check_module(module: module, ast: node)

    assert.false(type_checker.diagnostics.errors?)
    assert.false(a_type.instance_methods.get('foo').none?)
  }

  g.test('Defining a static method when reopening an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let a_type = ClassType.new('A')
    let node = parse('impl A { static def foo {} }')

    module.define_constant(name: a_type.name, type: a_type)

    type_checker.check_module(module: module, ast: node)

    assert.false(type_checker.diagnostics.errors?)
    assert.false(a_type.static_methods.get('foo').none?)
  }

  g.test('Defining an existing instance method when reopening an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let a_type = ClassType.new('A')
    let foo_method = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(type_checker.builtins.nil_singleton)
    )

    let node = parse('impl A { def foo {} }')

    module.define_constant(name: a_type.name, type: a_type)
    a_type.instance_methods.define(name: foo_method.name, type: foo_method)

    type_checker.check_module(module: module, ast: node)

    assert.false(type_checker.diagnostics.errors?)
    assert.false(a_type.instance_methods['foo'].type.same_object?(foo_method))
  }

  g.test('Defining an existing static method when reopening an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let a_type = ClassType.new('A')
    let foo_method =
      MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

    let node = parse('impl A { static def foo {} }')

    module.define_constant(name: a_type.name, type: a_type)
    a_type.static_methods.define(name: foo_method.name, type: foo_method)

    type_checker.check_module(module: module, ast: node)

    assert.true(type_checker.diagnostics.errors?)
    assert.same_object(a_type.static_methods['foo'].type, foo_method)
  }
}

test.group('Type-checking identifier references') do (g) {
  g.test('Referring to an undefined identifier') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo')
    let node = body.children[0] as Identifier

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
    assert.true(node.symbol.none?)
  }

  g.test('Referring to a defined local variable') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo')
    let node = body.children[0] as Identifier

    body
      .variable_scope
      .symbols
      .define(name: 'foo', type: type_checker.builtins.integer_type.new_instance)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)

    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )

    assert.same_object(node.symbol.get.type, node.resolved_type.get)
  }

  g.test('Referring to an imported module') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo')
    let node = body.children[0] as Identifier

    module
      .globals
      .define(name: 'foo', type: type_checker.builtins.integer_type.new_instance)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)

    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )

    assert.same_object(node.symbol.get.type, node.resolved_type.get)
  }
}

test.group('Type-checking method calls without explicit receivers') do (g) {
  g.test('Sending a message to "self"') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo')
    let node = body.children[0] as Identifier
    let type = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
    )

    module.define_method(name: type.name, type: type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )

    assert_instance_of(node.symbol.get.type, MethodType)
  }

  g.test('Sending a message to "self" that throws an unhandled error') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo')
    let node = body.children[0] as Identifier
    let int_type = type_checker.builtins.integer_type
    let type = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: type.name, type: type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Sending a message to "self" with parentheses that throws an unhandled error') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo()')
    let node = body.children[0] as Identifier
    let int_type = type_checker.builtins.integer_type
    let type = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: type.name, type: type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Calling a defined module method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo')
    let node = body.children[0] as Identifier
    let type = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
    )

    module.define_method(name: type.name, type: type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Calling an imported module method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo')
    let node = body.children[0] as Identifier
    let type = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
    )

    module.globals.define(name: type.name, type: type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Calling a module method that returns Self in a generic type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo')
    let node = body.children[0] as Identifier
    let rtype =
      type_checker.builtins.array_type.new_instance(Array.new(SelfType.new))

    let method = MethodType.new(name: 'foo', layout: BlockLayout.new(rtype))

    module.define_method(name: method.name, type: method)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)

    let type = node.resolved_type.get as ClassInstance
    let param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    assert_object_instance(type, type_checker.builtins.array_type)
    assert.same_object(type.type_parameter_types[param], module)
  }
}

test.group('Type-checking global references using ::') do (g) {
  g.test('Referring to a global variable') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('::Foo')
    let node = body.children[0] as Global

    module.define_constant(
      name: 'Foo',
      type: type_checker.builtins.integer_type.new_instance
    )

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)

    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )

    assert.same_object(node.symbol.get.type, node.resolved_type.get)
  }

  g.test('Referring to an imported global variable') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('::foo')
    let node = body.children[0] as Global

    module
      .globals
      .define(name: 'foo', type: type_checker.builtins.integer_type.new_instance)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)

    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )

    assert.same_object(node.symbol.get.type, node.resolved_type.get)
  }

  g.test('Calling a module method with no arguments using ::') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('::foo')
    let node = body.children[0] as Global
    let type = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
    )

    module.define_method(name: type.name, type: type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Calling an imported module method with no arguments using ::') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('::foo')
    let node = body.children[0] as Global
    let type = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
    )

    module.globals.define(name: type.name, type: type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Calling an imported module method that throws an unhandled error') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('::foo')
    let layout = BlockLayout.new(
      return_type: int_type.new_instance,
      throw_type: Option.some(int_type.new_instance)
    )

    let type = MethodType.new(name: 'foo', layout: layout)

    module.globals.define(name: type.name, type: type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking constants defined by the compiler') do (g) {
  g.test('Referencing the ThisModule global') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('ThisModule')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, module)
  }
}

test.group('Type-checking variable reassignments') do (g) {
  g.test('Reassigning an existing local variable with the same type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo = 10')
    let node = body.children[0] as AssignLocal
    let int_type = type_checker.builtins.integer_type

    body
      .variable_scope
      .symbols
      .define(name: 'foo', type: int_type.new_instance, mutable: True)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Reassigning an existing attribute with the same type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('impl A { def foo(arg = @a = 10) {} }')

    let impl_node = body.children[0] as ReopenObject
    let meth_node = impl_node.body.children[0] as DefineMethod
    let arg_node = meth_node.arguments[0] as DefineOptionalArgument
    let assign_node = arg_node.default_value as AssignAttribute

    let obj_type = ClassType.new(name: 'A')
    let int_type = type_checker.builtins.integer_type

    let attr =
      obj_type.define_attribute(name: '@a', type: int_type.new_instance)

    module.define_constant(name: obj_type.name, type: obj_type)
    type_checker.check_module(module: module, ast: body)

    let method = obj_type.instance_methods['foo'].type

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(assign_node.symbol.get, attr)
    assert_object_instance(method.arguments['arg'].type, int_type)
  }

  g.test('Reassigning an existing local variable with a different compatible type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo = 10')
    let node = body.children[0] as AssignLocal
    let int_type = type_checker.builtins.integer_type
    let initial_type = AnyType.new

    let lvar = body
      .variable_scope
      .symbols
      .define(name: 'foo', type: initial_type, mutable: True)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(body.variable_scope.symbols['foo'].type, initial_type)
    assert.true(node.symbol.get.same_object?(lvar))
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Reassigning an existing local variable with an incompatible type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo = 10.5')
    let node = body.children[0] as AssignLocal
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type

    body
      .variable_scope
      .symbols
      .define(name: 'foo', type: int_type.new_instance, mutable: True)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)

    # The expression itself returns a Float, but the existing variable
    # definition is not altered.
    assert_object_instance(node.resolved_type.get, float_type)
    assert_object_instance(body.variable_scope.symbols['foo'].type, int_type)
  }

  g.test('Reassigning an immutable local variable') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo = 10')
    let node = body.children[0] as AssignLocal

    body
      .variable_scope
      .symbols
      .define(name: 'foo', type: type_checker.builtins.integer_type.new_instance)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Reassigning an undefined local variable') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo = 10')
    let node = body.children[0] as AssignLocal

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(body.variable_scope.symbols.get('foo').none?)
    assert.true(node.symbol.none?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Reassigning an undefined attribute') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('impl A { def foo(arg = @a = 10) {} }')

    let impl_node = body.children[0] as ReopenObject
    let meth_node = impl_node.body.children[0] as DefineMethod
    let arg_node = meth_node.arguments[0] as DefineOptionalArgument
    let assign_node = arg_node.default_value as AssignAttribute

    let obj_type = ClassType.new(name: 'A')
    let int_type = type_checker.builtins.integer_type

    module.define_constant(name: obj_type.name, obj_type)

    type_checker.check_module(module: module, ast: body)

    let method = obj_type.instance_methods['foo'].type

    assert.true(type_checker.diagnostics.errors?)
    assert.true(assign_node.symbol.none?)
    assert_object_instance(method.arguments['arg'].type, int_type)
  }
}

test.group('Type-checking attribute references') do (g) {
  g.test('Referring to a defined attribute') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('impl A { def foo(arg = @a) {} }')

    let impl_node = body.children[0] as ReopenObject
    let meth_node = impl_node.body.children[0] as DefineMethod
    let arg_node = meth_node.arguments[0] as DefineOptionalArgument
    let attr_node = arg_node.default_value as Attribute

    let obj_type = ClassType.new(name: 'A')
    let int_type = type_checker.builtins.integer_type

    let attr =
      obj_type.define_attribute(name: '@a', type: int_type.new_instance)

    module.define_constant(name: obj_type.name, obj_type)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(attr_node.symbol.get, attr)
    assert_object_instance(attr_node.resolved_type.get, int_type)
  }

  g.test('Referring to an undefined attribute') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('impl A { def foo(arg = @a) {} }')

    let impl_node = body.children[0] as ReopenObject
    let meth_node = impl_node.body.children[0] as DefineMethod
    let arg_node = meth_node.arguments[0] as DefineOptionalArgument
    let attr_node = arg_node.default_value as Attribute
    let obj_type = ClassType.new(name: 'A')

    module.define_constant(name: obj_type.name, obj_type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(attr_node.symbol.none?)
    assert.true(attr_node.resolved_type.get.error?)
  }

  g.test('Referring to a type parameter attribute') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('impl A { def foo { @a } }')
    let impl_node = body.children[0] as ReopenObject
    let meth_node = impl_node.body.children[0] as DefineMethod
    let attr_node = meth_node.body.children[0] as Attribute
    let obj_type = ClassType.new(name: 'A')
    let param = TypeParameterType.new('T')

    obj_type.type_parameters.define(name: param.name, type: param)
    obj_type.define_attribute(name: '@a', type: param)

    module.define_constant(name: obj_type.name, obj_type)
    type_checker.check_module(module: module, ast: body)

    let attr_type = attr_node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(attr_type, RigidTypeParameterType)
    assert.same_object((attr_type as RigidTypeParameterType).type, param)
  }
}

test.group('Type-checking method returns') do (g) {
  g.test('Returning at the module-level, without a value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('return')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Returning at the module-level, with a value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('return 10')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining an argument with a return as the default value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo(arg = return) {}')

    type_checker.check_module(module: module, ast: body)

    let method = body.children[0] as DefineMethod
    let arg = method.arguments[0]

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(arg.resolved_type.get, NeverType)
  }

  g.test('Returning from a method without a value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def foo { return }')
    let method_node = body.children[0] as DefineMethod
    let return_node = method_node.body.children[0] as Return

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(return_node.resolved_type.get, NeverType)
  }

  g.test('Returning from a method with a valid value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo -> Integer { return 10 }')
    let method_node = body.children[0] as DefineMethod
    let return_node = method_node.body.children[0] as Return

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(return_node.resolved_type.get, NeverType)
    assert_object_instance(
      return_node.expression.get.resolved_type.get,
      int_type
    )
  }

  g.test('Returning from a method with an invalid value') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo { return 10 }')
    let method_node = body.children[0] as DefineMethod
    let return_node = method_node.body.children[0] as Return

    type_checker.check_module(module: module, ast: body)

    let method_type = method_node.resolved_type.get

    assert.true(type_checker.diagnostics.errors?)
    assert_instance_of(return_node.resolved_type.get, NeverType)
    assert_object_instance(
      return_node.expression.get.resolved_type.get,
      int_type
    )
    assert_object_instance(
      method_type.return_type,
      type_checker.builtins.nil_type
    )
  }

  g.test('Returning from a closure') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('do { return }')

    type_checker.check_module(module: module, ast: body)

    let block = body.children[0].resolved_type.get as ClosureType

    assert.true(type_checker.diagnostics.errors?)
    assert.true(block.return_type.error?)
  }

  g.test('Returning from a lambda') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('fn { return 10 }')

    type_checker.check_module(module: module, ast: body)

    let block = body.children[0].resolved_type.get as LambdaType

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(block.return_type, int_type)
  }
}

test.group('Type-checking pattern-matching expressions') do (g) {
  g.test('Defining an empty match expression') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('match {}')
    let node = body.children[0] as Match

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Defining a match without any patterns') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('match(10) {}')
    let node = body.children[0] as Match

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Defining a match with only an "else" branch') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('match(10) { else -> { 10 } }')
    let node = body.children[0] as Match

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Defining a non-exhaustive match') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('match(10) { 10 -> { 10 } }')
    let node = body.children[0] as Match

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Defining a match when the Match trait does not exist') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('match(10) { 10 -> { 10 } else -> { 20 } }')
    let node = body.children[0] as Match

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Defining a match with an invalid expression case') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('match(10.5) { 10.5 -> { 10 } else -> { 20 } }')
    let node = body.children[0] as Match

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    # In this test, Integer does not implement std::operators::Match, and thus
    # can't be used in an expression case.
    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Defining a match with a valid expression case') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let module = new_module('foo')
    let body = parse('match(10) { 10 -> { 10 } else -> { 20 } }')
    let node = body.children[0] as Match
    let case = node.cases[0] as MatchExpressions

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(case.resolved_type.get, int_type)
    assert_object_instance(case.patterns[0].resolved_type.get, int_type)
    assert_object_instance(node.else_branch.get.resolved_type.get, int_type)

    assert.false(case.body.type_scope.none?)
    assert.false(node.else_branch.get.body.type_scope.none?)
  }

  g.test('Defining a match with an expression case with two patterns') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let module = new_module('foo')
    let body = parse('match(10) { 10, 20 -> { 10 } else -> { 20 } }')
    let node = body.children[0] as Match
    let case = node.cases[0] as MatchExpressions

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(case.resolved_type.get, int_type)
    assert_object_instance(case.patterns[0].resolved_type.get, int_type)
    assert_object_instance(case.patterns[1].resolved_type.get, int_type)
  }

  g.test('Defining a match with an expression guard') {
    let type_checker = TypeChecker.new
    let builtins = type_checker.builtins
    let module = new_module('foo')
    let body = parse('match(10) { 10 when True -> { 10 } else -> { 20 } }')

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match
    let case = node.cases[0] as MatchExpressions
    let pattern = case.patterns[0]

    assert.false(type_checker.diagnostics.errors?)

    assert_object_instance(pattern.resolved_type.get, builtins.integer_type)
    assert_object_instance(
      case.guard.get.resolved_type.get,
      builtins.boolean_type
    )
  }

  g.test('Defining a match with an invalid expression guard') {
    let type_checker = TypeChecker.new
    let builtins = type_checker.builtins
    let module = new_module('foo')
    let body = parse('match(10) { 10 when 20 -> { 10 } else -> { 20 } }')

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match
    let case = node.cases[0] as MatchExpressions

    # This test errors because guards must return a Boolean.
    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(
      case.guard.get.resolved_type.get,
      builtins.integer_type
    )
  }

  g.test('Defining a match with a type case') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('match(x) { as Integer -> { 10 } else -> { 20 } }')

    body
      .variable_scope
      .symbols
      .define(name: 'x', type: TraitInstance.new(TraitType.new('X')))

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match
    let case = node.cases[0] as MatchType

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(case.resolved_type.get, int_type)
    assert_object_instance(case.pattern.resolved_type.get, int_type)

    assert.false(case.body.type_scope.none?)
    assert.false(node.else_branch.get.body.type_scope.none?)
  }

  g.test('Defining a match with a type case and a valid guard') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let builtins = type_checker.builtins
    let int_type = builtins.integer_type
    let body =
      parse('match(x) { as Integer when True -> { 10 } else -> { 20 } }')

    body
      .variable_scope
      .symbols
      .define(name: 'x', type: TraitInstance.new(TraitType.new('X')))

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match
    let case = node.cases[0] as MatchType

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(case.resolved_type.get, int_type)
    assert_object_instance(
      case.guard.get.resolved_type.get,
      builtins.boolean_type
    )
    assert_object_instance(case.pattern.resolved_type.get, int_type)
  }

  g.test('Defining a match with a type case and an invalid guard') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let builtins = type_checker.builtins
    let int_type = builtins.integer_type
    let body = parse('match(x) { as Integer when 10 -> { 10 } else -> { 20 } }')

    body
      .variable_scope
      .symbols
      .define(name: 'x', type: TraitInstance.new(TraitType.new('X')))

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match
    let case = node.cases[0] as MatchType

    assert.true(type_checker.diagnostics.errors?)

    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(case.resolved_type.get, int_type)
    assert_object_instance(case.guard.get.resolved_type.get, int_type)
    assert_object_instance(case.pattern.resolved_type.get, int_type)
  }

  g.test('Defining a match where cases return different types') {
    let type_checker = TypeChecker.new
    let builtins = type_checker.builtins
    let module = new_module('foo')
    let body = parse('match(10) { 10 -> { 10.5 } else -> { 20 } }')

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match
    let case = node.cases[0] as MatchExpressions

    assert_instance_of(node.resolved_type.get, AnyType)
    assert_object_instance(case.resolved_type.get, builtins.float_type)
    assert_object_instance(
      node.else_branch.get.resolved_type.get,
      builtins.integer_type
    )
  }

  g.test('Defining a match without an argument with a Boolean expression case') {
    let type_checker = TypeChecker.new
    let builtins = type_checker.builtins
    let module = new_module('foo')
    let body = parse('match { True -> { 10 } else -> { 20 } }')

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match
    let case = node.cases[0] as MatchExpressions
    let patt = case.patterns[0]

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, builtins.integer_type)
    assert_object_instance(case.resolved_type.get, builtins.integer_type)
    assert_object_instance(patt.resolved_type.get, builtins.boolean_type)

    assert.false(case.body.type_scope.none?)
    assert.false(node.else_branch.get.body.type_scope.none?)
  }

  g.test('Defining a match without an argument with a non-Boolean expression case') {
    let type_checker = TypeChecker.new
    let builtins = type_checker.builtins
    let module = new_module('foo')
    let body = parse('match { 10 -> { 10 } else -> { 20 } }')

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match
    let case = node.cases[0] as MatchExpressions
    let patt = case.patterns[0]

    assert.true(type_checker.diagnostics.errors?)

    assert_object_instance(node.resolved_type.get, builtins.integer_type)
    assert_object_instance(case.resolved_type.get, builtins.integer_type)
    assert_object_instance(patt.resolved_type.get, builtins.integer_type)
  }

  g.test('Defining a match without an argument with a type case') {
    let type_checker = TypeChecker.new
    let builtins = type_checker.builtins
    let module = new_module('foo')
    let body = parse('match { as Integer -> { 10 } else -> { 20 } }')

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, builtins.integer_type)
  }

  g.test('Defining a match with a binding') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse(
      '
      match(let x = 10) {
        10 -> { x }
        as Integer -> { x }
        else -> { x }
      }
      '
    )

    setup_match_types(type_checker: type_checker, module: module)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.cases[0].resolved_type.get, int_type)
    assert_object_instance(node.cases[1].resolved_type.get, int_type)
    assert_object_instance(node.else_branch.get.resolved_type.get, int_type)
  }

  g.test('Defining a match with a type case matching a generic type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let ary_type = type_checker.builtins.array_type
    let trait_type = TraitType.new('Foo')
    let body = parse('match(x) { as Array -> {} else -> {} }')

    setup_match_types(type_checker: type_checker, module: module)
    module.define_constant(name: 'Array', type: ary_type)
    body.variable_scope.symbols.define(name: 'x', type: trait_type.new_instance)
    type_checker.check_module(module: module, ast: body)

    let node = body.children[0] as Match
    let case = node.cases[0] as MatchType

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(case.pattern.resolved_type.get, ary_type)
  }
}

test.group('Type-checking type casts') do (g) {
  g.test('Casting a type to an implemented trait') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let to_foo = TraitType.new('ToFoo')
    let module = new_module('foo')
    let body = parse('x as ToFoo')
    let node = body.children[0] as TypeCast

    int_type
      .add_trait_implementation(TraitImplementation.new(to_foo.new_instance))

    module.define_constant(name: 'ToFoo', type: to_foo)
    body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_trait_instance(node.resolved_type.get, to_foo)
  }

  g.test('Casting a type to an unimplemented trait') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let to_foo = TraitType.new('ToFoo')
    let module = new_module('foo')
    let body = parse('x as ToFoo')
    let node = body.children[0] as TypeCast

    module.define_constant(name: 'ToFoo', type: to_foo)
    body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_trait_instance(node.resolved_type.get, to_foo)
  }

  g.test('Casting a type to a non-existing type') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let module = new_module('foo')
    let body = parse('x as ToFoo')
    let node = body.children[0]

    body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Casting a trait to an object that implements the trait') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let to_foo = TraitType.new('ToFoo')
    let module = new_module('foo')
    let body = parse('x as Integer')
    let node = body.children[0] as TypeCast

    int_type
      .add_trait_implementation(TraitImplementation.new(to_foo.new_instance))

    module.define_constant(name: 'Integer', type: int_type)
    body.variable_scope.symbols.define(name: 'x', type: to_foo.new_instance)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test("Casting a trait to an object that doesn't implement the trait") {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let to_foo = TraitType.new('ToFoo')
    let module = new_module('foo')
    let body = parse('x as Integer')
    let node = body.children[0] as TypeCast

    module.define_constant(name: 'Integer', type: int_type)
    body.variable_scope.symbols.define(name: 'x', type: to_foo.new_instance)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Casting an error type to an object') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let module = new_module('foo')
    let body = parse('x as Integer')
    let node = body.children[0]

    module.define_constant(name: 'Integer', type: int_type)
    body.variable_scope.symbols.define(name: 'x', type: ErrorType.new)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Casting one object to another object') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let module = new_module('foo')
    let body = parse('x as Integer')
    let node = body.children[0]

    module.define_constant(name: 'Integer', type: int_type)
    body.variable_scope.symbols.define(name: 'x', type: float_type.new_instance)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Casting a type to a method type parameter') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('def foo!(A) { 10 as A }')
    let meth_node = body.children[0] as DefineMethod
    let node = meth_node.body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)

    let type = node.resolved_type.get
    let param = module.methods['foo'].type.lookup_type_parameter('A').get.type

    assert_instance_of(type, RigidTypeParameterType)
    assert.same_object((type as RigidTypeParameterType).type, param)
  }

  g.test('Casting a type to an class type parameter') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('class Foo!(A) { def foo { 10 as A } }')
    let obj_node = body.children[0] as DefineClass
    let meth_node = obj_node.body.children[0] as DefineMethod
    let node = meth_node.body.children[0]

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get
    let obj = module.constants['Foo'].type as ClassType
    let param = obj.lookup_type_parameter('A').get.type

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(type, RigidTypeParameterType)
    assert.same_object((type as RigidTypeParameterType).type, param)
  }
}

test.group('Type-checking closures') do (g) {
  g.test('Defining an empty basic closure') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('{}')
    let node = body.children[0] as BasicClosure

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert.true(type.arguments.empty?)
    assert.true(type.throw_type.none?)

    assert.false(node.body.type_scope.none?)
    assert.same_object(node.body.type_scope.get.block.get, type)

    assert_object_instance(type.return_type, type_checker.builtins.nil_type)
  }

  g.test('Defining a basic closure that captures a local variable') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let module = new_module('foo')
    let body = parse('{ x }')
    let node = body.children[0] as BasicClosure

    body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert.true(type.arguments.empty?)
    assert.true(type.throw_type.none?)
    assert.true(type.captures?)

    assert_object_instance(type.return_type, int_type)
    assert_object_instance(node.body.children[0].resolved_type.get, int_type)
  }

  g.test('Defining an empty closure without explicit types') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('do {}')
    let node = body.children[0] as Closure

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert.true(type.arguments.empty?)
    assert.true(type.throw_type.none?)

    assert.false(node.body.type_scope.none?)
    assert.same_object(node.body.type_scope.get.block.get, type)
    assert_object_instance(type.return_type, type_checker.builtins.nil_type)
  }

  g.test('Defining a closure without explicit types that captures a local variable') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let module = new_module('foo')
    let body = parse('do { x }')
    let node = body.children[0] as Closure

    body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert.true(type.arguments.empty?)
    assert.true(type.throw_type.none?)
    assert.true(type.captures?)

    assert_object_instance(type.return_type, int_type)
    assert_object_instance(node.body.children[0].resolved_type.get, int_type)
  }

  g.test('Defining a closure with typed arguments') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let body = parse("do (a: Float, b: Integer) { a \n b }")
    let node = body.children[0] as Closure

    module.define_constant(name: 'Integer', type: int_type)
    module.define_constant(name: 'Float', type: float_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert.equal(type.arguments.length, 2)
    assert.true(type.throw_type.none?)

    assert_object_instance(type.return_type, int_type)

    assert_object_instance(type.arguments['a'].type, float_type)
    assert_object_instance(type.arguments['b'].type, int_type)

    assert_object_instance(node.body.children[0].resolved_type.get, float_type)
    assert_object_instance(node.body.children[1].resolved_type.get, int_type)
  }

  g.test('Defining a closure with an explicit return type and a valid return value') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('do -> Integer { 10 }')
    let node = body.children[0] as Closure

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type.return_type, int_type)
  }

  g.test('Defining a closure with an explicit return type and an invalid return value') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('do -> Integer { 10.5 }')
    let node = body.children[0] as Closure

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(type.return_type, int_type)
  }

  g.test('Defining a closure with an explicit throw type and a valid thrown type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('do !! Integer { local throw 10 }')
    let node = body.children[0] as Closure

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type.throw_type.get, int_type)
  }

  g.test('Defining a closure with an explicit throw type and an invalid thrown type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('do !! Integer { local throw 10.5 }')
    let node = body.children[0] as Closure

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(type.throw_type.get, int_type)
  }

  g.test('Defining a closure with an explicit throw type that never throws') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('do !! Integer {}')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining a closure that throws without an explicit throw type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('do { local throw 10 }')
    let node = body.children[0] as Closure

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type.throw_type.get, int_type)
  }

  g.test('Defining a closure with a type parameter') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('do !(T)(a: T) { a }')
    let node = body.children[0] as Closure

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get
    let param = type.lookup_type_parameter('T').get.type

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(type.return_type, RigidTypeParameterType)
    assert.same_object((type.return_type as RigidTypeParameterType).type, param)
  }

  g.test('Defining a closure with a type parameter and explicit return type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('do !(T)(a: T) -> T { a }')
    let node = body.children[0] as Closure

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get
    let param = type.lookup_type_parameter('T').get.type

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(type.return_type, param)
  }

  g.test('Defining a closure with a type parameter and explicit throw type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('do !(T)(a: T) !! T { local throw a }')
    let node = body.children[0] as Closure

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get
    let param = type.lookup_type_parameter('T').get.type

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(type.throw_type.get, param)
  }

  g.test('Defining a closure with immutable untyped arguments') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('do (a, b) {}')
    let node = body.children[0] as Closure

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.true(type_checker.diagnostics.errors?)
    assert.true(type.arguments['a'].type.error?)
    assert.true(type.arguments['b'].type.error?)
  }

  g.test('Defining a closure with an optional argument') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let module = new_module('foo')
    let body = parse('do (a = 10) {}')
    let node = body.children[0] as Closure

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type.arguments['a'].type, int_type)
  }

  g.test('Defining a closure with a statically typed rest argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('do(*a: Integer) {}')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    let block = body.children[0].resolved_type.get as ClosureType
    let arg = block.arguments['a'].type as ClassInstance

    assert.false(type_checker.diagnostics.errors?)
    assert.true(block.rest_argument?)
    assert_object_instance(arg, type_checker.builtins.integer_type)
  }

  g.test('Referring to closure method argument in its body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('do(a: Integer) { a }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let method = body.children[0] as Closure
    let lvar = method.body.children[0] as Identifier

    assert_object_instance(lvar.resolved_type.get, int_type)
    assert.false(type_checker.diagnostics.errors?)
  }

  g.test('Referring to a closure rest argument in its body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let ary_type = type_checker.builtins.array_type
    let body = parse('do(*a: Integer) { a }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let method = body.children[0] as Closure
    let lvar = method.body.children[0] as Identifier

    let param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    let type = lvar.resolved_type.get

    assert_object_instance(type, ary_type)
    assert_object_instance(type.lookup_type_parameter_type(param).get, int_type)
    assert.false(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking lambdas') do (g) {
  g.test('Defining an empty lambda without explicit types') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('fn {}')
    let node = body.children[0] as Lambda

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert.true(type.arguments.empty?)
    assert.true(type.throw_type.none?)

    assert.false(node.body.type_scope.none?)
    assert.same_object(node.body.type_scope.get.block.get, type)

    assert_object_instance(type.return_type, type_checker.builtins.nil_type)
  }

  g.test('Defining a lambda that refers to a local variarble') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let module = new_module('foo')
    let body = parse('fn { x }')
    let node = body.children[0] as Lambda

    body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.true(type_checker.diagnostics.errors?)
    assert.true(type.arguments.empty?)
    assert.true(type.throw_type.none?)
    assert.true(type.return_type.error?)
  }

  g.test('Defining a lambda with typed arguments') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let body = parse("fn (a: Float, b: Integer) { a \n b }")
    let node = body.children[0] as Lambda

    module.define_constant(name: 'Integer', type: int_type)
    module.define_constant(name: 'Float', type: float_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert.equal(type.arguments.length, 2)
    assert.true(type.throw_type.none?)

    assert_object_instance(type.return_type, int_type)

    assert_object_instance(type.arguments['a'].type, float_type)
    assert_object_instance(type.arguments['b'].type, int_type)

    assert_object_instance(node.body.children[0].resolved_type.get, float_type)
    assert_object_instance(node.body.children[1].resolved_type.get, int_type)
  }

  g.test('Defining a lambda with an explicit return type and a valid return value') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('fn -> Integer { 10 }')
    let node = body.children[0] as Lambda

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type.return_type, int_type)
  }

  g.test('Defining a lambda with an explicit return type and an invalid return value') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('fn -> Integer { 10.5 }')
    let node = body.children[0] as Lambda

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(type.return_type, int_type)
  }

  g.test('Defining a lambda with an explicit throw type and a valid thrown type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('fn !! Integer { local throw 10 }')
    let node = body.children[0] as Lambda

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type.throw_type.get, int_type)
  }

  g.test('Defining a lambda with an explicit throw type and an invalid thrown type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('fn !! Integer { local throw 10.5 }')
    let node = body.children[0] as Lambda

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(type.throw_type.get, int_type)
  }

  g.test('Defining a lambda with an explicit throw type that never throws') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('fn !! Integer {}')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Defining a lambda that throws using `local throw` without an explicit throw type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('fn { local throw 10 }')
    let node = body.children[0] as Lambda

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type.throw_type.get, int_type)
  }

  g.test('Defining a lambda that throws without an explicit throw type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let int_type = type_checker.builtins.integer_type
    let body = parse('fn { throw 10 }')
    let node = body.children[0] as Lambda

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type.throw_type.get, int_type)
  }

  g.test('Defining a lambda with a type parameter') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('fn !(T)(a: T) { a }')
    let node = body.children[0] as Lambda

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get
    let param = type.lookup_type_parameter('T').get.type

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(type.return_type, RigidTypeParameterType)
    assert.same_object((type.return_type as RigidTypeParameterType).type, param)
  }

  g.test('Defining a lambda with a type parameter and explicit return type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('fn !(T)(a: T) -> T { a }')
    let node = body.children[0] as Lambda

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get
    let param = type.lookup_type_parameter('T').get.type

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(type.return_type, param)
  }

  g.test('Defining a lambda with a type parameter and explicit throw type') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('fn !(T)(a: T) !! T { local throw a }')
    let node = body.children[0] as Lambda

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get
    let param = type.lookup_type_parameter('T').get.type

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(type.throw_type.get, param)
  }

  g.test('Defining a lambda with immutable untyped arguments') {
    let type_checker = TypeChecker.new
    let module = new_module('foo')
    let body = parse('fn (a, b) {}')
    let node = body.children[0] as Lambda

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.true(type_checker.diagnostics.errors?)
    assert.true(type.arguments['a'].type.error?)
    assert.true(type.arguments['b'].type.error?)
  }

  g.test('Defining a lambda with an optional argument') {
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let module = new_module('foo')
    let body = parse('fn (a = 10) {}')
    let node = body.children[0] as Lambda

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type.arguments['a'].type, int_type)
  }

  g.test('Defining a lambda with a statically typed rest argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('fn(*a: Integer) {}')

    module
      .define_constant(name: 'Integer', type: type_checker.builtins.integer_type)

    type_checker.check_module(module: module, ast: body)

    let block = body.children[0].resolved_type.get as LambdaType
    let arg = block.arguments['a'].type as ClassInstance

    assert.false(type_checker.diagnostics.errors?)
    assert.true(block.rest_argument?)
    assert_object_instance(arg, type_checker.builtins.integer_type)
  }

  g.test('Referring to lambda method argument in its body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('fn(a: Integer) { a }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let method = body.children[0] as Lambda
    let lvar = method.body.children[0] as Identifier

    assert_object_instance(lvar.resolved_type.get, int_type)
    assert.false(type_checker.diagnostics.errors?)
  }

  g.test('Referring to a lambda rest argument in its body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let ary_type = type_checker.builtins.array_type
    let body = parse('fn(*a: Integer) { a }')

    module.define_constant(name: 'Integer', type: int_type)
    type_checker.check_module(module: module, ast: body)

    let method = body.children[0] as Lambda
    let lvar = method.body.children[0] as Identifier

    let param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    let type = lvar.resolved_type.get

    assert_object_instance(type, ary_type)
    assert_object_instance(type.lookup_type_parameter_type(param).get, int_type)
    assert.false(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking method throws') do (g) {
  g.test('Throwing at the module-level') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('throw 10')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking local throws') do (g) {
  g.test('Throwing at the module-level') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('local throw 10')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking yields') do (g) {
  g.test('Yielding at the module-level') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('yield 10')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking sending messages') do (g) {
  g.test('Not passing any arguments when none are required') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo()')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Not passing enough arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)
    foo.define_required_argument(name: 'b', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Passing too many arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Passing the correct number of arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing a keyword argument when no arguments are expected') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(foo: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Passing an undefined keyword argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(foo: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.arguments.define(name: 'bar', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing duplicate keyword arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(a: 10, a: 20)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)
    foo.arguments.define(name: 'b', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing duplicate undefined keyword arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(b: 10, b: 20)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.arguments.define(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)

    # Two errors: one because "b" does not exist, and one because "b" is
    # specified twice.
    assert.equal(type_checker.diagnostics.length, 2)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing a keyword argument and leaving out a required argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10, c: 20)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)
    foo.define_required_argument(name: 'b', type: int_type.new_instance)
    foo.define_required_argument(name: 'c', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Passing a valid keyword argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(a: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Not passing an optional argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.arguments.define(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing an optional argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.arguments.define(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing one optional argument when two are defined') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.arguments.define(name: 'a', type: int_type.new_instance)
    foo.arguments.define(name: 'b', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing an optional argument as a keyword argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(a: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.arguments.define(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing an optional keyword argument with a missing required argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(b: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)
    foo.arguments.define(name: 'b', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Passing two required out of order keyword arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(a: 10, c: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)
    foo.define_required_argument(name: 'b', type: int_type.new_instance)
    foo.define_required_argument(name: 'c', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Passing too many undefined keyword arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(a: 10, b: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Passing an argument of the wrong type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10.5)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing a keyword argument of the wrong type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(a: 10.5)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing too many arguments to a rest argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10, 20, 30)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_rest_argument(name: 'a', type: int_type.new_instance)
    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing too many incorrectly typed arguments to a rest argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10.5, 20.5, 30.5)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_rest_argument(name: 'a', type: int_type.new_instance)
    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.equal(type_checker.diagnostics.length, 3)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing a keyword argument to a rest argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(a: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_rest_argument(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Passing a keyword argument with an incorrect type to a rest argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(a: 10.5)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_rest_argument(name: 'a', type: int_type.new_instance)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Assigning a method type parameter using a positional argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let param = TypeParameterType.new('T')
    let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

    foo.type_parameters.define(name: 'T', type: param)
    foo.define_required_argument(name: 'a', type: param)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Assigning a method type parameter using a keyword argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(a: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let param = TypeParameterType.new('T')
    let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

    foo.type_parameters.define(name: 'T', type: param)
    foo.define_required_argument(name: 'a', type: param)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Assigning a receiver type parameter using a positional argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('rec.push(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let ary_type = type_checker.builtins.array_type
    let ary_param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))

    push.define_required_argument(name: 'val', type: ary_param)
    ary_type.instance_methods.define(name: push.name, type: push)

    let rec = ary_type.new_instance

    body.variable_scope.symbols.define(name: 'rec', type: rec)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(
      rec.lookup_type_parameter_type(ary_param).get,
      int_type
    )
  }

  g.test('Assigning a receiver type parameter using a keyword argument') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('rec.push(val: 10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let ary_type = type_checker.builtins.array_type
    let ary_param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))

    push.define_required_argument(name: 'val', type: ary_param)
    ary_type.instance_methods.define(name: push.name, type: push)

    let rec = ary_type.new_instance

    body.variable_scope.symbols.define(name: 'rec', type: rec)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(
      rec.lookup_type_parameter_type(ary_param).get,
      int_type
    )
  }

  g.test('Returning a generic type containing a method type parameter') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let ary_type = type_checker.builtins.array_type
    let param = TypeParameterType.new('T')
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(ary_type.new_instance(Array.new(param)))
    )

    foo.type_parameters.define(name: 'T', type: param)
    foo.define_required_argument(name: 'a', type: param)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get
    let ary_param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, ary_type)
    assert_object_instance(
      type.lookup_type_parameter_type(ary_param).get,
      int_type
    )
  }

  g.test('Returning a Self type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('self.foo')
    let node = body.children[0] as Send
    let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(SelfType.new))

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, module)
  }

  g.test('Returning a generic type containing a Self type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('self.foo')
    let node = body.children[0] as Send
    let ary_type = type_checker.builtins.array_type
    let param = TypeParameterType.new('T')

    ary_type.type_parameters.define(name: 'T', type: param)

    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(ary_type.new_instance(Array.new(SelfType.new))),
    )

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, ary_type)
    assert.same_object(type.lookup_type_parameter_type(param).get, module)
  }

  g.test('Method type parameters are not assigned in the receiver type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('rec.push(10, 20)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let ary_type = type_checker.builtins.array_type
    let ary_param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))
    let b_param = TypeParameterType.new('B')

    push.type_parameters.define(name: b_param.name, type: b_param)
    push.define_required_argument(name: 'val', type: ary_param)
    push.define_required_argument(name: 'foo', type: b_param)

    ary_type.instance_methods.define(name: push.name, type: push)

    let rec = ary_type.new_instance

    body.variable_scope.symbols.define(name: 'rec', type: rec)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(
      rec.lookup_type_parameter_type(ary_param).get,
      int_type
    )
    assert.true(rec.lookup_type_parameter_type(b_param).none?)
  }

  g.test('Assigning a method type parameter using a closure') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let builtins = type_checker.builtins
    let body = parse('foo { 10 }')
    let node = body.children[0] as Send
    let param = TypeParameterType.new('R')
    let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

    foo.type_parameters.define(name: param.name, type: param)
    foo
      .define_required_argument('block', ClosureType.new(BlockLayout.new(param)))

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, builtins.integer_type)
  }

  g.test('Assigning a method type parameter using a lambda') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let builtins = type_checker.builtins
    let body = parse('foo fn { 10 }')
    let node = body.children[0] as Send
    let param = TypeParameterType.new('R')
    let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

    foo.type_parameters.define(name: param.name, type: param)
    foo
      .define_required_argument('block', LambdaType.new(BlockLayout.new(param)))

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, builtins.integer_type)
  }

  g.test('Assigning a method type parameter using an object') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('foo(a)')
    let node = body.children[0] as Send
    let list_type = ClassType.new('List')
    let list_param = TypeParameterType.new('T')

    list_type.type_parameters.define(name: list_param.name, type: list_param)

    let param = TypeParameterType.new('R')
    let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

    foo.type_parameters.define(name: param.name, type: param)
    foo.define_required_argument(
      'list',
      list_type.new_instance(Array.new(param))
    )

    body.variable_scope.symbols.define(
      name: 'a',
      type: list_type.new_instance(Array.new(int_type.new_instance))
    )

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Assigning a method type parameter using a trait') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('foo(a)')
    let node = body.children[0] as Send
    let to_list_type = TraitType.new('ToList')
    let to_list_param = TypeParameterType.new('T')

    to_list_type
      .type_parameters
      .define(name: to_list_param.name, type: to_list_param)

    # def foo!(R)(list: ToList!(R)) -> R
    let param = TypeParameterType.new('R')
    let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

    foo.type_parameters.define(name: param.name, type: param)
    foo.define_required_argument(
      'list',
      to_list_type.new_instance(Array.new(param))
    )

    body.variable_scope.symbols.define(
      name: 'a',
      type: to_list_type.new_instance(Array.new(int_type.new_instance))
    )

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Sending an identifier message of which the error type is Never') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('foo')
    let node = body.children[0]
    let layout = BlockLayout.new(
      return_type: int_type.new_instance,
      throw_type: Option.some(NeverType.new)
    )

    let foo = MethodType.new(name: 'foo', layout: layout)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Sending a message of which the error type is Never') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('foo()')
    let node = body.children[0]
    let layout = BlockLayout.new(
      return_type: int_type.new_instance,
      throw_type: Option.some(NeverType.new)
    )

    let foo = MethodType.new(name: 'foo', layout: layout)

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Sending a message defined in the Object trait while in a trait instance') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('trait A { def foo { bar } }')

    let bootstrap = ModuleType.new(BOOTSTRAP_MODULE)
    let object_trait = TraitType.new(OBJECT_TRAIT)
    let bar = MethodType.new(name: 'bar', layout: BlockLayout.new(AnyType.new))

    bootstrap.constants.define(name: object_trait.name, type: object_trait)
    object_trait.default_methods.define(name: bar.name, type: bar)
    type_checker.add_module(bootstrap)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
  }

  g.test('Sending a message to a type parameter that responds to the message') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let str_type = type_checker.builtins.string_type
    let to_string_trait = TraitType.new('ToString')
    let to_string = MethodType
      .new(name: 'to_string', layout: BlockLayout.new(str_type.new_instance))

    to_string_trait
      .default_methods
      .define(name: to_string.name, type: to_string)

    let param = TypeParameterType
      .new(name: 'T', required_traits: Array.new(to_string_trait.new_instance))

    let body = parse('a.to_string')
    let node = body.children[0]

    body.variable_scope.symbols.define(name: 'a', type: param)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, str_type)
  }

  g.test('Sending an undefined message to a type parameter') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let param = TypeParameterType.new('T')
    let body = parse('a.test')
    let node = body.children[0]

    body.variable_scope.symbols.define(name: 'a', type: param)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }
}

test.group('Type-checking sending messages with method bounds') do (g) {
  g.test('Sending a message that is not available') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('rec.push(10)')
    let node = body.children[0] as Send
    let bla_type = TraitType.new('Bla')
    let ary_type = type_checker.builtins.array_type
    let ary_param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    # This defines the method as `def push(val: T) when T: Bla`
    let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))

    push.define_required_argument(name: 'val', type: ary_param)

    push.type_parameter_bounds.define(
      parameter: ary_param,
      requirements: Array.new(bla_type.new_instance)
    )

    ary_type.instance_methods.define(name: push.name, type: push)

    let rec = ary_type.new_instance

    body.variable_scope.symbols.define(name: 'rec', type: rec)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Sending a message that is available') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('rec.push(10)')
    let node = body.children[0] as Send
    let bla_type = TraitType.new('Bla')
    let int_type = type_checker.builtins.integer_type
    let ary_type = type_checker.builtins.array_type
    let ary_param = type_checker
      .builtins
      .array_type
      .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
      .get
      .type

    int_type
      .add_trait_implementation(TraitImplementation.new(bla_type.new_instance))

    # This defines the method as `def push(val: T) when T: Bla`
    let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))

    push.define_required_argument(name: 'val', type: ary_param)

    push.type_parameter_bounds.define(
      parameter: ary_param,
      requirements: Array.new(bla_type.new_instance)
    )

    ary_type.instance_methods.define(name: push.name, type: push)

    let rec = ary_type.new_instance

    body.variable_scope.symbols.define(name: 'rec', type: rec)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }
}

test.group('Type-checking sending "call" to blocks') do (g) {
  g.test('Sending the "call" message to a closure') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo.call(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo = ClosureType.new(BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)

    body.variable_scope.symbols.define(name: 'foo', type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Sending the "call" message to a lambda') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo.call(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo = LambdaType.new(BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)

    body.variable_scope.symbols.define(name: 'foo', type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Sending the "call" message to a method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo.call(10)')
    let node = body.children[0] as Send
    let int_type = type_checker.builtins.integer_type
    let foo =
      MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)

    body.variable_scope.symbols.define(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Sending the "call" message when it may throw an unhandled error') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('foo.call')
    let int_type = type_checker.builtins.integer_type
    let foo = ClosureType.new(
      BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    body.variable_scope.symbols.define(name: 'foo', type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking imported methods') do (g) {
  g.test('Calling an imported method without arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('foo')
    let node = body.children[0]
    let foo = MethodType
      .new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    module.globals.define(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Calling an imported method with arguments') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('foo(10)')
    let node = body.children[0]
    let foo = MethodType
      .new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

    foo.define_required_argument(name: 'a', type: int_type.new_instance)
    module.globals.define(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }
}

test.group('Type-checking the `local try` keyword') do (g) {
  g.test('Re-throwing outside of a block using an identifier') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('local try foo')
    let node = body.children[0] as Try
    let ident = node.expression as Identifier
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_throw_type.get, float_type)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(ident.resolved_throw_type.get, float_type)
  }

  g.test('Re-throwing outside of a block using a message send') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('local try foo()')
    let node = body.children[0] as Try
    let send = node.expression as Send
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(send.resolved_throw_type.get, float_type)
  }

  g.test("Re-throwing an error with an expression that doesn't throw") {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('{ local try 10 }')
    let block = body.children[0] as BasicClosure
    let node = block.body.children[0] as Try

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_throw_type.get.error?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test("Handling an error with an expression that doesn't throw") {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('{ local try 10 else 20 }')
    let block = body.children[0] as BasicClosure
    let node = block.body.children[0] as Try

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Re-throwing an incompatible error type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('do !! Integer { local try foo }')
    let block = body.children[0] as Closure
    let node = block.body.children[0] as Try
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_constant(name: int_type.name, type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Handling an error thrown by a method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('{ local try foo else 10 }')
    let block = body.children[0] as BasicClosure
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_constant(name: int_type.name, type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Re-throwing an error in a basic closure that has no explicit error type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('{ local try foo }')
    let block = body.children[0] as BasicClosure
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(block.resolved_type.get.throw_type.get, int_type)
  }

  g.test('Re-throwing an error in a closure that has no explicit error type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('do { local try foo }')
    let block = body.children[0] as Closure
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(block.resolved_type.get.throw_type.get, int_type)
  }

  g.test('Re-throwing an error in a lambda using `local try` that has no explicit error type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('fn { local try foo }')
    let block = body.children[0] as Lambda
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(block.resolved_type.get.throw_type.get, int_type)
  }

  g.test('Re-throwing an error in a lambda that has no explicit error type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('fn { try foo }')
    let block = body.children[0] as Lambda
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(block.resolved_type.get.throw_type.get, int_type)
  }

  g.test('Handling an error with an incompatible else type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('{ local try foo else 10.5 }')
    let block = body.children[0] as BasicClosure
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_constant(name: int_type.name, type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Defining a local variable in the else body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('{ local try foo else { let a = 10 } }')
    let block = body.children[0] as BasicClosure
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    let else_vars = node.else_body.variable_scope

    assert.true(body.variable_scope.lookup('a').none?)
    assert.true(block.body.variable_scope.lookup('a').none?)

    assert_object_instance(else_vars.lookup('a').get.type, int_type)
    assert.true(else_vars.parent.get.same_object?(block.body.variable_scope))
  }

  g.test('Defining a variable to store the thrown error in') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('{ local try foo else (error) error }')
    let block = body.children[0] as BasicClosure
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert_object_instance(
      node.else_body.variable_scope.lookup('error').get.type,
      int_type
    )
  }

  g.test('Using a method that throws in a closure inside a `local try`') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('{ local try foo({ bar }) }')
    let int_type = type_checker.builtins.integer_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    let val_type = ClosureType.new(
      BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    foo.define_required_argument(name: 'val', type: val_type)

    let bar = MethodType.new(
      name: 'bar',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_method(name: bar.name, type: bar)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(type_checker.diagnostics.length, 1)
  }

  g.test('Passing a called closure that throws as an argument in a `local try`') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('{ local try foo({ local try bar }.call) }')
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    foo.define_required_argument(name: 'val', type: int_type.new_instance)

    let bar = MethodType.new(
      name: 'bar',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_method(name: bar.name, type: bar)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(type_checker.diagnostics.length, 1)
  }
}

test.group('Type-checking the `try` keyword') do (g) {
  g.test('Re-throwing outside of a block using an identifier') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('try foo')
    let node = body.children[0] as Try
    let ident = node.expression as Identifier
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_throw_type.get, float_type)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(ident.resolved_throw_type.get, float_type)
  }

  g.test('Re-throwing outside of a block using a message send') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('try foo()')
    let node = body.children[0] as Try
    let send = node.expression as Send
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
    assert_object_instance(send.resolved_throw_type.get, float_type)
  }

  g.test("Re-throwing an error with an expression that doesn't throw") {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bar { try 10 }')
    let block = body.children[0] as DefineMethod
    let node = block.body.children[0] as Try

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_throw_type.get.error?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test("Handling an error with an expression that doesn't throw") {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bar { try 10 else 20 }')
    let block = body.children[0] as DefineMethod
    let node = block.body.children[0] as Try

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Re-throwing an error in a method that has no explicit error type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bar { try foo }')
    let block = body.children[0] as DefineMethod
    let node = block.body.children[0] as Try
    let int_type = type_checker.builtins.integer_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Re-throwing an incompatible error type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bar !! Integer { try foo }')
    let block = body.children[0] as DefineMethod
    let node = block.body.children[0] as Try
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_constant(name: int_type.name, type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Handling an error thrown by a method') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bar { try foo else 10 }')
    let block = body.children[0] as DefineMethod
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_constant(name: int_type.name, type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Handling an error with an incompatible else type') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bar { try foo else 10.5 }')
    let block = body.children[0] as DefineMethod
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_constant(name: int_type.name, type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Defining a local variable in the else body') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bar { try foo else { let a = 10 } }')
    let block = body.children[0] as DefineMethod
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    let else_vars = node.else_body.variable_scope

    assert.true(body.variable_scope.lookup('a').none?)
    assert.true(block.body.variable_scope.lookup('a').none?)

    assert_object_instance(else_vars.lookup('a').get.type, int_type)
    assert.true(else_vars.parent.get.same_object?(block.body.variable_scope))
  }

  g.test('Defining a variable to store the thrown error in') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bar { try foo else (error) error }')
    let block = body.children[0] as DefineMethod
    let node = block.body.children[0] as Try

    let int_type = type_checker.builtins.integer_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)

    type_checker.check_module(module: module, ast: body)

    assert_object_instance(
      node.else_body.variable_scope.lookup('error').get.type,
      int_type
    )
  }

  g.test('Using a method that throws in a closure inside a `try`') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bla !! Integer { try foo({ bar }) }')
    let int_type = type_checker.builtins.integer_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    let val_type = ClosureType.new(
      BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    foo.define_required_argument(name: 'val', type: val_type)

    let bar = MethodType.new(
      name: 'bar',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_method(name: bar.name, type: bar)
    module.define_constant(name: int_type.name, type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(type_checker.diagnostics.length, 1)
  }

  g.test('Passing a called closure that throws as an argument in a `try`') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('def bla !! Integer { try foo({ local try bar }.call) }')
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )
    )

    foo.define_required_argument(name: 'val', type: int_type.new_instance)

    let bar = MethodType.new(
      name: 'bar',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    module.define_method(name: bar.name, type: bar)
    module.define_constant(name: int_type.name, type: int_type)

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.equal(type_checker.diagnostics.length, 1)
  }
}

test.group('Type-checking the `try!` keyword') do (g) {
  g.test("Handling an error with an expression that doesn't throw") {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('try! 10')
    let node = body.children[0] as TryPanic

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_throw_type.get.error?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Handling an error with an expression that throws') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('try! foo')
    let node = body.children[0] as TryPanic
    let int_type = type_checker.builtins.integer_type
    let float_type = type_checker.builtins.float_type
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(float_type.new_instance)
      )
    )

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_throw_type.get, float_type)
    assert_object_instance(node.resolved_type.get, int_type)
  }
}

test.group('Type-checking an unknown instruction') do (g) {
  g.test('Unknown instructions produce a compiler error') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('_INKOC.foo')
    let node = body.children[0]

    module.define_constant(name: int_type.name, type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(node.resolved_type.get.error?)
    assert.true(type_checker.diagnostics.errors?)
  }
}

test.group('Type-checking VM instructions') do (g) {
  g.test('VM instructions can only be used in the standard library') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_attribute')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }

  g.test('Using get_true()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_true')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.true_singleton
    )
  }

  g.test('Using get_false()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_false')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.false_singleton
    )
  }

  g.test('Using set_attribute()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.set_attribute')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using get_attribute()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('_INKOC.get_attribute(a, "foo")')
    let node = body.children[0]
    let foo_type = ClassType.new('Foo')

    body.variable_scope.symbols.define(name: 'a', type: foo_type.new_instance)
    module.define_constant(name: int_type.name, type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using object_equals()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.object_equals(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using copy_blocks()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.copy_blocks(foo, bar)')
    let node = body.children[0]
    let foo_type = ClassType.new('Foo')
    let bar_type = ClassType.new('Bar')

    body.variable_scope.symbols.define(name: 'foo', type: foo_type)
    body.variable_scope.symbols.define(name: 'bar', type: bar_type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, NeverType)
  }

  g.test('Using integer_add()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_add(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_div()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_div(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_mul()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_mul(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_sub()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_sub(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_mod()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_mod(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_bitwise_and()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_bitwise_and(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_bitwise_or()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_bitwise_or(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_bitwise_xor()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_bitwise_xor(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_shift_left()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_shift_left(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_shift_right()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_shift_right(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using integer_smaller()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_smaller(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using integer_greater()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_greater(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using integer_equals()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_equals(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using integer_greater_or_equal()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_greater_or_equal(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using integer_smaller_or_equal()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.integer_smaller_or_equal(10, 10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using float_add()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_add(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.float_type
    )
  }

  g.test('Using float_div()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_div(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.float_type
    )
  }

  g.test('Using float_mul()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_mul(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.float_type
    )
  }

  g.test('Using float_sub()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_sub(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.float_type
    )
  }

  g.test('Using float_mod()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_mod(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.float_type
    )
  }

  g.test('Using float_smaller()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_smaller(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using float_greater()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_greater(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using float_equals()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_equals(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using float_greater_or_equal()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_greater_or_equal(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using float_smaller_or_equal()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.float_smaller_or_equal(10.5, 10.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using get_nil()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_nil')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.nil_singleton
    )
  }

  g.test('Using get_nil_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_nil_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.nil_type)
  }

  g.test('Using get_module_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_module_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.module_type)
  }

  g.test('Using get_string_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_string_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.string_type)
  }

  g.test('Using get_integer_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_integer_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.integer_type)
  }

  g.test('Using get_float_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_float_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.float_type)
  }

  g.test('Using get_trait_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_trait_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.trait_type)
  }

  g.test('Using get_hasher_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_hasher_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.hasher_type)
  }

  g.test('Using get_array_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_array_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.array_type)
  }

  g.test('Using get_block_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_block_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.block_type)
  }

  g.test('Using run_block()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.run_block(block)')
    let node = body.children[0]
    let block = ClosureType
      .new(BlockLayout.new(type_checker.builtins.integer_type.new_instance))

    body.variable_scope.symbols.define(name: 'block', type: block)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using array_length()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.array_length(array)')
    let node = body.children[0]
    let array = type_checker.builtins.array_type.new_instance

    body.variable_scope.symbols.define(name: 'array', type: array)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using array_at()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.array_at')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using array_set()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.array_set')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using array_remove()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.array_remove')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using string_size()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.string_size("foo")')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using string_length()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.string_length("foo")')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using string_equals()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.string_equals("foo", "foo")')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using string_concat()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.string_concat("foo", "foo")')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.string_type
    )
  }

  g.test('Using string_byte()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.string_byte("foo", 0)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using process_spawn()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_spawn({})')
    let node = body.children[0]
    let proc_type = type_checker.builtins.process_type

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, proc_type)
  }

  g.test('Using process_send_message()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_send_message')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using process_receive_message()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_receive_message')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using process_current()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_current')
    let node = body.children[0]
    let proc_type = type_checker.builtins.process_type

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, proc_type)
  }

  g.test('Using process_suspend_current()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_suspend_current')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, NeverType)
  }

  g.test('Using process_terminate_current()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_terminate_current')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, NeverType)
  }

  g.test('Using get_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using close()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.close(10)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, NeverType)
  }

  g.test('Using process_set_blocking()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_set_blocking')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using process_panic()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.panic("foo")')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, NeverType)
  }

  g.test('Using exit()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.exit')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, NeverType)
  }

  g.test('Using byte_array_from_array()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.byte_array_from_array')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.byte_array_type
    )
  }

  g.test('Using byte_array_set()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.byte_array_set')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using byte_array_at()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.byte_array_at')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using byte_array_remove()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.byte_array_remove')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using byte_array_length()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.byte_array_length')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using byte_array_equals()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.byte_array_equals')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using byte_array_to_string()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.byte_array_to_string')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.string_type
    )
  }

  g.test('Using get_boolean_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_boolean_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.boolean_type)
  }

  g.test('Using get_byte_array_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_byte_array_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.byte_array_type
    )
  }

  g.test('Using get_ffi_library_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_ffi_library_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.ffi_library_type
    )
  }

  g.test('Using get_ffi_function_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_ffi_function_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.ffi_function_type
    )
  }

  g.test('Using get_ffi_pointer_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_ffi_pointer_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.ffi_pointer_type
    )
  }

  g.test('Using get_ip_socket_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_ip_socket_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.ip_socket_type
    )
  }

  g.test('Using get_unix_socket_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_unix_socket_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.unix_socket_type
    )
  }

  g.test('Using get_process_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_process_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(node.resolved_type.get, type_checker.builtins.process_type)
  }

  g.test('Using get_read_only_file_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_read_only_file_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.read_only_file_type
    )
  }

  g.test('Using get_write_only_file_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_write_only_file_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.write_only_file_type
    )
  }

  g.test('Using get_read_write_file_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_read_write_file_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.read_write_file_type
    )
  }

  g.test('Using generator_prototype()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.get_generator_prototype')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert.same_object(
      node.resolved_type.get,
      type_checker.builtins.generator_type
    )
  }

  g.test('Using set_object_name()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.set_object_name')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.string_type
    )
  }

  g.test('Using process_set_panic_handler()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_set_panic_handler')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using process_add_defer_to_caller()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_add_defer_to_caller')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using set_default_panic_handler()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.set_default_panic_handler')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using process_set_pinned()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_set_pinned')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }

  g.test('Using process_identifier()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.process_identifier')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.integer_type
    )
  }

  g.test('Using if()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.if(1, "foo", 20.5)')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.string_type
    )
  }

  g.test('Using module_load()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.module_load')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.module_type
    )
  }

  g.test('Using module_get()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.module_get')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, type_checker.builtins.module_type)
  }

  g.test('Using generator_resume()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.generator_resume')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, NeverType)
  }

  g.test('Using generator_value()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.generator_value')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_instance_of(node.resolved_type.get, AnyType)
  }

  g.test('Using generator_yielded()') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('_INKOC.generator_yielded')
    let node = body.children[0]

    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(
      node.resolved_type.get,
      type_checker.builtins.boolean_type
    )
  }
}

test.group('Type-checking object constructors') do (g) {
  g.test('Creating an instance without attributes') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('A')
    let body = parse('A {}')
    let node = body.children[0]

    module.globals.define(name: 'A', obj_type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, obj_type)
  }

  g.test('Creating an instance with attributes') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('A')
    let builtins = type_checker.builtins
    let int_type = builtins.integer_type
    let str_type = builtins.string_type

    obj_type.define_attribute(name: '@a', type: int_type.new_instance)
    obj_type.define_attribute(name: '@b', type: str_type.new_instance)

    let body = parse('A { @a = 10, @b = "foo" }')
    let node = body.children[0] as Constructor

    module.globals.define(name: 'A', obj_type)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, obj_type)

    assert_object_instance(node.attributes[0].resolved_type.get, int_type)
    assert_object_instance(node.attributes[1].resolved_type.get, str_type)
  }

  g.test('Creating an instance without setting all attributes') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('A')
    let builtins = type_checker.builtins

    obj_type
      .define_attribute(name: '@a', type: builtins.integer_type.new_instance)

    obj_type
      .define_attribute(name: '@b', type: builtins.string_type.new_instance)

    let body = parse('A { @a = 10 }')
    let node = body.children[0]

    module.globals.define(name: 'A', obj_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, obj_type)
  }

  g.test('Creating an instance while setting the same attribute twice') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('A')
    let builtins = type_checker.builtins

    obj_type
      .define_attribute(name: '@a', type: builtins.integer_type.new_instance)

    let body = parse('A { @a = 10, @a = 20 }')
    let node = body.children[0]

    module.globals.define(name: 'A', obj_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, obj_type)
  }

  g.test('Creating an instance while setting an undefined attribute') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('A')
    let body = parse('A { @a = 10 }')
    let node = body.children[0]

    module.globals.define(name: 'A', obj_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, obj_type)
  }

  g.test('Creating an instance with a generic attribute') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('A')
    let int_type = type_checker.builtins.integer_type
    let param = TypeParameterType.new('T')

    obj_type.define_attribute(name: '@a', type: param)

    let body = parse('A { @a = 10 }')
    let node = body.children[0]

    module.globals.define(name: 'A', obj_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, obj_type)
    assert_object_instance(type.lookup_type_parameter_type(param).get, int_type)
  }

  g.test('Creating an instance using a Self type in a module method') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let obj_type = ClassType.new('A')
    let body = parse('def foo { Self {} }')

    module.globals.define(name: 'A', obj_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Creating an instance using a Self type in an instance method') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class A { def foo { Self {} } }')

    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
  }

  g.test('Creating an instance using a Self type in a static method') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let body = parse('class A { static def foo { Self {} } }')
    let object_node = body.children[0] as DefineClass
    let method_node = object_node.body.children[0] as DefineMethod
    let node = method_node.body.children[0]

    type_checker.check_module(module: module, ast: body)

    let obj_type = module.constants['A'].type as ClassType

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, obj_type)
  }

  g.test('Creating an instance of a built-in type') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let byte_array = type_checker.builtins.byte_array_type
    let body = parse('ByteArray {}')
    let node = body.children[0]

    module.globals.define(name: byte_array.name, type: byte_array)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }
}

test.group('Type-checking generators') do (g) {
  g.test('Creating a generator without parentheses') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let gen_type = type_checker.builtins.generator_type
    let body = parse(
      'def gen => Integer { yield 10 }
      gen'
    )
    let node = body.children[1] as Identifier

    module.globals.define(name: 'Integer', int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, gen_type)

    let vparam =
      type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

    let eparam =
      type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

    assert_object_instance(type.lookup_type_parameter_type(vparam).get, int_type)
    assert_instance_of(type.lookup_type_parameter_type(eparam).get, NeverType)
  }

  g.test('Creating a generator using parentheses') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let gen_type = type_checker.builtins.generator_type
    let body = parse(
      'def gen => Integer { yield 10 }
      gen()'
    )
    let node = body.children[1] as Send

    module.globals.define(name: 'Integer', int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, gen_type)

    let vparam =
      type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

    let eparam =
      type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

    assert_object_instance(type.lookup_type_parameter_type(vparam).get, int_type)
    assert_instance_of(type.lookup_type_parameter_type(eparam).get, NeverType)
  }

  g.test('Creating a generator that throws without parentheses') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let gen_type = type_checker.builtins.generator_type
    let body = parse(
      'def gen !! Integer => Integer {
        yield 10
        throw 20
      }
      gen'
    )
    let node = body.children[1] as Identifier

    module.globals.define(name: 'Integer', int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, gen_type)
    assert.true(node.resolved_throw_type.none?)

    let vparam =
      type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

    let eparam =
      type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

    assert_object_instance(type.lookup_type_parameter_type(vparam).get, int_type)
    assert_object_instance(type.lookup_type_parameter_type(eparam).get, int_type)
  }

  g.test('Creating a generator that throws with parentheses') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let gen_type = type_checker.builtins.generator_type
    let body = parse(
      'def gen !! Integer => Integer {
        yield 10
        throw 20
      }
      gen()'
    )

    let node = body.children[1] as Send

    module.globals.define(name: 'Integer', int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, gen_type)
    assert.true(node.resolved_throw_type.none?)

    let vparam =
      type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

    let eparam =
      type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

    assert_object_instance(type.lookup_type_parameter_type(vparam).get, int_type)
    assert_object_instance(type.lookup_type_parameter_type(eparam).get, int_type)
  }

  g.test('Creating a generator using a global') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let gen_type = type_checker.builtins.generator_type
    let body = parse(
      'def gen !! Integer => Integer {
        yield 10
        throw 20
      }
      ::gen'
    )

    let node = body.children[1] as Global

    module.globals.define(name: 'Integer', int_type)
    type_checker.check_module(module: module, ast: body)

    let type = node.resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(type, gen_type)
    assert.true(node.resolved_throw_type.none?)

    let vparam =
      type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

    let eparam =
      type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

    assert_object_instance(
      type.lookup_type_parameter_type(vparam).get,
      int_type
    )

    assert_object_instance(
      type.lookup_type_parameter_type(eparam).get,
      int_type
    )
  }
}

test.group('Type-checking Option types created using ?T') do (g) {
  g.test('Creating an Option type when Option is undefined') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo(arg: ?Integer) {}')
    let node = body.children[0] as DefineMethod

    module.globals.define(name: int_type.name, type: int_type)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.arguments[0].resolved_type.get.error?)
  }

  g.test('Creating an Option type when Option is defined') {
    let module = new_std_module('foo')
    let type_checker = TypeChecker.new
    let opt_mod = ModuleType.new(OPTION_MODULE)
    let opt_type = ClassType.new('Option')
    let opt_param = TypeParameterType.new('T')

    opt_type.type_parameters.define(name: opt_param.name, type: opt_param)
    opt_mod.define_constant(name: opt_type.name, type: opt_type)
    type_checker.add_module(opt_mod)

    let int_type = type_checker.builtins.integer_type
    let body = parse('def foo(arg: ?Integer) {}')
    let node = body.children[0] as DefineMethod

    module.globals.define(name: int_type.name, type: int_type)
    type_checker.check_module(module: module, ast: body)

    let arg_type = node.arguments[0].resolved_type.get

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(arg_type, opt_type)

    assert_object_instance(
      arg_type.lookup_type_parameter_type(opt_param).get,
      int_type
    )
  }
}

test.group('Type-checking external function definitions') do (g) {
  g.test('Defining an external function') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let flt_type = type_checker.builtins.float_type
    let str_type = type_checker.builtins.string_type
    let body = parse('extern def foo(num: Integer) !! Float -> String')

    module.define_constant(name: 'Integer', type: int_type)
    module.define_constant(name: 'Float', type: flt_type)
    module.define_constant(name: 'String', type: str_type)
    type_checker.check_module(module: module, ast: body)

    let method = module.lookup_method('foo').get.type as MethodType

    assert.true(method.external_function?)
    assert_object_instance(method.arguments['num'].type, int_type)
    assert_object_instance(method.throw_type.get, flt_type)
    assert_object_instance(method.return_type, str_type)
  }
}

test.group('Type-checking external function calls') do (g) {
  g.test('Calling an external function without a receiver') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('foo')
    let node = body.children[0]
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(int_type.new_instance),
      external: True
    )

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.false(type_checker.diagnostics.errors?)
    assert_object_instance(node.resolved_type.get, int_type)
  }

  g.test('Calling an external function with a receiver') {
    let module = new_module('foo')
    let type_checker = TypeChecker.new
    let int_type = type_checker.builtins.integer_type
    let body = parse('self.foo')
    let node = body.children[0]
    let foo = MethodType.new(
      name: 'foo',
      layout: BlockLayout.new(int_type.new_instance),
      external: True
    )

    module.define_method(name: foo.name, type: foo)
    type_checker.check_module(module: module, ast: body)

    assert.true(type_checker.diagnostics.errors?)
    assert.true(node.resolved_type.get.error?)
  }
}
