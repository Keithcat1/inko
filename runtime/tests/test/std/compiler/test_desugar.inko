import std::compiler::ast::body::Body
import std::compiler::ast::imports::Import
import std::compiler::ast::literals::IntegerLiteral
import std::compiler::ast::node::Node
import std::compiler::ast::objects::ImplementTrait
import std::compiler::ast::send::Send
import std::compiler::desugar
import std::compiler::module_name::ModuleName
import std::compiler::parser::Parser
import std::compiler::types::(BOOTSTRAP_MODULE, OBJECT_TRAIT)
import std::mirror::ObjectMirror
import std::test
import std::test::assert

def parse(input: String) -> Body {
  let parser = Parser.new(input: input, file: 'test.inko')

  try! parser.parse
}

def imports_in(body: Body) -> Array!(ModuleName) {
  body
    .children
    .iter
    .map do (node) { (node as Import).module_name }
    .to_array as Array!(ModuleName)
}

def module_name(*components: String) -> ModuleName {
  ModuleName.new(components)
}

def assert_instance_of(node: Node, instance_of: Node) {
  assert.true(ObjectMirror.new(node).instance_of?(instance_of))
}

test.group('std::compiler::desugar.add_object_implementation') do (g) {
  g.test('Adding the implementation of the Object trait') {
    let body = parse('object A {}')
    let module = module_name('foo')

    desugar.add_object_implementation(name: module, body: body)

    assert.equal(body.children.length, 2)

    let impl_node = body.children[1] as ImplementTrait

    assert.equal(impl_node.object_name.name, 'A')
    assert.equal(impl_node.trait_name.name, OBJECT_TRAIT)
    assert.true(impl_node.body.children.empty?)
    assert.same_object(impl_node.location, body.children[0].location)
  }

  g.test("The Object trait isn't implemented in std::bootstrap") {
    let body = parse('object A {}')

    desugar.add_object_implementation(name: BOOTSTRAP_MODULE, body: body)

    assert.equal(body.children.length, 1)
  }
}

test.group('std::compiler::desugar.hoist_imports') do (g) {
  g.test('Hosting imports to the start of the module') {
    let body = parse("import foo\n10\nimport bar")

    desugar.hoist_imports(body)

    assert_instance_of(body.children[0], Import)
    assert_instance_of(body.children[1], Import)
    assert_instance_of(body.children[2], IntegerLiteral)

    assert.equal(
      (body.children[0] as Import).module_name,
      ModuleName.new(Array.new('foo'))
    )

    assert.equal(
      (body.children[1] as Import).module_name,
      ModuleName.new(Array.new('bar'))
    )
  }

  g.test('Hoisting imports when there are no imports to hoist_imports') {
    let body = parse('10')

    desugar.hoist_imports(body)

    assert.equal(body.children.length, 1)
    assert_instance_of(body.children[0], IntegerLiteral)
  }
}

test.group('std::compiler::desugar.add_implicit_symbols') do (g) {
  g.test('Adding implicit symbols to an import without symbols') {
    let body = parse('import std')

    desugar.add_implicit_symbols(body)

    let imp = body.children[0] as Import

    assert.equal(imp.symbols.length, 1)
    assert.true(imp.symbols[0].import_self?)
  }

  g.test('Adding implicit symbols to an import with symbols') {
    let body = parse('import std::(foo)')

    desugar.add_implicit_symbols(body)

    let imp = body.children[0] as Import

    assert.equal(imp.symbols.length, 1)
    assert.equal(imp.symbols[0].name, 'foo')
  }
}

test.group('std::compiler::desugar.add_implicit_imports') do (g) {
  g.test('Inserting implicit imports when compiling a module without imports') {
    let body = parse('')

    desugar.add_implicit_imports(name: module_name('std', 'foo'), body: body)

    let imports = imports_in(body)

    assert.equal(
      imports,
      Array.new(
        ModuleName.new(Array.new('std', 'bootstrap')),
        ModuleName.new(Array.new('std', 'prelude')),
      )
    )
  }

  g.test('Inserting implicit imports when compiling a module with imports') {
    let body = parse('import foo')

    desugar.add_implicit_imports(name: module_name('std', 'foo'), body: body)

    let imports = imports_in(body)

    assert.equal(
      imports,
      Array.new(
        ModuleName.new(Array.new('std', 'bootstrap')),
        ModuleName.new(Array.new('std', 'prelude')),
        ModuleName.new(Array.new('foo'))
      )
    )
  }

  g.test('Inserting implicit imports when compiling std::prelude') {
    let body = parse('')

    desugar
      .add_implicit_imports(name: module_name('std', 'prelude'), body: body)

    let imports = imports_in(body)

    assert.equal(
      imports,
      Array.new(
        ModuleName.new(Array.new('std', 'bootstrap')),
      )
    )
  }

  g.test('Inserting implicit imports when compiling std::bootstrap') {
    let body = parse('')

    desugar
      .add_implicit_imports(name: module_name('std', 'bootstrap'), body: body)

    assert.true(body.children.empty?)
  }
}
