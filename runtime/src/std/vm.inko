#! Methods for interacting with the Inko virtual machine.
import std::conversion::ToString
import std::debug
import std::mirror
import std::process
import std::stdio::stderr
import std::string_buffer::StringBuffer

## Triggers a panic, terminating the VM.
##
## A panic will result in a stack trace being displayed followed by a custom
## message. Once printed the virtual machine will terminate right away.
##
## A panic should only be triggered as a last resort when no better alternative
## is available. For errors that may happen regularly (e.g. network timeouts)
## it's better to throw an error using the `throw` keyword.
##
## This method will never return.
##
## # Examples
##
## Triggering a panic:
##
##     import std::vm
##
##     vm.panic('Uh-oh, something bad happened!')
def panic(message: ToString) -> Void {
  _INKOC.panic(message.to_string)
}

## Terminates the VM immediately with the given exit status.
##
## The exit status can be a number between -2147483648 and 2147483647.
##
## While calling this method will result in the VM terminating it is technically
## possible another process sets the exit status around the same time. In this
## case the exit status will be set to most recent value.
##
## # Examples
##
## Terminating the VM:
##
##     import std::vm
##
##     vm.exit(1)
def exit(status: Integer) -> Void {
  _INKOC.exit(status)
}

## Defines the default panic handler.
##
## The provided `lambda` is executed whenever a process panics and doesn't
## define its own panic handler. Once the block returns, the process will
## terminate.
##
## The argument passed to the provided block is a `String` containing the panic
## message. Obtaining a stacktrace can be done using `std::debug.stacktrace`, as
## the call stack does not unwind before running the panick handler.
##
## # Examples
##
## Defining a custom default panic handler:
##
##     import std::vm
##     import std::stdio::stderr
##
##     vm.panicking lambda (error) {
##       stderr.print(error)
##     }
def panicking(block: lambda (String)) -> Nil {
  _INKOC.set_default_panic_handler(block)
  Nil
}

# Registers the default panic handler.
#
# When this handler is invoked, an error and stacktrace is printed, followed by
# terminating the _entire_ program. The program will be terminated with exit
# status code 1.
panicking lambda (error) {
  # We use a single buffer for the entire error, instead of writing to STDERR
  # multiple times. This ensures the output does not get messed up by other
  # processes writing to STDERR concurrently.
  let output = StringBuffer
    .new(['Stack trace (the most recent call comes last):'])

  let module_path = mirror.reflect_module(ThisModule).path

  debug.stacktrace(skip: 2).each_with_index do (frame, index) {
    # If the frame originates from this particular module, we ignore it. This
    # way we ignore any frames produced by this handler itself.
    frame.file == module_path
      .if_false {
        output.push("\n  ")
        output.push(index.to_string)
        output.push(': ')
        output.push(frame.file.to_string.inspect)
        output.push(', line ')
        output.push(frame.line.to_string)
        output.push(', in ')
        output.push(frame.name.inspect)
      }
  }

  output.push("\nProcess ")
  output.push(process.current.to_string)
  output.push(' panicked: ')
  output.push(error)

  stderr.print(output)

  exit(1)
}
