import std.fmt (fmt)
import std.io (Error as IoError)
import std.json (Error, ErrorKind, Json, Number, Parser, PullParser, Type)
import std.test (Tests)

fn parse_invalid(input: String) -> Option[String] {
  let bytes = input.to_byte_array

  Parser.new(bytes).parse.error.map(fn (v) { v.to_string })
}

fn pub tests(t: mut Tests) {
  t.test('ErrorKind.==', fn (t) {
    t.equal(
      ErrorKind.RecursionLimitExceeded(1),
      ErrorKind.RecursionLimitExceeded(1),
    )
    t.equal(ErrorKind.InvalidSurrogate('a'), ErrorKind.InvalidSurrogate('a'))
    t.equal(ErrorKind.Read(IoError.Other(1)), ErrorKind.Read(IoError.Other(1)))

    t.not_equal(ErrorKind.RecursionLimitExceeded(1), ErrorKind.Generic('foo'))
  })

  t.test('ErrorKind.fmt', fn (t) {
    t.equal(
      fmt(ErrorKind.RecursionLimitExceeded(1)),
      'RecursionLimitExceeded(1)',
    )
    t.equal(fmt(ErrorKind.InvalidSurrogate('a')), 'InvalidSurrogate("a")')
    t.equal(fmt(ErrorKind.Read(IoError.Other(1))), 'Read(Other(1))')
  })

  t.test('ErrorKind.to_string', fn (t) {
    t.equal(
      ErrorKind.RecursionLimitExceeded(1).to_string,
      'the maximum recursion depth of 1 is exceeded',
    )
    t.equal(ErrorKind.Generic('foo').to_string, 'foo')
  })

  t.test('Error.fmt', fn (t) {
    let err = Error(ErrorKind.Generic('foo'), offset: 5)

    t.equal(fmt(err), 'Error(kind: Generic("foo"), offset: 5)')
  })

  t.test('Error.==', fn (t) {
    let err1 = Error(ErrorKind.Generic('a'), offset: 5)
    let err2 = Error(ErrorKind.Generic('a'), offset: 5)
    let err3 = Error(ErrorKind.RecursionLimitExceeded(1), offset: 6)

    t.equal(err1, err2)
    t.not_equal(err1, err3)
  })

  t.test('Error.to_string', fn (t) {
    let err = Error(ErrorKind.Generic('test'), offset: 5)

    t.equal(err.to_string, 'test, at byte offset 5')
  })

  t.test('PullParser.value_type', fn (t) {
    t.equal(PullParser.new('10').value_type, Result.Ok(Type.Number))
    t.equal(PullParser.new('10.2').value_type, Result.Ok(Type.Number))
    t.equal(PullParser.new('"a"').value_type, Result.Ok(Type.String))
    t.equal(PullParser.new('true').value_type, Result.Ok(Type.Bool))
    t.equal(PullParser.new('false').value_type, Result.Ok(Type.Bool))
    t.equal(PullParser.new('null').value_type, Result.Ok(Type.Null))
    t.equal(PullParser.new('[]').value_type, Result.Ok(Type.Array))
    t.equal(PullParser.new('{}').value_type, Result.Ok(Type.Object))
  })

  t.test('PullParser.skip', fn (t) {
    let parser = PullParser.new('10')

    t.equal(parser.skip, Result.Ok(nil))
    t.equal(parser.offset, 1)
  })

  t.test('PullParser.values with valid input', fn (t) {
    let parser = PullParser.new('[10,20]')
    let values = []
    let res = parser.values(fn { parser.int.map(fn (v) { values.push(v) }) })

    t.true(res.ok?)
    t.equal(values, [10, 20])
  })

  t.test('PullParser.values with invalid input', fn (t) {
    ['', '10', '[,]', '[10,]'].into_iter.each(fn (input) {
      let parser = PullParser.new(input)

      t.true(parser.values(fn { parser.int.map(fn (_) { nil }) }).error?)
    })
  })

  t.test('PullParser.keys with valid input', fn (t) {
    let parser = PullParser.new('{"a": 10, "b": 20}')
    let values = []
    let res = parser.keys(fn (k) {
      parser.int.map(fn (v) { values.push((k, v)) })
    })

    t.true(res.ok?)
    t.equal(values, [('a', 10), ('b', 20)])
  })

  t.test('PullParser.keys with invalid input', fn (t) {
    ['', '10', '{,}', '{"a":10,}'].into_iter.each(fn (input) {
      let parser = PullParser.new(input)

      t.true(parser.keys(fn (k) { parser.int.map(fn (_) { nil }) }).error?)
    })
  })

  t.test('PullParser.bool', fn (t) {
    t.equal(PullParser.new('true').bool, Result.Ok(true))
    t.equal(PullParser.new('false').bool, Result.Ok(false))
    t.true(PullParser.new('null').bool.error?)
    t.true(PullParser.new('').bool.error?)
  })

  t.test('PullParser.null', fn (t) {
    t.equal(PullParser.new('null').null, Result.Ok(nil))
    t.true(PullParser.new('n').null.error?)
    t.true(PullParser.new('').null.error?)
  })

  t.test('PullParser.string', fn (t) {
    t.equal(PullParser.new('"hello"').string, Result.Ok('hello'))
    t.true(PullParser.new('"hello').string.error?)
    t.true(PullParser.new('').string.error?)
  })

  t.test('PullParser.int', fn (t) {
    t.equal(PullParser.new('10').int, Result.Ok(10))
    t.equal(PullParser.new('10.5').int, Result.Ok(10))
    t.true(PullParser.new('null').int.error?)
    t.true(PullParser.new('').int.error?)
  })

  t.test('PullParser.float', fn (t) {
    t.equal(PullParser.new('10.5').float, Result.Ok(10.5))
    t.equal(PullParser.new('10').float, Result.Ok(10.0))
    t.true(PullParser.new('null').float.error?)
    t.true(PullParser.new('').float.error?)
  })

  t.test('PullParser.number', fn (t) {
    t.equal(PullParser.new('10.5').number, Result.Ok(Number.Float(10.5)))
    t.equal(PullParser.new('10').number, Result.Ok(Number.Int(10)))
    t.true(PullParser.new('null').number.error?)
    t.true(PullParser.new('').number.error?)
  })

  t.test('ObjectParser.key', fn (t) {
    let parser = PullParser.new('{"a":10,"b":10}')
    let values = []
    let res = parser
      .object
      .key('a', fn { parser.int.map(fn (v) { values.push(v) }) })
      .parse

    t.true(res.ok?)
    t.equal(values, [10])
  })

  t.test('ObjectParser.string', fn (t) {
    let parser = PullParser.new('{"a":"foo","b":10}')
    let values = []
    let res = parser.object.string('a', fn (v) { values.push(v) }).parse

    t.true(res.ok?)
    t.equal(values, ['foo'])
  })

  t.test('ObjectParser.int', fn (t) {
    let parser = PullParser.new('{"a":10,"b":10}')
    let values = []
    let res = parser.object.int('a', fn (v) { values.push(v) }).parse

    t.true(res.ok?)
    t.equal(values, [10])
  })

  t.test('ObjectParser.float', fn (t) {
    let parser = PullParser.new('{"a":10.5,"b":10}')
    let values = []
    let res = parser.object.float('a', fn (v) { values.push(v) }).parse

    t.true(res.ok?)
    t.equal(values, [10.5])
  })

  t.test('ObjectParser.bool', fn (t) {
    let parser = PullParser.new('{"a":true,"b":10}')
    let values = []
    let res = parser.object.bool('a', fn (v) { values.push(v) }).parse

    t.true(res.ok?)
    t.equal(values, [true])
  })

  t.test('ObjectParser.keys', fn (t) {
    let parser = PullParser.new('{"a":{"foo":10}}')
    let values = []
    let res = parser
      .object
      .keys('a', fn (k) { parser.int.map(fn (v) { values.push((k, v)) }) })
      .parse

    t.true(res.ok?)
    t.equal(values, [('foo', 10)])
  })

  t.test('ObjectParser.values', fn (t) {
    let parser = PullParser.new('{"a":[10,20]}')
    let values = []
    let res = parser
      .object
      .values('a', fn { parser.int.map(fn (v) { values.push(v) }) })
      .parse

    t.true(res.ok?)
    t.equal(values, [10, 20])
  })

  t.test('ObjectParser.strings', fn (t) {
    let parser = PullParser.new('{"a":["foo","bar"]}')
    let values = []
    let res = parser.object.strings('a', fn (v) { values.push(v) }).parse

    t.true(res.ok?)
    t.equal(values, ['foo', 'bar'])
  })

  t.test('ObjectParser.ints', fn (t) {
    let parser = PullParser.new('{"a":[10,20]}')
    let values = []
    let res = parser.object.ints('a', fn (v) { values.push(v) }).parse

    t.true(res.ok?)
    t.equal(values, [10, 20])
  })

  t.test('ObjectParser.floats', fn (t) {
    let parser = PullParser.new('{"a":[10.5,20.5]}')
    let values = []
    let res = parser.object.floats('a', fn (v) { values.push(v) }).parse

    t.true(res.ok?)
    t.equal(values, [10.5, 20.5])
  })

  t.test('Json.fmt', fn (t) {
    let map = Map.new

    map.set('a', Json.Int(10))

    t.equal(fmt(Json.Int(42)), 'Int(42)')
    t.equal(fmt(Json.Float(42.0)), 'Float(42.0)')
    t.equal(fmt(Json.String('test')), 'String("test")')
    t.equal(fmt(Json.Array([Json.Int(10)])), 'Array([Int(10)])')
    t.equal(fmt(Json.Object(map)), 'Object({"a": Int(10)})')
    t.equal(fmt(Json.Bool(true)), 'Bool(true)')
    t.equal(fmt(Json.Bool(false)), 'Bool(false)')
    t.equal(fmt(Json.Null), 'Null')
  })

  t.test('Json.==', fn (t) {
    let map1 = Map.new
    let map2 = Map.new
    let map3 = Map.new

    map1.set('a', Json.Int(10))
    map2.set('a', Json.Int(10))
    map3.set('a', Json.Int(10))

    t.equal(Json.Int(10), Json.Int(10))
    t.not_equal(Json.Int(10), Json.Int(20))
    t.not_equal(Json.Int(10), Json.Float(20.0))

    t.equal(Json.Float(10.0), Json.Float(10.0))
    t.not_equal(Json.Float(10.0), Json.Float(20.0))
    t.not_equal(Json.Float(10.0), Json.Int(10))

    t.equal(Json.String('foo'), Json.String('foo'))
    t.not_equal(Json.String('foo'), Json.String('bar'))
    t.not_equal(Json.String('foo'), Json.Int(10))

    t.equal(Json.Array([Json.Int(10)]), Json.Array([Json.Int(10)]))
    t.not_equal(Json.Array([Json.Int(10)]), Json.Array([Json.Int(20)]))
    t.not_equal(Json.Array([Json.Int(10)]), Json.Int(10))

    t.equal(Json.Object(map1), Json.Object(map2))
    t.not_equal(Json.Object(map3), Json.Object(Map.new))
    t.not_equal(Json.Object(Map.new), Json.Int(10))

    t.equal(Json.Bool(true), Json.Bool(true))
    t.not_equal(Json.Bool(true), Json.Bool(false))
    t.not_equal(Json.Bool(true), Json.Int(10))

    t.equal(Json.Null, Json.Null)
    t.not_equal(Json.Null, Json.Int(10))
  })

  t.test('Json.to_string', fn (t) {
    let map = Map.new

    map.set('a', Json.Int(1))
    map.set('b', Json.Int(2))

    t.equal(Json.Int(42).to_string, '42')
    t.equal(Json.Float(1.2).to_string, '1.2')
    t.equal(Json.String('foo').to_string, '"foo"')
    t.equal(Json.String('a\nb').to_string, '"a\\nb"')
    t.equal(Json.String('a\rb').to_string, '"a\\rb"')
    t.equal(Json.String('a\tb').to_string, '"a\\tb"')
    t.equal(Json.String('a\u{C}b').to_string, '"a\\fb"')
    t.equal(Json.String('a\u{8}b').to_string, '"a\\bb"')
    t.equal(Json.String('a\\b').to_string, '"a\\\\b"')
    t.equal(Json.Array([]).to_string, '[]')
    t.equal(Json.Array([Json.Int(1), Json.Int(2)]).to_string, '[1, 2]')
    t.equal(Json.Object(map).to_string, '{"a": 1, "b": 2}')
    t.equal(Json.Object(Map.new).to_string, '{}')
    t.equal(Json.Bool(true).to_string, 'true')
    t.equal(Json.Bool(false).to_string, 'false')
    t.equal(Json.Null.to_string, 'null')
  })

  t.test('Json.to_pretty_string', fn (t) {
    t.equal(Json.Int(42).to_pretty_string, '42')
    t.equal(Json.Float(1.2).to_pretty_string, '1.2')
    t.equal(Json.String('foo').to_pretty_string, '"foo"')
    t.equal(Json.String('a\nb').to_pretty_string, '"a\\nb"')
    t.equal(Json.String('a\rb').to_pretty_string, '"a\\rb"')
    t.equal(Json.String('a\tb').to_pretty_string, '"a\\tb"')
    t.equal(Json.String('a\u{C}b').to_pretty_string, '"a\\fb"')
    t.equal(Json.String('a\u{8}b').to_pretty_string, '"a\\bb"')
    t.equal(Json.String('a\\b').to_pretty_string, '"a\\\\b"')
    t.equal(Json.Bool(true).to_pretty_string, 'true')
    t.equal(Json.Bool(false).to_pretty_string, 'false')
    t.equal(Json.Null.to_pretty_string, 'null')

    t.equal(Json.Array([]).to_pretty_string, '[]')
    t.equal(
      Json.Array([Json.Int(1), Json.Int(2)]).to_pretty_string,
      '[
  1,
  2
]',
    )

    t.equal(
      Json.Array([Json.Array([Json.Int(1), Json.Int(2)])]).to_pretty_string,
      '[
  [
    1,
    2
  ]
]',
    )

    let map1 = Map.new
    let map2 = Map.new
    let map3 = Map.new

    map1.set('a', Json.Int(1))
    map1.set('b', Json.Int(2))
    map2.set('a', Json.Array([Json.Int(1), Json.Int(2)]))
    map3.set('a', Json.Int(1))
    map3.set('b', Json.Object(map2))

    t.equal(Json.Object(Map.new).to_pretty_string, '{}')
    t.equal(
      Json.Object(map1).to_pretty_string,
      '{
  "a": 1,
  "b": 2
}',
    )

    t.equal(
      Json.Object(map3).to_pretty_string,
      '{
  "a": 1,
  "b": {
    "a": [
      1,
      2
    ]
  }
}',
    )
  })

  t.test('Json.parse with integers', fn (t) {
    t.equal(Json.parse('0'), Result.Ok(Json.Int(0)))
    t.equal(Json.parse('42'), Result.Ok(Json.Int(42)))
    t.equal(Json.parse('  42'), Result.Ok(Json.Int(42)))
    t.equal(Json.parse('42   '), Result.Ok(Json.Int(42)))
    t.equal(Json.parse('\t42'), Result.Ok(Json.Int(42)))
    t.equal(Json.parse('\r42'), Result.Ok(Json.Int(42)))
    t.equal(Json.parse('-42'), Result.Ok(Json.Int(-42)))

    t.true(Json.parse('00').error?)
    t.true(Json.parse('10,').error?)
    t.true(Json.parse('-').error?)
    t.true(Json.parse('-01').error?)
    t.true(Json.parse('01').error?)
    t.true(Json.parse('1a').error?)
    t.true(Json.parse('-a').error?)
    t.true(Json.parse('- ').error?)
  })

  t.test('Json.parse with floats', fn (t) {
    t.equal(Json.parse('  1.2'), Result.Ok(Json.Float(1.2)))
    t.equal(Json.parse('1.2   '), Result.Ok(Json.Float(1.2)))
    t.equal(Json.parse('1.2'), Result.Ok(Json.Float(1.2)))
    t.equal(Json.parse('-1.2'), Result.Ok(Json.Float(-1.2)))
    t.equal(Json.parse('1.2e+123'), Result.Ok(Json.Float(1.2e+123)))
    t.equal(Json.parse('1.2e-123'), Result.Ok(Json.Float(1.2e-123)))
    t.equal(Json.parse('1.2E+123'), Result.Ok(Json.Float(1.2e+123)))
    t.equal(Json.parse('1.2E-123'), Result.Ok(Json.Float(1.2e-123)))
    t.equal(Json.parse('-1.2E-123'), Result.Ok(Json.Float(-1.2e-123)))
    t.equal(Json.parse('0.0'), Result.Ok(Json.Float(0.0)))
    t.equal(Json.parse('0E0'), Result.Ok(Json.Float(0.0)))
    t.equal(Json.parse('0e+1'), Result.Ok(Json.Float(0.0)))
    t.equal(Json.parse('1.2E1'), Result.Ok(Json.Float(1.2e1)))
    t.equal(Json.parse('1.2e1'), Result.Ok(Json.Float(1.2e1)))
    t.equal(
      Json.parse('1.7976931348623157e+310'),
      Result.Ok(Json.Float(Float.infinity)),
    )
    t.equal(
      Json.parse('4.940656458412465441765687928682213723651e-330'),
      Result.Ok(Json.Float(0.0)),
    )
    t.equal(
      Json.parse(
        '-0.000000000000000000000000000000000000000000000000000000000000000000000000000001',
      ),
      Result.Ok(Json.Float(-1.0E-78)),
    )

    # These numbers are too big for regular integers, so we promote them to
    # floats.
    t.equal(
      Json.parse('11111111111111111111111111111111111111111'),
      Result.Ok(Json.Float(11111111111111111111111111111111111111111.0)),
    )
    t.equal(
      Json.parse('10000000000000000999'),
      Result.Ok(Json.Float(10000000000000000999.0)),
    )

    t.true(Json.parse('00.0').error?)
    t.true(Json.parse('1.2e').error?)
    t.true(Json.parse('1.2e+').error?)
    t.true(Json.parse('1.2e-').error?)
    t.true(Json.parse('1.2E').error?)
    t.true(Json.parse('1.2E+').error?)
    t.true(Json.parse('1.2E-').error?)
    t.true(Json.parse('1.2E+a').error?)
    t.true(Json.parse('1.2E-a').error?)
    t.true(Json.parse('0E').error?)
    t.true(Json.parse('10.2,').error?)

    t.equal(
      parse_invalid('\n1.2e'),
      Option.Some(
        'all input is consumed but more input is expected, at byte offset 4',
      ),
    )
  })

  t.test('Json.parse with arrays', fn (t) {
    t.equal(Json.parse('[]'), Result.Ok(Json.Array([])))
    t.equal(Json.parse('[10]'), Result.Ok(Json.Array([Json.Int(10)])))
    t.equal(
      Json.parse('[10, 20]'),
      Result.Ok(Json.Array([Json.Int(10), Json.Int(20)])),
    )

    t.true(Json.parse('[').error?)
    t.true(Json.parse(']').error?)
    t.true(Json.parse('[,10]').error?)
    t.true(Json.parse('[10,]').error?)
    t.true(Json.parse('[10').error?)
    t.true(Json.parse('[10,').error?)
    t.true(Json.parse('[10true]').error?)
    t.true(Json.parse('[],').error?)

    {
      let bytes = '[[[[10]]]]'.to_byte_array
      let parser = Parser.new(bytes)

      parser.max_depth = 2
      t.true(parser.parse.error?)
    }
  })

  t.test('Json.parse with booleans', fn (t) {
    t.equal(Json.parse('true'), Result.Ok(Json.Bool(true)))
    t.equal(Json.parse('false'), Result.Ok(Json.Bool(false)))

    t.true(Json.parse('t').error?)
    t.true(Json.parse('tr').error?)
    t.true(Json.parse('tru').error?)
    t.true(Json.parse('f').error?)
    t.true(Json.parse('fa').error?)
    t.true(Json.parse('fal').error?)
    t.true(Json.parse('fals').error?)
  })

  t.test('Json.parse with NULL', fn (t) {
    t.equal(Json.parse('null'), Result.Ok(Json.Null))

    t.true(Json.parse('n').error?)
    t.true(Json.parse('nu').error?)
    t.true(Json.parse('nul').error?)
  })

  t.test('Json.parse with strings', fn (t) {
    t.equal(Json.parse('"foo"'), Result.Ok(Json.String('foo')))
    t.equal(Json.parse('"foo bar"'), Result.Ok(Json.String('foo bar')))
    t.equal(Json.parse('"foo\\nbar"'), Result.Ok(Json.String('foo\nbar')))
    t.equal(Json.parse('"foo\\tbar"'), Result.Ok(Json.String('foo\tbar')))
    t.equal(Json.parse('"foo\\rbar"'), Result.Ok(Json.String('foo\rbar')))
    t.equal(Json.parse('"foo\\bbar"'), Result.Ok(Json.String('foo\u{8}bar')))
    t.equal(Json.parse('"foo\\fbar"'), Result.Ok(Json.String('foo\u{C}bar')))
    t.equal(Json.parse('"foo\\"bar"'), Result.Ok(Json.String('foo"bar')))
    t.equal(Json.parse('"foo\\/bar"'), Result.Ok(Json.String('foo/bar')))
    t.equal(Json.parse('"foo\\\\bar"'), Result.Ok(Json.String('foo\\bar')))
    t.equal(Json.parse('"foo\\u005Cbar"'), Result.Ok(Json.String('foo\\bar')))
    t.equal(
      Json.parse('"foo\\u001Fbar"'),
      Result.Ok(Json.String('foo\u{1F}bar')),
    )
    t.equal(Json.parse('"\\uD834\\uDD1E"'), Result.Ok(Json.String('\u{1D11E}')))
    t.equal(
      Json.parse('"\\uE000\\uE000"'),
      Result.Ok(Json.String('\u{E000}\u{E000}')),
    )

    t.true(Json.parse('"\0"').error?)
    t.true(Json.parse('"\n"').error?)
    t.true(Json.parse('"\t"').error?)
    t.true(Json.parse('"\r"').error?)
    t.true(Json.parse('"\u{8}"').error?) # \b
    t.true(Json.parse('"\u{C}"').error?) # \f

    t.true(Json.parse('"\\x42"').error?)
    t.true(Json.parse('"\\u1"').error?)
    t.true(Json.parse('"\\u12"').error?)
    t.true(Json.parse('"\\u123"').error?)
    t.true(Json.parse('"\\u{XXXX}"').error?)
    t.true(Json.parse('"\\uD834\\uE000"').error?)
    t.true(Json.parse('"\\uD834\\uZZZZ"').error?)
    t.true(Json.parse('"\\uDFFF\\uDFFF"').error?)

    t.equal(
      parse_invalid('"a'),
      Option.Some(
        'all input is consumed but more input is expected, at byte offset 1',
      ),
    )
  })

  t.test('Json.parse with objects', fn (t) {
    let map1 = Map.new
    let map2 = Map.new
    let map3 = Map.new
    let map4 = Map.new
    let map5 = Map.new

    map2.set('a', Json.Int(10))
    map3.set('a', Json.Int(20))
    map4.set('a', Json.Int(10))
    map4.set('b', Json.Int(20))
    map5.set('a', Json.Int(10))
    map5.set('b', Json.Int(20))

    t.equal(Json.parse('{}'), Result.Ok(Json.Object(map1)))
    t.equal(Json.parse('{ "a" : 10 }'), Result.Ok(Json.Object(map2)))
    t.equal(Json.parse('{"a": 10, "a": 20}'), Result.Ok(Json.Object(map3)))
    t.equal(Json.parse('{"a": 10, "b": 20}'), Result.Ok(Json.Object(map4)))
    t.equal(
      Json.parse(
        '{
          "a": 10,
          "b": 20
        }',
      ),
      Result.Ok(Json.Object(map5)),
    )

    t.true(Json.parse('{').error?)
    t.true(Json.parse('}').error?)
    t.true(Json.parse('{{}}').error?)
    t.true(Json.parse('{"a"}').error?)
    t.true(Json.parse('{"a":}').error?)
    t.true(Json.parse('{"a":10,}').error?)
    t.true(Json.parse('{"a":10 "b": 20}').error?)
    t.true(Json.parse('{a":10,}').error?)
    t.true(Json.parse('{},').error?)
    t.true(Json.parse('{"a": true} "x"').error?)

    {
      let bytes = '{"a": {"b": {"c": 10}}}'.to_byte_array
      let parser = Parser.new(bytes)

      parser.max_depth = 2
      t.true(parser.parse.error?)
    }

    t.equal(
      parse_invalid('{"a"}'),
      Option.Some(
        "the character ':' is expected but '}' was found instead, at byte offset 4",
      ),
    )
  })

  t.test('Json.parse with Unicode BOMs', fn (t) {
    t.true(Json.parse('\u{FEFF}10').error?)
    t.true(Json.parse('\u{FFFE}10').error?)
    t.true(Json.parse('\u{EF}\u{BB}\u{BF}10').error?)
  })

  t.test('Json.query', fn (t) {
    t.equal(Json.Int(42).query.as_int, Option.Some(42))
    t.equal(Json.String('test').query.as_int, Option.None)
  })

  t.test('Query.key', fn (t) {
    let map = Map.new

    map.set('name', Json.String('Alice'))

    let obj = Json.Object(map)

    t.equal(obj.query.key('name').as_string, Option.Some('Alice'))
    t.equal(obj.query.key('city').as_string, Option.None)
    t.equal(Json.Int(42).query.key('name').as_string, Option.None)
  })

  t.test('Query.index', fn (t) {
    t.equal(Json.Array([Json.Int(42)]).query.index(0).as_int, Option.Some(42))
    t.equal(Json.Array([Json.Int(42)]).query.index(1).as_int, Option.None)
    t.equal(Json.Int(42).query.index(0).as_int, Option.None)
  })

  t.test('Query.as_int', fn (t) {
    t.equal(Json.String('test').query.as_int, Option.None)
    t.equal(Json.Float(1.2).query.as_int, Option.None)
    t.equal(Json.Null.query.as_int, Option.None)
    t.equal(Json.Array([]).query.as_int, Option.None)
    t.equal(Json.Object(Map.new).query.as_int, Option.None)
    t.equal(Json.Int(42).query.as_int, Option.Some(42))
  })

  t.test('Query.as_float', fn (t) {
    t.equal(Json.String('test').query.as_float, Option.None)
    t.equal(Json.Null.query.as_float, Option.None)
    t.equal(Json.Int(42).query.as_float, Option.None)
    t.equal(Json.Array([]).query.as_float, Option.None)
    t.equal(Json.Object(Map.new).query.as_float, Option.None)
    t.equal(Json.Float(1.2).query.as_float, Option.Some(1.2))
  })

  t.test('Query.as_string', fn (t) {
    t.equal(Json.Null.query.as_string, Option.None)
    t.equal(Json.Int(42).query.as_string, Option.None)
    t.equal(Json.Float(1.2).query.as_string, Option.None)
    t.equal(Json.Array([]).query.as_string, Option.None)
    t.equal(Json.Object(Map.new).query.as_string, Option.None)
    t.equal(Json.String('test').query.as_string, Option.Some('test'))
  })

  t.test('Query.as_array', fn (t) {
    t.equal(Json.Null.query.as_array, Option.None)
    t.equal(Json.Int(42).query.as_array, Option.None)
    t.equal(Json.Float(1.2).query.as_array, Option.None)
    t.equal(Json.Object(Map.new).query.as_array, Option.None)
    t.equal(Json.String('test').query.as_array, Option.None)
    t.equal(
      Json.Array([Json.Int(42)]).query.as_array,
      Option.Some(ref [Json.Int(42)]),
    )
  })

  t.test('Query.as_object', fn (t) {
    t.equal(Json.Null.query.as_object, Option.None)
    t.equal(Json.Int(42).query.as_object, Option.None)
    t.equal(Json.Float(1.2).query.as_object, Option.None)
    t.equal(Json.String('test').query.as_object, Option.None)
    t.equal(Json.Array([Json.Int(42)]).query.as_object, Option.None)
    t.equal(Json.Object(Map.new).query.as_object, Option.Some(ref Map.new))
  })

  t.test('Query.as_bool', fn (t) {
    t.equal(Json.Bool(true).query.as_bool, Option.Some(true))
    t.equal(Json.Bool(false).query.as_bool, Option.Some(false))
    t.equal(Json.Int(42).query.as_bool, Option.None)
  })
}
