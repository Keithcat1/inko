class List {
  let @values: Array[Int]
  let @sendable: uni Array[Int]

  fn example1 {
    recover {
      @values # Referring to a field is fine, as we expose it as `uni ref` or
              # `uni mut`.
      nil
    }
  }

  fn example2 {
    recover @values.clone # This _is_ allowed, because cloning returns a new
                          # owned value, and in this case the sub values (Int)
                          # are sendable.
  }

  fn example3 {
    recover @values # The field type isn't recoverable, so this isn't allowed
  }

  fn mut example4 {
    recover {
      @values = [10, 20] # Assignments aren't allowed, as references to the
                         # value returned by `recover` may escape through the
                         # assignment
      nil
    }
  }

  fn mut example5 {
    recover {
      @sendable = recover [10] # This _is_ OK because the value is sendable.
      nil
    }
  }

  fn mut example6 {
    recover {
      self.values = [10]
      self.sendable = recover [10]
    }
  }
}

# field_in_recover.inko:20:5 error(invalid-type): values of type 'uni ref Array[Int]' can't be recovered
# field_in_recover.inko:25:7 error(invalid-symbol): the field 'values' can't be assigned a value of type 'Array[Int]', as it's not sendable
# field_in_recover.inko:41:12 error(invalid-symbol): the field 'values' can't be assigned a value of type 'Array[Int]', as it's not sendable
