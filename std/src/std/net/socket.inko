# IP and Unix domain sockets.
#
# This module provides types for various socket types, such as TCP, UDP and Unix
# sockets.
#
# The types `Socket` and `UnixSocket` are low-level sockets that implement most
# of the socket logic. Types such as `TcpServer` and `TcpClient` wrap these
# sockets to make it easier to create commonly used sockets, such as a TCP
# client.
#
# # Deadlines and timeouts
#
# Socket timeouts are supported through a mechanism known as a "deadline". A
# deadline specifies the time after which socket operations must time out when
# waiting for them to complete. Deadlines represent a fixed point in time, and
# can be created from both `Duration` and `Instant` values.
#
# The use of deadlines instead of timeouts makes it easier to apply time limits
# to multiple operations. Consider the following chain of events:
#
# 1. `read()`
# 1. `write()`
# 1. `read()`
#
# Traditionally one might set a timeout such as 10 seconds. This poses a
# problem: the timeout is applied to every operation, meaning each operation is
# allowed to run up to 10 seconds, resulting in a total maximum runtime of 30
# seconds.
#
# Using deadlines one sets a deadline in the future, and no matter the amount of
# operations performed, the operations time out once we cross the deadline. In
# our above example that means we can easily limit the total runtime to 10
# seconds using a deadline that's 10 seconds in the future.
#
# Deadlines are set using `Socket.timeout_after` and
# `UnixSocket.timeout_after=`. Here's an example using deadlines to limit the
# time spent waiting for a client to connect:
#
# ```inko
# import std.net.ip (IpAddress)
# import std.net.socket (TcpServer)
# import std.time (Duration)
#
# let server = TcpServer.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9000).get
#
# server.socket.timeout_after = Duration.from_secs(3)
#
# # This times out after roughly three seconds.
# server.accept.get
# ```
#
# It's important to keep in mind that deadlines only apply when an operation
# must wait, i.e. a read is performed but no data is available. If the operation
# completes immediately (i.e. a read is performed and enough data _is_
# available), the deadline is ignored. This means that if you perform an
# operation in a loop and set a deadline, and data is always available such that
# the operation never blocks, the loop may run indefinitely; depending on what
# the loop does of course.
#
# For more information about timeouts versus deadlines, consider reading [this
# article](https://vorpus.org/blog/timeouts-and-cancellation-for-humans/).
import std.cmp (Equal)
import std.drop (Drop)
import std.fmt (Format, Formatter)
import std.fs.path (Path)
import std.io (Error, Read, Write, WriteInternal)
import std.libc
import std.net.ip (IpAddress)
import std.string (ToString)
import std.time (Duration, ToInstant)

# The maximum value valid for a listen() call.
#
# Linux and FreeBSD do not allow for values greater than this as they internally
# use an u16, so we'll limit the backlog to this value. We don't use SOMAXCONN
# because it might be hardcoded. This means that setting `net.core.somaxconn` on
# Linux (for example) would have no effect.
let MAXIMUM_LISTEN_BACKLOG = 65_535

# A value that signals the lack of a socket deadline.
let NO_DEADLINE = -1
let IPV4 = 0
let IPV6 = 1
let UNIX = 2
let STREAM = 0
let DGRAM = 1
let RAW = 2

fn extern setsockopt(
  socket: Int32,
  level: Int32,
  option: Int32,
  value: Pointer[UInt8],
  size: Int32,
) -> Int32

fn extern getsockopt(
  socket: Int32,
  level: Int32,
  option: Int32,
  value: Pointer[UInt8],
  size: Pointer[Int32],
) -> Int32

fn extern inko_socket_new(
  domain: Int,
  kind: Int,
  protocol: Int,
  out: Pointer[RawSocket],
) -> Int64

fn extern inko_socket_accept(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  deadline: Int,
  out: Pointer[RawSocket],
) -> Int64

fn extern inko_socket_local_address(
  state: Pointer[UInt8],
  socket: Pointer[RawSocket],
  out: Pointer[RawAddress],
) -> Int64

fn extern inko_socket_peer_address(
  state: Pointer[UInt8],
  socket: Pointer[RawSocket],
  out: Pointer[RawAddress],
) -> Int64

fn extern inko_socket_receive_from(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: mut ByteArray,
  amount: Int,
  deadline: Int,
  out: Pointer[RawAddress],
) -> Int64

fn extern inko_socket_bind(
  socket: Pointer[RawSocket],
  address: String,
  port: Int,
) -> IntResult

fn extern inko_socket_read(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: mut ByteArray,
  amount: Int,
  deadline: Int,
) -> IntResult

fn extern inko_socket_connect(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  address: String,
  port: Int,
  deadline: Int,
) -> IntResult

fn extern inko_socket_listen(
  socket: Pointer[RawSocket],
  value: Int,
) -> IntResult

fn extern inko_socket_drop(socket: Pointer[RawSocket])

fn extern inko_socket_send_bytes_to(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: ref ByteArray,
  address: String,
  port: Int,
  deadline: Int,
) -> IntResult

fn extern inko_socket_send_string_to(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: String,
  address: String,
  port: Int,
  deadline: Int,
) -> IntResult

fn extern inko_socket_write(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  data: Pointer[UInt8],
  size: Int,
  deadline: Int,
) -> IntResult

fn extern inko_socket_try_clone(
  socket: Pointer[RawSocket],
  out: Pointer[RawSocket],
) -> Int64

fn extern inko_socket_shutdown_read(socket: Pointer[RawSocket]) -> IntResult

fn extern inko_socket_shutdown_write(socket: Pointer[RawSocket]) -> IntResult

fn extern inko_socket_shutdown_read_write(
  socket: Pointer[RawSocket],
) -> IntResult

class extern Linger {
  let @l_onoff: Int32
  let @l_linger: Int32
}

class extern RawSocket {
  let @inner: Int32
  let @registered: UInt8
  let @unix: UInt8
}

class extern RawAddress {
  let @address: String
  let @port: Int
}

class extern IntResult {
  let @tag: Int
  let @value: Int
}

trait RawSocketOperations {
  fn mut raw_socket -> Pointer[RawSocket]

  fn raw_deadline -> Int
}

# An IPv4 or IPv6 socket address.
class pub SocketAddress {
  # The IPv4/IPv6 address of this socket address.
  let pub @ip: IpAddress

  # The port number of this socket address.
  let pub @port: Int

  fn static from_raw(raw: ref RawAddress) -> SocketAddress {
    # The address passed to this method is one filled in by the system. Assuming
    # our IP address parsing logic is complete (which it should be),
    # encountering an address we can't parse is a bug and should terminate the
    # program.
    let ip = match IpAddress.parse(raw.address) {
      case Some(v) -> v
      case _ -> panic("IpAddress.parse doesn't support '${raw.address}'")
    }

    SocketAddress(ip, raw.port)
  }
}

impl Equal[ref SocketAddress] for SocketAddress {
  # Returns `true` if `self` and `other` are the same.
  fn pub ==(other: ref SocketAddress) -> Bool {
    @ip == other.ip and @port == other.port
  }
}

impl Format for SocketAddress {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write('${@ip}:${@port}')
  }
}

# A low-level, non-blocking IPv4 or IPv6 socket.
class pub Socket {
  let @socket: RawSocket

  # A point in time after which socket operations time out.
  #
  # We use an `Int` to remove the need for using `Option[Instant]`.
  let @deadline: Int

  fn static new(
    domain: Int,
    type: Int,
    protocol: Int,
  ) -> Result[Socket, Error] {
    let sock = RawSocket(
      inner: 0 as Int32,
      registered: 0 as UInt8,
      unix: 0 as UInt8,
    )

    match inko_socket_new(domain, type, protocol, mut sock) as Int {
      case 0 -> Result.Ok(Socket(socket: sock, deadline: NO_DEADLINE))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns a new `Socket` configured as a stream socket.
  #
  # The `ipv6` argument specifies if the socket is an IPv4 socket (`false`) or
  # an IPv6 socket (`true`).
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  #
  # Socket.stream(ipv6: false)
  # ```
  fn pub static stream(ipv6: Bool) -> Result[Socket, Error] {
    Socket.new(ipv6.to_int, STREAM, protocol: 0)
  }

  # Returns a new `Socket` configured as a datagram socket.
  #
  # The `ipv6` argument specifies if the socket is an IPv4 socket (`false`) or
  # an IPv6 socket (`true`).
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  #
  # Socket.datagram(ipv6: false)
  # ```
  fn pub static datagram(ipv6: Bool) -> Result[Socket, Error] {
    Socket.new(ipv6.to_int, DGRAM, protocol: 0)
  }

  # Returns a new `Socket` configured as a raw socket.
  #
  # The `ipv6` argument specifies if the socket is an IPv4 socket (`false`) or
  # an IPv6 socket (`true`).
  #
  # The `protocol` argument must specify a valid IANA IP protocol as defined in
  # RFC 1700.
  #
  # Note that on certain platforms (e.g. Linux, and probably most other Unix
  # systems) you'll need root privileges in order to create a raw socket.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  #
  # Socket.raw(ipv6: false, protocol: 1)
  # ```
  fn pub static raw(ipv6: Bool, protocol: Int) -> Result[Socket, Error] {
    Socket.new(ipv6.to_int, RAW, protocol)
  }

  # Sets the point in time after which socket operations must time out, known as
  # a "deadline".
  #
  # # Examples
  #
  # Using a `Duration` results in this method calculating the absolute time
  # after which operations time out:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.time (Duration)
  #
  # let socket = Socket.datagram(ipv6: false)
  #
  # socket.timeout_after = Duration.from_secs(5)
  # ```
  #
  # We can also use an `Instant`:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.time (Duration, Instant)
  #
  # let socket = Socket.datagram(ipv6: false)
  #
  # socket.timeout_after = Instant.new + Duration.from_secs(5)
  # ```
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @deadline = deadline.to_instant.to_int
  }

  # Clears the deadline to apply to socket operations.
  fn pub mut reset_deadline {
    @deadline = NO_DEADLINE
  }

  # Binds this socket to the specified address.
  #
  # # Examples
  #
  # Binding a socket:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # ```
  fn pub mut bind(ip: ref IpAddress, port: Int) -> Result[Nil, Error] {
    match inko_socket_bind(@socket, ip.to_string, port) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a socket:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let listener = Socket.stream(ipv6: false).get
  # let client = Socket.stream(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket.listen.get
  # client.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # ```
  fn pub mut connect(ip: ref IpAddress, port: Int) -> Result[Nil, Error] {
    match
      inko_socket_connect(
        _INKO.state,
        _INKO.process,
        @socket,
        ip.to_string,
        port,
        @deadline,
      )
    {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.stream(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket.listen.get
  # ```
  fn pub mut listen -> Result[Nil, Error] {
    match inko_socket_listen(@socket, MAXIMUM_LISTEN_BACKLOG) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let listener = Socket.stream(ipv6: false).get
  # let stream = Socket.stream(ipv6: false).get
  #
  # listener.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # listener.listen.get
  #
  # stream.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # stream.write_string('ping').get
  #
  # let client = listener.accept.get
  # let buffer = ByteArray.new
  #
  # client.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[Socket, Error] {
    let sock = RawSocket(
      inner: 0 as Int32,
      registered: 0 as UInt8,
      unix: 0 as UInt8,
    )

    match
      inko_socket_accept(
        _INKO.state,
        _INKO.process,
        @socket,
        @deadline,
        mut sock,
      )
        as Int
    {
      case 0 -> Result.Ok(Socket(socket: sock, deadline: NO_DEADLINE))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sends a `String` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket
  #   .send_string_to(
  #     string: 'hello',
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  # ```
  fn pub mut send_string_to(
    string: String,
    ip: ref IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    match
      inko_socket_send_string_to(
        _INKO.state,
        _INKO.process,
        @socket,
        string,
        ip.to_string,
        port,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  # let bytes = 'hello'.to_byte_array
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket
  #   .send_bytes_to(
  #     bytes: bytes,
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  # ```
  fn pub mut send_bytes_to(
    bytes: ref ByteArray,
    ip: ref IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    match
      inko_socket_send_bytes_to(
        _INKO.state,
        _INKO.process,
        @socket,
        bytes,
        ip.to_string,
        port,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  # let bytes = ByteArray.new
  #
  # socket
  #   .send_string_to(
  #     'hello',
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  #
  # let received_from = socket.receive_from(bytes: bytes, size: 5).get
  #
  # bytes.to_string       # => 'hello'
  # received_from.address # => '0.0.0.0'
  # received_from.port    # => 9999
  # ```
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[SocketAddress, Error] {
    let raw = RawAddress(address: '', port: 0)

    match
      inko_socket_receive_from(
        _INKO.state,
        _INKO.process,
        @socket,
        bytes,
        size,
        @deadline,
        mut raw,
      )
        as Int
    {
      case 0 -> Result.Ok(SocketAddress.from_raw(raw))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns the local address of this socket.
  fn pub local_address -> Result[SocketAddress, Error] {
    let raw = RawAddress(address: '', port: 0)

    match inko_socket_local_address(_INKO.state, @socket, mut raw) as Int {
      case 0 -> Result.Ok(SocketAddress.from_raw(raw))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns the peer address of this socket.
  fn pub peer_address -> Result[SocketAddress, Error] {
    let raw = RawAddress(address: '', port: 0)

    match inko_socket_peer_address(_INKO.state, @socket, mut raw) as Int {
      case 0 -> Result.Ok(SocketAddress.from_raw(raw))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `IP_TTL` option.
  fn pub mut ttl=(value: Int) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_IP, libc.IP_TTL, value)
  }

  # Sets the value of the `IPV6_V6ONLY` option.
  fn pub mut only_ipv6=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_IPV6, libc.IPV6_V6ONLY, value.to_int)
  }

  # Sets the value of the `TCP_NODELAY` option.
  fn pub mut no_delay=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_TCP, libc.TCP_NODELAY, value.to_int)
  }

  # Returns `true` if the `TCP_NODELAY` option is set.
  fn pub no_delay? -> Bool {
    get_option(libc.IPPROTO_TCP, libc.TCP_NODELAY) != 0
  }

  # Sets the value of the `SO_BROADCAST` option.
  fn pub mut broadcast=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_BROADCAST, value.to_int)
  }

  # Sets the value of the `SO_LINGER` option.
  #
  # If a `Some` is given, the linger value is set to the duration in seconds. If
  # a `None` is given, the linger value is instead reset.
  #
  # On most platforms the linger duration has a precision of whole seconds. If a
  # `Duration` is supplied that is less than one second long or contains
  # fractional seconds, the value may be truncated or rounded to the nearest
  # second.
  fn pub mut linger=(value: Option[Duration]) -> Result[Nil, Error] {
    let linger = Linger(l_onoff: 0 as Int32, l_linger: 0 as Int32)

    match value {
      case Some(d) -> {
        linger.l_onoff = 1 as Int32
        linger.l_linger = d.to_secs.to_int as Int32
      }
      case _ -> {}
    }

    let res = setsockopt(
      @socket.inner,
      libc.SOL_SOCKET as Int32,
      libc.SO_LINGER as Int32,
      (mut linger) as Pointer[UInt8],
      8 as Int32,
    )
      as Int

    if res == 0 { Result.Ok(nil) } else { Result.Error(Error.last_os_error) }
  }

  # Returns the value of the `SO_LINGER` option.
  fn pub linger -> Option[Duration] {
    let linger = Linger(l_onoff: 0 as Int32, l_linger: 0 as Int32)
    let size = 8 as Int32
    let res = getsockopt(
      @socket.inner,
      libc.SOL_SOCKET as Int32,
      libc.SO_LINGER as Int32,
      (mut linger) as Pointer[UInt8],
      mut size,
    )
      as Int

    # Similar to get_option(), this method shouldn't ever reach this point, but
    # we panic just in case we do.
    if res != 0 { panic('getsockopt(2) failed: ${Error.last_os_error}') }

    if linger.l_onoff as Int != 0 {
      Option.Some(Duration.from_secs(linger.l_linger as Int))
    } else {
      Option.None
    }
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_RCVBUF, value.to_int)
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_SNDBUF, value.to_int)
  }

  # Sets the value of the `SO_KEEPALIVE` option.
  fn pub mut keepalive=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_KEEPALIVE, value.to_int)
  }

  # Sets the value of the `SO_REUSEADDR` option.
  fn pub mut reuse_address=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_REUSEADDR, value.to_int)
  }

  # Sets the value of the `SO_REUSEPORT` option.
  #
  # Not all platforms may support this option, in which case the supplied
  # argument will be ignored.
  fn pub mut reuse_port=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_REUSEPORT, value.to_int)
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    match inko_socket_shutdown_read(@socket) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    match inko_socket_shutdown_write(@socket) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    match inko_socket_shutdown_read_write(@socket) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[Socket, Error] {
    let sock = RawSocket(
      inner: 0 as Int32,
      registered: 0 as UInt8,
      unix: 0 as UInt8,
    )

    match inko_socket_try_clone(@socket, mut sock) as Int {
      case 0 -> Result.Ok(Socket(socket: sock, deadline: NO_DEADLINE))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  fn mut set_option(level: Int, option: Int, value: Int) -> Result[Nil, Error] {
    let val = value as Int32
    let res = setsockopt(
      @socket.inner,
      level as Int32,
      option as Int32,
      (mut val) as Pointer[UInt8],
      4 as Int32,
    )
      as Int

    if res == 0 { Result.Ok(nil) } else { Result.Error(Error.last_os_error) }
  }

  fn get_option(level: Int, option: Int) -> Int {
    let size = 4 as Int32
    let val = 0 as Int32
    let res = getsockopt(
      @socket.inner,
      level as Int32,
      option as Int32,
      (mut val) as Pointer[UInt8],
      mut size,
    )
      as Int

    if res == 0 {
      val as Int
    } else {
      # Since we control the arguments passed to getsockopt() such that they
      # won't be invalid, this method isn't expected to fail at runtime. To
      # remove the need for unneccesary error handling, we panic instead should
      # we encounter an error after all.
      panic('getsockopt(2) failed: ${Error.last_os_error}')
    }
  }
}

impl RawSocketOperations for Socket {
  fn mut raw_socket -> Pointer[RawSocket] {
    @socket
  }

  fn raw_deadline -> Int {
    @deadline
  }
}

impl Drop for Socket {
  fn mut drop {
    inko_socket_drop(@socket)
  }
}

impl Read for Socket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    match
      inko_socket_read(
        _INKO.state,
        _INKO.process,
        @socket,
        into,
        size,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl WriteInternal for Socket {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    let state = _INKO.state
    let proc = _INKO.process

    match inko_socket_write(state, proc, @socket, data, size, @deadline) {
      case { @tag = 0, @value = n } -> Result.Ok(n)
      case { @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Write for Socket {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    write_all_internal(bytes.to_pointer, bytes.size)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    write_all_internal(string.to_pointer, string.size)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A UDP socket.
#
# A `UdpSocket` can be used to easily create a bound UDP socket from an IP
# address and a port.
class pub UdpSocket {
  # The raw `Socket` wrapped by this `UdpSocket`.
  let pub @socket: Socket

  # Creates a new `UdpSocket`, bound to the given address.
  #
  # # Examples
  #
  # Creating a new bound UDP socket:
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # UdpSocket.new(IpAddress.v4(0, 0, 0, 0), port: 0).get
  # ```
  fn pub static new(ip: ref IpAddress, port: Int) -> Result[UdpSocket, Error] {
    let socket = try Socket.datagram(ip.v6?)

    try socket.bind(ip, port)
    Result.Ok(UdpSocket(socket))
  }

  # Connects `self` to the remote address.
  #
  # Connecting a `UdpSocket` allows sending and receiving data using the
  # methods from `std.io.Read` and `std.io.Write`, instead of having to use
  # `UdpSocket.receive_from` and `UdpSocket.send_to`.
  #
  # # Examples
  #
  # Connecting a UDP socket:
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # let socket1 =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 40_000).get
  # let socket2 =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 41_000).get
  #
  # socket1.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 41_000).get
  # ```
  fn pub mut connect(ip: ref IpAddress, port: Int) -> Result[Nil, Error] {
    @socket.connect(ip, port)
  }

  # Sends a `String` to the given address.
  #
  # See the documentation of `Socket.send_string_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # let socket =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #
  # socket
  #   .send_string_to(
  #     string: 'hello',
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  # ```
  fn pub mut send_string_to(
    string: String,
    ip: ref IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    @socket.send_string_to(string, ip, port)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `Socket.send_bytes_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # let socket =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # let bytes = 'hello'.to_byte_array
  #
  # socket
  #   .send_bytes_to(
  #     bytes: bytes,
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  # ```
  fn pub mut send_bytes_to(
    bytes: ref ByteArray,
    ip: ref IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    @socket.send_bytes_to(bytes, ip, port)
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # See the documentation of `Socket.receive_from` for more information.
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[SocketAddress, Error] {
    @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UdpSocket, Error] {
    @socket.try_clone.map(fn (sock) { UdpSocket(sock) })
  }
}

impl RawSocketOperations for UdpSocket {
  fn mut raw_socket -> Pointer[RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

impl Read for UdpSocket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for UdpSocket {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A TCP socket connected to another TCP socket.
class pub TcpClient {
  # The raw `Socket` wrapped by this `TcpClient`.
  let pub @socket: Socket

  fn static from(socket: Socket) -> Result[TcpClient, Error] {
    try socket.no_delay = true
    Result.Ok(TcpClient(socket))
  }

  # Creates a new `TcpClient` that is connected to the TCP socket at the given
  # IP address and port.
  #
  # This method doesn't enforce a deadline on establishing the connection. If
  # you need to limit the amount of time spent waiting to establish the
  # connection, use `TcpClient.with_timeout` instead.
  #
  # # Examples
  #
  # Connecting a `TcpClient`:
  #
  # ```inko
  # import std.net.socket (TcpClient)
  # import std.net.ip (IpAddress)
  #
  # TcpClient.new(IpAddress.v4(127, 0, 0, 1), port: 40_000).get
  # ```
  fn pub static new(ip: ref IpAddress, port: Int) -> Result[TcpClient, Error] {
    let socket = try Socket.stream(ip.v6?)

    try socket.connect(ip, port)
    from(socket)
  }

  # Creates a new `TcpClient` but limits the amount of time spent waiting for
  # the connection to be established.
  #
  # The `timeout_after` argument specifies the deadline after which the
  # `connect()` times out. The deadline is cleared once connected.
  #
  # See `TcpClient.new` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (TcpClient)
  # import std.net.ip (IpAddress)
  # import std.time (Duration)
  #
  # TcpClient
  #   .with_timeout(
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 40_000,
  #     timeout_after: Duration.from_secs(5)
  #   )
  #   .get
  # ```
  fn pub static with_timeout[T: ToInstant](
    ip: ref IpAddress,
    port: Int,
    timeout_after: ref T,
  ) -> Result[TcpClient, Error] {
    let socket = try Socket.stream(ip.v6?)

    socket.timeout_after = timeout_after
    try socket.connect(ip, port)
    socket.reset_deadline
    from(socket)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `Socket.peer_address` for more information.
  fn pub peer_address -> Result[SocketAddress, Error] {
    @socket.peer_address
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    @socket.shutdown_read
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    @socket.shutdown_write
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    @socket.shutdown
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[TcpClient, Error] {
    @socket.try_clone.map(fn (sock) { TcpClient(sock) })
  }
}

impl RawSocketOperations for TcpClient {
  fn mut raw_socket -> Pointer[RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

impl Read for TcpClient {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for TcpClient {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A TCP socket server that can accept incoming connections.
class pub TcpServer {
  # The raw `Socket` wrapped by this `TcpServer`.
  let pub @socket: Socket

  # Creates a new `TcpServer` bound to and listening on the given IP address
  # and port.
  #
  # A `TcpServer` uses `SO_REUSEADDR` and `SO_REUSEPORT` to allow for fast
  # rebinding of sockets. `SO_REUSEPORT` is only used on platforms that support
  # it.
  #
  # # Examples
  #
  # ```inko
  # import std.net.ip (IpAddress)
  # import std.net.socket (TcpServer)
  #
  # TcpServer.new(IpAddress.v4(0, 0, 0, 0), port: 40_000).get
  # ```
  fn pub static new(ip: ref IpAddress, port: Int) -> Result[TcpServer, Error] {
    let socket = try Socket.stream(ip.v6?)

    try socket.no_delay = true
    try socket.reuse_address = true
    try socket.reuse_port = true
    try socket.bind(ip, port)
    try socket.listen
    Result.Ok(TcpServer(socket))
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  # ```inko
  # import std.net.socket (TcpServer, TcpClient)
  # import std.net.ip (IpAddress)
  #
  # let listener =
  #   TcpServer.new(ip: IpAddress.v4(127, 0, 0, 1), port: 40_000).get
  # let client =
  #   TcpClient.new(ip: IpAddress.v4(127, 0, 0, 1), port: 40_000).get
  #
  # client.write_string('ping')
  #
  # let connection = listener.accept.get
  # let buffer = ByteArray.new
  #
  # connection.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[TcpClient, Error] {
    @socket.accept.then(fn (sock) { TcpClient.from(sock) })
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[TcpServer, Error] {
    @socket.try_clone.map(fn (sock) { TcpServer(sock) })
  }
}

impl RawSocketOperations for TcpServer {
  fn mut raw_socket -> Pointer[RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

# A Unix domain socket address.
class pub UnixAddress {
  # The path or name of the address.
  #
  # This is a `String` since using a `Path` does not make sense for abstract
  # and unnamed addresses.
  let pub @address: String

  # Returns the path of this address.
  #
  # If the address is unnamed or an abstract address, None is returned.
  fn pub to_path -> Option[Path] {
    if unnamed? or abstract? {
      Option.None
    } else {
      Option.Some(@address.to_path)
    }
  }

  # Returns `true` if `self` is an abstract address.
  #
  # # Examples
  #
  # Checking if an address is abstract:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress.new('/tmp/test.sock'.to_path).abstract?    # => false
  # UnixAddress.new("\0example-address".to_path).abstract? # => true
  # ```
  fn pub abstract? -> Bool {
    @address.starts_with?('\0')
  }

  # Returns `true` if `self` is an unnamed address.
  #
  # # Examples
  #
  # Checking if an address is unnamed:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress.new('/tmp/test.sock'.to_path).unnamed? # => false
  # UnixAddress.new(''.to_path).unnamed?               # => true
  # ```
  fn pub unnamed? -> Bool {
    @address.empty?
  }
}

impl Format for UnixAddress {
  fn pub fmt(formatter: mut Formatter) {
    let write = if abstract? {
      '@${@address.slice(start: 1, size: @address.size - 1)}'
    } else if unnamed? {
      'unnamed'
    } else {
      @address
    }

    formatter.write(write)
  }
}

impl Equal[ref UnixAddress] for UnixAddress {
  # Returns `true` if `self` and `other` are the same socket addresses.
  #
  # # Examples
  #
  # Comparing two `UnixAddress` objects:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress.new('a.sock'.to_path) == UnixAddress.new('a.sock'.to_path) # => true
  # UnixAddress.new('a.sock'.to_path) == UnixAddress.new('b.sock'.to_path) # => false
  # ```
  fn pub ==(other: ref UnixAddress) -> Bool {
    @address == other.address
  }
}

impl ToString for UnixAddress {
  # Returns the address name or path as a `String`.
  #
  # # Examples
  #
  # Converting a `UnixAddress` to a `String`:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress.new('/tmp/test.sock'.to_path).to_string # => '/tmp/test.sock'
  # UnixAddress.new("\0example".to_path).to_string      # => "\0example"
  # ```
  fn pub to_string -> String {
    @address
  }
}

# A low-level, non-blocking Unix domain socket.
class pub UnixSocket {
  let @socket: RawSocket

  # A point in time after which socket operations time out.
  #
  # We use an `Int` to remove the need for using `Option[Instant]`.
  let @deadline: Int

  fn static new(type: Int) -> Result[UnixSocket, Error] {
    let sock = RawSocket(
      inner: 0 as Int32,
      registered: 0 as UInt8,
      unix: 1 as UInt8,
    )

    match inko_socket_new(UNIX, type, 0, mut sock) as Int {
      case 0 -> Result.Ok(UnixSocket(socket: sock, deadline: NO_DEADLINE))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns a new `UnixSocket` configured as a stream socket.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # UnixSocket.stream
  # ```
  fn pub static stream -> Result[UnixSocket, Error] {
    UnixSocket.new(STREAM)
  }

  # Returns a new `UnixSocket` configured as a datagram socket.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # UnixSocket.datagram
  # ```
  fn pub static datagram -> Result[UnixSocket, Error] {
    UnixSocket.new(DGRAM)
  }

  # Sets the point in time after which socket operations must time out, known as
  # a "deadline".
  #
  # # Examples
  #
  # Using a `Duration` results in this method calculating the absolute time
  # after which operations time out:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  # import std.time (Duration)
  #
  # let socket = UnixSocket.datagram
  #
  # socket.timeout_after = Duration.from_secs(5)
  # ```
  #
  # We can also use an `Instant`:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  # import std.time (Duration, Instant)
  #
  # let socket = UnixSocket.datagram
  #
  # socket.timeout_after = Instant.new + Duration.from_secs(5)
  # ```
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @deadline = deadline.to_instant.to_int
  }

  # Clears the deadline to apply to socket operations.
  fn pub mut reset_deadline {
    @deadline = NO_DEADLINE
  }

  # Binds this socket to the specified path or abstract address.
  #
  # # Examples
  #
  # Binding a Unix socket to a path:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # ```
  fn pub mut bind(path: ref Path) -> Result[Nil, Error] {
    match inko_socket_bind(@socket, path.to_string, 0) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a Unix socket:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let listener = UnixSocket.stream.get
  # let stream = UnixSocket.stream.get
  #
  # listener.bind('/tmp/test.sock'.to_path).get
  # listener.listen.get
  #
  # stream.connect('/tmp/test.sock').get
  # ```
  fn pub mut connect(path: ref Path) -> Result[Nil, Error] {
    match
      inko_socket_connect(
        _INKO.state,
        _INKO.process,
        @socket,
        path.to_string,
        0,
        @deadline,
      )
    {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.stream.get
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # socket.listen.get
  # ```
  fn pub mut listen -> Result[Nil, Error] {
    match inko_socket_listen(@socket, MAXIMUM_LISTEN_BACKLOG) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let listener = UnixSocket.stream.get
  # let stream = UnixSocket.stream.get
  #
  # listener.bind('/tmp/test.sock'.to_path).get
  # listener.listen.get
  #
  # stream.connect('/tmp/test.sock').get
  # stream.write_string('ping').get
  #
  # let client = listener.accept.get
  # let buffer = ByteArray.new
  #
  # client.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[UnixSocket, Error] {
    let sock = RawSocket(
      inner: 0 as Int32,
      registered: 0 as UInt8,
      unix: 1 as UInt8,
    )

    match
      inko_socket_accept(
        _INKO.state,
        _INKO.process,
        @socket,
        @deadline,
        mut sock,
      )
        as Int
    {
      case 0 -> Result.Ok(UnixSocket(socket: sock, deadline: NO_DEADLINE))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sends a `String` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # socket
  #   .send_string_to(string: 'hello', address: '/tmp/test.sock'.to_path)
  #   .get
  # ```
  fn pub mut send_string_to(
    string: String,
    address: ref Path,
  ) -> Result[Int, Error] {
    let addr = address.to_string

    match
      inko_socket_send_string_to(
        _INKO.state,
        _INKO.process,
        @socket,
        string,
        addr,
        0,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  # let bytes = 'hello'.to_byte_array
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # socket
  #   .send_bytes_to(bytes: bytes, address: '/tmp/test.sock'.to_path)
  #   .get
  # ```
  fn pub mut send_bytes_to(
    bytes: ref ByteArray,
    address: ref Path,
  ) -> Result[Int, Error] {
    let addr = address.to_string

    match
      inko_socket_send_bytes_to(
        _INKO.state,
        _INKO.process,
        @socket,
        bytes,
        addr,
        0,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  # let bytes = ByteArray.new
  #
  # socket.send_string_to('hello', address: '/tmp/test.sock'.to_path).get
  #
  # let received_from = socket.receive_from(bytes: bytes, size: 5).get
  #
  # bytes.to_string         # => 'hello'
  # received_from.to_string # => '/tmp/test.sock'
  # ```
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[UnixAddress, Error] {
    let raw = RawAddress(address: '', port: 0)

    match
      inko_socket_receive_from(
        _INKO.state,
        _INKO.process,
        @socket,
        bytes,
        size,
        @deadline,
        mut raw,
      )
        as Int
    {
      case 0 -> Result.Ok(UnixAddress(raw.address))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns the local address of this socket.
  fn pub local_address -> Result[UnixAddress, Error] {
    let raw = RawAddress(address: '', port: 0)

    match inko_socket_local_address(_INKO.state, @socket, mut raw) as Int {
      case 0 -> Result.Ok(UnixAddress(raw.address))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns the peer address of this socket.
  fn pub peer_address -> Result[UnixAddress, Error] {
    let raw = RawAddress(address: '', port: 0)

    match inko_socket_peer_address(_INKO.state, @socket, mut raw) as Int {
      case 0 -> Result.Ok(UnixAddress(raw.address))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_RCVBUF, value.to_int)
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_SNDBUF, value.to_int)
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    match inko_socket_shutdown_read(@socket) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    match inko_socket_shutdown_write(@socket) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    match inko_socket_shutdown_read_write(@socket) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixSocket, Error] {
    let sock = RawSocket(
      inner: 0 as Int32,
      registered: 0 as UInt8,
      unix: 1 as UInt8,
    )

    match inko_socket_try_clone(@socket, mut sock) as Int {
      case 0 -> Result.Ok(UnixSocket(socket: sock, deadline: NO_DEADLINE))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  fn mut set_option(level: Int, option: Int, value: Int) -> Result[Nil, Error] {
    let val = value as Int32
    let res = setsockopt(
      @socket.inner,
      level as Int32,
      option as Int32,
      (mut val) as Pointer[UInt8],
      4 as Int32,
    )
      as Int

    if res == 0 { Result.Ok(nil) } else { Result.Error(Error.last_os_error) }
  }
}

impl RawSocketOperations for UnixSocket {
  fn mut raw_socket -> Pointer[RawSocket] {
    @socket
  }

  fn raw_deadline -> Int {
    @deadline
  }
}

impl Drop for UnixSocket {
  fn mut drop {
    inko_socket_drop(@socket)
  }
}

impl Read for UnixSocket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    match
      inko_socket_read(
        _INKO.state,
        _INKO.process,
        @socket,
        into,
        size,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl WriteInternal for UnixSocket {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    let state = _INKO.state
    let proc = _INKO.process

    match inko_socket_write(state, proc, @socket, data, size, @deadline) {
      case { @tag = 0, @value = n } -> Result.Ok(n)
      case { @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Write for UnixSocket {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    write_all_internal(bytes.to_pointer, bytes.size)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    write_all_internal(string.to_pointer, string.size)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A Unix datagram socket.
class pub UnixDatagram {
  # The raw `UnixSocket` wrapped by this `UnixDatagram`.
  let pub @socket: UnixSocket

  # Creates a new Unix datagram socket bound to the given address.
  #
  # # Examples
  #
  # Creating a new Unix datagram socket:
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # UnixDatagram.new('/tmp/test.sock'.to_path).get
  # ```
  fn pub static new(address: ref Path) -> Result[UnixDatagram, Error] {
    let socket = try UnixSocket.datagram

    try socket.bind(address)
    Result.Ok(UnixDatagram(socket))
  }

  # Connects `self` to the remote addres.s
  #
  # Connecting a `UnixDatagram` allows sending and receiving data using the
  # methods from `std.io.Read` and `std.io.Write`, instead of having to use
  # `UnixDatagram.receive_from` and `UnixDatagram.send_to`.
  #
  # # Examples
  #
  # Connecting a Unix datagram socket:
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # let socket1 = UnixDatagram.new('/tmp/test1.sock'.to_path).get
  # let socket2 = UnixDatagram.new('/tmp/test2.sock'.to_path).get
  #
  # socket1.connect('/tmp/test2.sock').get
  # ```
  fn pub mut connect(address: ref Path) -> Result[Nil, Error] {
    @socket.connect(address)
  }

  # Sends a `String` to the given address.
  #
  # See the documentation of `UnixSocket.send_string_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # let socket = UnixDatagram.new('/tmp/test.sock'.to_path).get
  #
  # socket
  #   .send_string_to(string: 'hello', address: '/tmp/test.sock'.to_path)
  #   .get
  # ```
  fn pub mut send_string_to(
    string: String,
    address: ref Path,
  ) -> Result[Int, Error] {
    @socket.send_string_to(string, address)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `UnixSocket.send_bytes_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # let socket = UnixDatagram.new('/tmp/test.sock'.to_path).get
  # let bytes = 'hello'.to_byte_array
  #
  # socket
  #   .send_bytes_to(bytes: bytes, address: '/tmp/test.sock'.to_path)
  #   .get
  # ```
  fn pub mut send_bytes_to(
    bytes: ref ByteArray,
    address: ref Path,
  ) -> Result[Int, Error] {
    @socket.send_bytes_to(bytes, address)
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # See the documentation of `UnixSocket.receive_from` for more information.
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[UnixAddress, Error] {
    @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixDatagram, Error] {
    @socket.try_clone.map(fn (sock) { UnixDatagram(sock) })
  }
}

impl RawSocketOperations for UnixDatagram {
  fn mut raw_socket -> Pointer[RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

impl Read for UnixDatagram {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for UnixDatagram {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A Unix stream socket connected to another Unix socket.
class pub UnixClient {
  # The raw `UnixSocket` wrapped by this `UnixClient`.
  let pub @socket: UnixSocket

  # Creates a new `UnixClient` that is connected to the given address.
  #
  # This method doesn't enforce a deadline on establishing the connection. If
  # you need to limit the amount of time spent waiting to establish the
  # connection, use `UnixClient.with_timeout` instead.
  #
  # # Examples
  #
  # Connecting a `UnixClient`:
  #
  # ```inko
  # import std.net.socket (UnixServer, UnixClient)
  #
  # let listener = UnixServer.new('/tmp/test.sock'.to_path).get
  #
  # UnixClient.new('/tmp/test.sock'.to_path).get
  # ```
  fn pub static new(address: ref Path) -> Result[UnixClient, Error] {
    let socket = try UnixSocket.stream

    try socket.connect(address)
    Result.Ok(UnixClient(socket))
  }

  # Creates a new `UnixClient` but limits the amount of time spent waiting for
  # the connection to be established.
  #
  # The `timeout_after` argument specifies the deadline after which the
  # `connect()` times out. The deadline is cleared once connected.
  #
  # See `UnixClient.new` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixClient)
  # import std.time (Duration)
  #
  # UnixClient
  #   .with_timeout(
  #     address: '/tmp/test.sock'
  #     timeout_after: Duration.from_secs(5)
  #   )
  #   .get
  # ```
  fn pub static with_timeout[T: ToInstant](
    address: ref Path,
    timeout_after: ref T,
  ) -> Result[UnixClient, Error] {
    let socket = try UnixSocket.stream

    socket.timeout_after = timeout_after
    try socket.connect(address)
    socket.reset_deadline
    Result.Ok(UnixClient(socket))
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `UnixSocket.peer_address` for more information.
  fn pub peer_address -> Result[UnixAddress, Error] {
    @socket.peer_address
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    @socket.shutdown_read
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    @socket.shutdown_write
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    @socket.shutdown
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixClient, Error] {
    @socket.try_clone.map(fn (sock) { UnixClient(sock) })
  }
}

impl RawSocketOperations for UnixClient {
  fn mut raw_socket -> Pointer[RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

impl Read for UnixClient {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for UnixClient {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A Unix socket server that can accept incoming connections.
class pub UnixServer {
  # The raw `UnixSocket` wrapped by this `UnixServer`.
  let pub @socket: UnixSocket

  # Creates a new `UnixServer` bound to and listening on the given address.
  #
  # The `backlog` argument can be used to set the listen backlog.
  #
  # # Examples
  #
  # Creating a `UnixServer`:
  #
  # ```inko
  # import std.net.socket (UnixServer)
  #
  # UnixServer.new('/tmp/test.sock'.to_path).get
  # ```
  fn pub static new(address: ref Path) -> Result[UnixServer, Error] {
    let socket = try UnixSocket.stream

    try socket.bind(address)
    try socket.listen
    Result.Ok(UnixServer(socket))
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  # ```inko
  # import std.net.socket (UnixServer, UnixClient)
  #
  # let listener = UnixServer.new('/tmp/test.sock'.to_path).get
  # let client = UnixClient.new('/tmp/test.sock'.to_path).get
  #
  # client.write_string('ping')
  #
  # let connection = listener.accept.get
  # let buffer = ByteArray.new
  #
  # connection.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[UnixClient, Error] {
    @socket.accept.map(fn (sock) { UnixClient(sock) })
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixServer, Error] {
    @socket.try_clone.map(fn (sock) { UnixServer(sock) })
  }
}

impl RawSocketOperations for UnixServer {
  fn mut raw_socket -> Pointer[RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}
