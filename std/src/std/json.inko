# Parsing and generating of JSON.
#
# # Parsing JSON
#
# This module provides support for parsing and generating JSON, conforming to
# RFC 8259 (https://www.rfc-editor.org/rfc/rfc8259). Tests were performed
# against the test corpus provided by the article
# https://seriot.ch/projects/parsing_json.html. Extensions such as parsing
# `NaN`, `Infinity`, and comments are not supported.
#
# The easiest way to parse JSON is using `Json.parse`:
#
#     import std.json (Json)
#
#     Json.parse('[10]').get # => Json.Array([Json.Int(10)])
#
# The parser enforces limits on the number of nested objects and the size of
# strings. These limits can be adjusted by using the `Parser` type directly like
# so:
#
#     import std.json (Parser)
#
#     let parser = Parser.new('[10]')
#
#     parser.max_depth = 4
#     parser.max_string_size = 128
#     parser.parse
#
# # Generating JSON
#
# Generating JSON strings is done using `Json.to_string` and
# `Json.to_pretty_string`:
#
#     import std.json (Json)
#
#     Json.Array([Json.Int(1), Json.Int(2)]).to_string # => '[1, 2]'
#
# When using `to_pretty_string`, the default indentation is two spaces per
# indentation level. You can change this value by using the `Generator` type
# directly:
#
#     import std.json (Generator, Json)
#
#     let val = Json.Array([Json.Int(1), Json.Int(2)])
#     let gen = Generator.new(indent: 4)
#
#     gen.generate(val)
#
# This would then produce the following JSON:
#
#     [
#         1,
#         2
#     ]
#
# # Performance
#
# The implementation provided by this module isn't optimised for maximum
# performance or optimal memory usage. Instead this module aims to provide an
# implementation that's good enough for most cases.
import std.cmp (Equal)
import std.fmt (Format as FormatTrait, Formatter)
import std.int (Format)
import std.io (Error as IoError)
import std.iter (Peekable)
import std.set (Set)
import std.string (Bytes, StringBuffer, ToString)
import std.utf8

let BRACKET_OPEN = 0x5B
let BRACKET_CLOSE = 0x5D
let CURLY_OPEN = 0x7B
let CURLY_CLOSE = 0x7D
let DQUOTE = 0x22
let COMMA = 0x2C
let MINUS = 0x2D
let PLUS = 0x2B
let DOT = 0x2E
let COLON = 0x3A
let SLASH = 0x2F
let BSLASH = 0x5C
let SPACE = 0x20
let BS = 0x8
let TAB = 0x9
let LF = 0xA
let CR = 0xD
let FF = 0xC
let ZERO = 0x30
let NINE = 0x39
let LOWER_A = 0x61
let UPPER_A = 0x41
let LOWER_E = 0x65
let UPPER_E = 0x45
let UPPER_F = 0x5a
let LOWER_T = 0x74
let LOWER_F = 0x66
let LOWER_N = 0x6E
let LOWER_B = 0x62
let LOWER_R = 0x72
let LOWER_U = 0x75

# A table mapping bytes that follow a "\", and the types to replace the sequence
# with. A value of `-1` means there's no replacement.
let ESCAPE_TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, DQUOTE, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, SLASH, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, BSLASH,
  -1, -1, -1, -1, -1, BS, -1, -1, -1, FF, -1, -1, -1, -1, -1, -1, -1, LF, -1,
  -1, -1, CR, -1, TAB, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1,
]

# The default amount of spaces to use for indentation when pretty-printing JSON
# objects.
let DEFAULT_PRETTY_INDENT = 2

fn digit?(byte: Int) -> Bool {
  byte >= ZERO and byte <= NINE
}

fn exponent?(byte: Int) -> Bool {
  byte == LOWER_E or byte == UPPER_E
}

fn char(byte: Int) -> String {
  ByteArray.from_array([byte]).into_string
}

# A type describing the different possible errors.
#
# End users don't really care about the difference between
# RecursionLimitExceeded and InvalidSurrogate(...), nor can they really act
# differently based on the kind of error.
class pub enum ErrorKind {
  # The maximum recursion limit is exceeded.
  case RecursionLimitExceeded(Int)

  # An invalid UTF-16 surrogate pair is encountered.
  case InvalidSurrogate(String)

  # A generic error with a custom message.
  case Generic(String)

  # An error occurred while reading from the input stream.
  case Read(IoError)
}

impl Equal[ref ErrorKind] for ErrorKind {
  fn pub ==(other: ref ErrorKind) -> Bool {
    match (self, other) {
      case (RecursionLimitExceeded(a), RecursionLimitExceeded(b)) -> a == b
      case (InvalidSurrogate(a), InvalidSurrogate(b)) -> a == b
      case (Read(a), Read(b)) -> a == b
      case (Generic(a), Generic(b)) -> a == b
      case _ -> false
    }
  }
}

impl FormatTrait for ErrorKind {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case RecursionLimitExceeded(v) -> {
        formatter.tuple('RecursionLimitExceeded').field(v).finish
      }
      case InvalidSurrogate(v) -> {
        formatter.tuple('InvalidSurrogate').field(v).finish
      }
      case Read(v) -> formatter.tuple('Read').field(v).finish
      case Generic(v) -> formatter.tuple('Generic').field(v).finish
    }
  }
}

impl ToString for ErrorKind {
  fn pub to_string -> String {
    match self {
      case RecursionLimitExceeded(v) -> {
        'the maximum recursion depth of ${v} is exceeded'
      }
      case InvalidSurrogate(v) -> "${v} isn't a valid UTF-16 surrogate pair"
      case Read(v) -> v.to_string
      case Generic(v) -> v.to_string
    }
  }
}

# A type describing an error produced while parsing a JSON document.
class pub Error {
  # A value describing the kind of error.
  let pub @kind: ErrorKind

  # The byte offset in the input string at which the error starts.
  #
  # Managing column counts is tricky, as this involves maintaining a grapheme
  # cluster counter, which is complicated and expensive. Instead we report a
  # byte offset (relative to the start of the input), as we need to maintain
  # this anyway.
  #
  # The article at https://www.foonathan.net/2021/02/column/ contains additional
  # information regarding this topic.
  let pub @offset: Int
}

impl Equal[ref Error] for Error {
  fn pub ==(other: ref Error) -> Bool {
    @kind == other.kind and @offset == other.offset
  }
}

impl FormatTrait for Error {
  fn pub fmt(formatter: mut Formatter) {
    formatter
      .object('Error')
      .field('kind', @kind)
      .field('offset', @offset)
      .finish
  }
}

impl ToString for Error {
  fn pub to_string -> String {
    '${@kind}, at byte offset ${@offset}'
  }
}

# A type used to query/fetch data from a JSON value.
#
# Manually extracting values from JSON objects can be cumbersome. Take the
# following JSON for example:
#
#     {
#       "name": "Alice",
#       "address": {
#         "street": "Sesame Street"
#       }
#     }
#
# If we want to get the value of the `street` key, we'd have to write the
# following:
#
#     match json {
#       case Object(root) -> match root.opt('address') {
#         case Some(Object(addr)) -> match addr.opt('street') {
#           case Some(String(v)) -> Option.Some(v)
#           case _ -> Option.None
#         }
#         case _ -> Option.None
#       }
#       case _ -> Option.None
#     }
#
# In contrast, using the `Query` type we can instead write the following:
#
#     json.query.key('address').key('street').as_string
#
# Querying is done using the methods `Query.key` to get an object key's value,
# and `Query.index` to get the value of an array index. Methods such as
# `Query.as_string` and `Query.as_int` are used to extract the final value as a
# certain type, if such a value is present.
class pub Query {
  let @value: Option[ref Json]

  # Returns a `Query` that matches the value assigned to the object key `name`,
  # if the current value the query matches against is an object.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     let map = Map.new
  #
  #     map.set('name', 'Alice')
  #     Json.Object(map).query.key('name').as_string # => Option.Some('alice')
  #     Json.Int(42).query.key('name').as_string     # => Option.None
  fn pub move key(name: String) -> Query {
    @value = match ref @value {
      case Some(Object(v)) -> v.opt(name)
      case _ -> Option.None
    }

    self
  }

  # Returns a `Query` that matches the value assigned to the array index
  # `index`, if the current value the query matches against is an array.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     Json.Array([Json.Int(10)]).query.index(0).as_int # => Option.Some(10)
  #     Json.Int(42).query.index(0).as_int               # => Option.None
  fn pub move index(index: Int) -> Query {
    @value = match ref @value {
      case Some(Array(v)) -> v.opt(index)
      case _ -> Option.None
    }

    self
  }

  # Returns the value `self` matches against if it's a `Bool`.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     Json.String('test').query.as_bool # => Option.None
  #     Json.Bool(true).query.as_bool     # => Option.Some(true)
  fn pub move as_bool -> Option[Bool] {
    match @value {
      case Some(Bool(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's a `String`.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     Json.Int(42).query.as_string        # => Option.None
  #     Json.String('test').query.as_string # => Option.Some('test')
  fn pub move as_string -> Option[String] {
    match @value {
      case Some(String(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's an `Int`.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     Json.String('test').query.as_int # => Option.None
  #     Json.Int(42).query.as_int        # => Option.Some(42)
  fn pub move as_int -> Option[Int] {
    match @value {
      case Some(Int(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's a `Float`.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     Json.String('test').query.as_float # => Option.None
  #     Json.Float(42.0).query.as_float    # => Option.Some(42.0)
  fn pub move as_float -> Option[Float] {
    match @value {
      case Some(Float(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's an `Object`.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     let map = Map.new
  #
  #     map.set('name', 'Alice')
  #     Json.Object(map).query.as_object # => Option.Some(...)
  #     Json.Int(42).query.as_object     # => Option.None
  fn pub move as_object -> Option[ref Map[String, Json]] {
    match @value {
      case Some(Object(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's an `Array`.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     Json.Array([Json.Int(42)]).query.as_array # => Option.Some(...)
  #     Json.Int(42).query.as_array               # => Option.None
  fn pub move as_array -> Option[ref Array[Json]] {
    match @value {
      case Some(Array(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }
}

# A JSON value, such as `true` or an array.
class pub enum Json {
  case Int(Int)
  case Float(Float)
  case String(String)
  case Array(Array[Json])
  case Object(Map[String, Json])
  case Bool(Bool)
  case Null

  # Parses a `Bytes` into a JSON object.
  #
  # # Examples
  #
  # Parsing a `String`:
  #
  #     import std.json (Json)
  #
  #     Json.parse('[10]') # => Result.Ok(Json.Array([Json.Int(10)]))
  #
  # Parsing a `ByteArray`:
  #
  #     import std.json (Json)
  #
  #     Json.parse('[10]'.to_byte_array) # => Result.Ok(Json.Array([Json.Int(10)]))
  fn pub static parse[T: Bytes](bytes: ref T) -> Result[Json, Error] {
    Parser.new(bytes).parse
  }

  # Formats `self` as a JSON string using indentation for nested objects.
  #
  # This method uses two spaces per indentation. To customise the amount of
  # spaces you'll need to use the `Generator` type directly.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     Json.Int(42).to_pretty_string               # => '42'
  #     Json.Array([Json.Int(42)]).to_pretty_string # => "[\n  42\n]"
  fn pub to_pretty_string -> String {
    Generator.new(DEFAULT_PRETTY_INDENT).generate(self)
  }

  # Returns a new `Query` that starts at `self`.
  #
  # See the documentation of the `Query` type for more information.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     Json.Int(42).query.as_int # => Option.Some(42)
  fn pub query -> Query {
    Query(Option.Some(self))
  }
}

impl ToString for Json {
  # Formats `self` as a JSON string.
  #
  # # Examples
  #
  #     import std.json (Json)
  #
  #     Json.Int(42).to_string               # => '42'
  #     Json.Array([Json.Int(42)]).to_string # => '[42]'
  fn pub to_string -> String {
    Generator.new(0).generate(self)
  }
}

impl FormatTrait for Json {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Int(val) -> formatter.tuple('Int').field(val).finish
      case Float(val) -> formatter.tuple('Float').field(val).finish
      case String(val) -> formatter.tuple('String').field(val).finish
      case Array(val) -> formatter.tuple('Array').field(val).finish
      case Object(val) -> formatter.tuple('Object').field(val).finish
      case Bool(val) -> formatter.tuple('Bool').field(val).finish
      case Null -> formatter.tuple('Null').finish
    }
  }
}

impl Equal[ref Json] for Json {
  fn pub ==(other: ref Json) -> Bool {
    match self {
      case Int(lhs) -> {
        match other {
          case Int(rhs) -> lhs == rhs
          case _ -> false
        }
      }
      case Float(lhs) -> {
        match other {
          case Float(rhs) -> lhs == rhs
          case _ -> false
        }
      }
      case String(lhs) -> {
        match other {
          case String(rhs) -> lhs == rhs
          case _ -> false
        }
      }
      case Array(lhs) -> {
        match other {
          case Array(rhs) -> lhs == rhs
          case _ -> false
        }
      }
      case Object(lhs) -> {
        match other {
          case Object(rhs) -> lhs == rhs
          case _ -> false
        }
      }
      case Bool(lhs) -> {
        match other {
          case Bool(rhs) -> lhs == rhs
          case _ -> false
        }
      }
      case Null -> {
        match other {
          case Null -> true
          case _ -> false
        }
      }
    }
  }
}

# A numeric value that's either an `Int` or a `Float`.
class pub enum Number {
  case Int(Int)
  case Float(Float)
}

impl Equal[ref Number] for Number {
  fn pub ==(other: ref Number) -> Bool {
    match (self, other) {
      case (Int(a), Int(b)) -> a == b
      case (Float(a), Float(b)) -> a == b
      case _ -> false
    }
  }
}

impl FormatTrait for Number {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Int(v) -> formatter.tuple('Int').field(v).finish
      case Float(v) -> formatter.tuple('Float').field(v).finish
    }
  }
}

# A type describing what kind of value is located at the current position in an
# input stream.
class pub enum Type {
  case Array
  case Bool
  case Null
  case Number
  case Object
  case String
}

impl Equal[ref Type] for Type {
  fn pub ==(other: ref Type) -> Bool {
    match (self, other) {
      case (Array, Array) -> true
      case (Bool, Bool) -> true
      case (Null, Null) -> true
      case (Number, Number) -> true
      case (Object, Object) -> true
      case (String, String) -> true
      case _ -> false
    }
  }
}

impl FormatTrait for Type {
  fn pub fmt(formatter: mut Formatter) {
    let name = match self {
      case Array -> 'Array'
      case Bool -> 'Bool'
      case Null -> 'Null'
      case Number -> 'Number'
      case Object -> 'Object'
      case String -> 'String'
    }

    formatter.tuple(name).finish
  }
}

# A pull parser for turning a stream of bytes into JSON values.
#
# Using a `PullParser` you can parse a JSON document into a desired set of
# values, without the need for any intermediate `Json` values. For example,
# parsing an array of integers is done as follows:
#
#     import std.json (PullParser)
#
#     let parser = PullParser.new('[10, 20]')
#     let values = []
#
#     parser.values(fn { Result.Ok(values.push(try parser.int)) }).get
#     values # => [10, 20]
#
# For objects one _can_ use the low-level method `PullParser.keys`, but it's
# recommended to use `PullParser.object` when the names of the keys are known at
# compile-time. For example:
#
#     import std.json (PullParser)
#
#     class Person {
#       let @name: String
#       let @age: Int
#     }
#
#     let parser = PullParser.new('{ "name": "Alice", "age": 42 }')
#     let person = Person(name: '', age: 0)
#
#     parser
#       .object
#       .string('name', fn (v) { person.name = name })
#       .int('age', fn (v) { person.age = v })
#       .parse
#       .get
class pub PullParser {
  let @input: Peekable[Int]
  let @offset: Int
  let @buffer: ByteArray

  # Returns a new parser that parses the given `Bytes` value.
  fn pub static new[T: Bytes](input: ref T) -> PullParser {
    PullParser(input: input.bytes.peekable, offset: -1, buffer: ByteArray.new)
  }

  # Returns a `Type` describing what type of value is located at the current
  # offset.
  fn pub mut value_type -> Result[Type, Error] {
    let typ = match try peek {
      case Some(MINUS) -> Type.Number
      case Some(BRACKET_OPEN) -> Type.Array
      case Some(CURLY_OPEN) -> Type.Object
      case Some(LOWER_T or LOWER_F) -> Type.Bool
      case Some(LOWER_N) -> Type.Null
      case Some(DQUOTE) -> Type.String
      case Some(byte) if digit?(byte) -> Type.Number
      # This is to take care of any random garbage that may be included in the
      # JSON document, including Unicode BOMs. This also saves us from having to
      # explicitly check for all the different BOMs.
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    Result.Ok(typ)
  }

  # Recursively parses but ignores the current value.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     PullParser.new('[10, 20]').skip # => Result.Ok(nil)
  fn pub mut skip -> Result[Nil, Error] {
    match value_type {
      case Ok(Number) -> {
        number
        nil
      }
      case Ok(Array) -> values(fn { skip })
      case Ok(Object) -> keys(fn (_) { skip })
      case Ok(String) -> string
      case Ok(Null) -> null
      case Ok(Bool) -> bool
      case Error(e) -> throw e
    }

    Result.Ok(nil)
  }

  # Parses an array, calling the `value` closure for every value in the array.
  #
  # It's expected that the `value` closure advances the parser by parsing the
  # value in it's desired format.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     let parser = PullParser.new('[10, 20]')
  #     let values = []
  #
  #     parser
  #       .values(fn {
  #         values.push(parser.int.get)
  #         Result.Ok(nil)
  #       })
  #       .get
  #
  #     values # => [10, 20]
  fn pub mut values(value: fn -> Result[Nil, Error]) -> Result[Nil, Error] {
    try expect(BRACKET_OPEN, skip_whitespace: true)

    loop {
      match try peek {
        case Some(BRACKET_CLOSE) -> {
          try advance
          break
        }
        case Some(_) -> {
          try value.call
          try separator(BRACKET_CLOSE)
        }
        case _ -> throw missing_input
      }
    }

    Result.Ok(nil)
  }

  # Parses an object, calling `value` for each key and passing it the name of
  # the key.
  #
  # It's expected that the `value` closure advances the parser by parsing the
  # value in it's desired format.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     class Person {
  #       let @name: String
  #       let @age: Int
  #     }
  #
  #     let parser = PullParser.new('{ "name": "Alice", "age": 42 }')
  #     let person = Person(name: '', age: 0)
  #
  #     parser
  #       .keys(fn (key) {
  #         match key {
  #           case 'name' -> person.name = parser.string.get
  #           case 'age' -> person.age = parser.int.get
  #           case _ -> {}
  #         }
  #
  #         Result.Ok(nil)
  #       })
  #       .get
  #
  #     person.name # => 'Alice'
  #     person.age  # => 42
  fn pub mut keys(
    value: fn (String) -> Result[Nil, Error],
  ) -> Result[Nil, Error] {
    try expect(CURLY_OPEN, skip_whitespace: true)

    loop {
      match try peek {
        case Some(CURLY_CLOSE) -> {
          advance
          break
        }
        case Some(DQUOTE) -> {
          let key = try string

          try expect(COLON, skip_whitespace: true)
          try value.call(key)
          try separator(CURLY_CLOSE)
        }
        case Some(byte) -> throw unexpected(byte)
        case _ -> throw missing_input
      }
    }

    Result.Ok(nil)
  }

  # Returns an `ObjectParser` for parsing an object with a known set of keys.
  #
  # For more information, refer to the various methods of the `ObjectParser`
  # type.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     class Person {
  #       let @name: String
  #     }
  #
  #     let parser = PullParser.new('{ "name": "String" }')
  #     let person = Person(name: '')
  #
  #     parser.object.string('name', fn (v) { person.name = v }).parse.get
  fn pub mut object -> ObjectParser {
    ObjectParser.new(self)
  }

  # Parses the boolean value `true` or `false`.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     PullParser.new('true').bool # => Result.Ok(true)
  fn pub mut bool -> Result[Bool, Error] {
    match try peek {
      case Some(LOWER_T) -> {
        advance
        identifier('rue').map(fn (_) { true })
      }
      case Some(LOWER_F) -> {
        advance
        identifier('alse').map(fn (_) { false })
      }
      case Some(v) -> throw unexpected(v)
      case _ -> throw missing_input
    }
  }

  # Parses a `null` value.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     PullParser.new('null').null # => Result.Ok(nil)
  fn pub mut null -> Result[Nil, Error] {
    identifier('null')
  }

  # Parses a string.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     PullParser.new('"hello"').string # => Result.Ok('hello')
  fn pub mut string -> Result[String, Error] {
    match try peek {
      case Some(DQUOTE) -> try advance
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    loop {
      match try advance {
        case Some(BSLASH) -> {
          match try advance {
            case Some(LOWER_U) -> try escaped_unicode
            case Some(byte) -> {
              match ESCAPE_TABLE.get(byte) {
                case -1 -> throw unexpected(byte)
                case val -> @buffer.push(val)
              }
            }
            case _ -> throw missing_input
          }
        }
        case Some(DQUOTE) -> break
        case Some(val) if val >= 0x0 and val <= 0x001F -> {
          throw generic_error(
            'control characters in the range 0x0..0x001F must be escaped',
          )
        }
        case Some(byte) -> @buffer.push(byte)
        case _ -> throw missing_input
      }
    }

    Result.Ok(@buffer.drain_to_string)
  }

  fn mut escaped_unicode -> Result[Nil, Error] {
    let high = try codepoint

    if utf8.encode_scalar(high, @buffer) > 0 { return Result.Ok(nil) }

    # At this point the codepoint is either straight up invalid (e.g. "\uZZZZ"),
    # or it's a UTF-16 surrogate.
    if utf8.surrogate?(high).false? {
      throw error(ErrorKind.InvalidSurrogate(high.format(Format.Hex)))
    }

    try expect(BSLASH, skip_whitespace: false)
    try expect(LOWER_U, skip_whitespace: false)

    let low = try codepoint

    if utf8.surrogate?(low) {
      let codepoint = utf8.codepoint_from_surrogates(high, low)

      # The encoding may fail for pairs such as "\uDFFF\uDFFF".
      if utf8.encode_scalar(codepoint, @buffer) > 0 { return Result.Ok(nil) }
    }

    let pair = '\\u${high.format(Format.Hex)}\\u${low.format(Format.Hex)}'

    throw error(ErrorKind.InvalidSurrogate(pair))
  }

  fn mut codepoint -> Result[Int, Error] {
    let mut num = 0
    let mut idx = 0

    while idx < 4 {
      let digit = match try advance {
        case Some(byte) -> {
          if byte >= ZERO and byte <= NINE {
            byte - ZERO
          } else if byte >= LOWER_A and byte <= LOWER_F {
            byte - LOWER_A + 10
          } else if byte >= UPPER_A and byte <= UPPER_F {
            byte - UPPER_A + 10
          } else {
            throw unexpected(byte)
          }
        }
        case _ -> throw missing_input
      }

      num = num * 16 + digit
      idx += 1
    }

    Result.Ok(num)
  }

  # Parses a number as an `Int`.
  #
  # If the value in the input stream is in fact a float (e.g. `1.2` instead of
  # just `1`), it's first pased as a `Float` and then cast to an `Int`.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     Parser.new('10').int  # => Result.Ok(10)
  #     Parser.new('1.2').int # => Result.Ok(1)
  fn pub mut int -> Result[Int, Error] {
    match number {
      case Ok(Int(v)) -> Result.Ok(v)
      case Ok(Float(v)) -> Result.Ok(v.to_int)
      case Error(e) -> Result.Error(e)
    }
  }

  # Parses a number as a `Float`.
  #
  # If the value in the input stream is in fact an integer (e.g. `1` instead of
  # `1.0` or `1.2`), the value is first parsed as an `Int` and then cast to a
  # `Float`.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     Parser.new('1.2').float # => Result.Ok(1.2)
  #     Parser.new('1').float   # => Result.Ok(1.0)
  fn pub mut float -> Result[Float, Error] {
    match number {
      case Ok(Int(v)) -> Result.Ok(v.to_float)
      case Ok(Float(v)) -> Result.Ok(v)
      case Error(e) -> Result.Error(e)
    }
  }

  # Parses a number into a `Number` value.
  #
  # A `Number` is a wrapper enum around either a `Float` or an `Int`. If you
  # only care about numbers in a particular format (e.g. integers), use
  # `PullParser.int` or `PullParser.float` instead.
  #
  # # Examples
  #
  #     import std.json (PullParser)
  #
  #     Parser.new('1.2').number # => Result.Ok(Number.Float(1.2))
  #     Parser.new('1').number   # => Result.Ok(Number.Int(1))
  fn pub mut number -> Result[Number, Error] {
    match try peek {
      case Some(MINUS) -> {
        try advance_and_buffer

        match try peek_next {
          case Some(byte) if digit?(byte) -> {}
          case Some(byte) -> throw unexpected(byte)
          case _ -> throw missing_input
        }
      }
      case Some(byte) if digit?(byte) -> {}
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    # Numbers such as 001, 010, 01.0, etc are invalid.
    match try peek_next {
      case Some(ZERO) -> {
        try advance_and_buffer

        match try peek_next {
          case Some(byte) if digit?(byte) -> throw unexpected(byte)
          case _ -> {}
        }
      }
      case _ -> {}
    }

    try buffer_digits

    match try peek_next {
      # Examples: 1.2, 1.2e1, 1.2e+1
      case Some(DOT) -> {
        try advance_and_buffer

        match try peek_next {
          case Some(byte) if digit?(byte) -> {}
          case Some(byte) -> throw unexpected(byte)
          case _ -> throw missing_input
        }

        try buffer_digits

        match try peek_next {
          case Some(byte) if exponent?(byte) -> try exponent
          case _ -> {}
        }
      }
      # Example: 1E4
      case Some(byte) if exponent?(byte) -> try exponent
      # Example: 123
      #
      # If the number is too big to fit in an Int, we'll promote it to a Float.
      case _ -> {
        match Int.parse(@buffer, Format.Decimal) {
          case Some(val) -> {
            @buffer.clear
            return Result.Ok(Number.Int(val))
          }
          case _ -> {}
        }
      }
    }

    # At this point we've already validated the input format, and it's
    # compatible with the underlying float parser, so no extra checks are
    # needed.
    let res = Result.Ok(Number.Float(Float.parse(@buffer).get))

    @buffer.clear
    res
  }

  fn mut exponent -> Result[Nil, Error] {
    try advance_and_buffer

    match try peek_next {
      case Some(MINUS or PLUS) -> {
        try advance_and_buffer
        nil
      }
      case _ -> {}
    }

    match try peek_next {
      case Some(byte) if digit?(byte) -> {}
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    try buffer_digits
    Result.Ok(nil)
  }

  fn mut buffer_digits -> Result[Nil, Error] {
    loop {
      match try peek_next {
        case Some(byte) if digit?(byte) -> {
          try advance
          @buffer.push(byte)
        }
        case _ -> return Result.Ok(nil)
      }
    }
  }

  fn mut advance_and_buffer -> Result[Option[Int], Error] {
    match try advance {
      case Some(val) -> {
        @buffer.push(val)
        Result.Ok(Option.Some(val))
      }
      case _ -> Result.Ok(Option.None)
    }
  }

  fn mut advance -> Result[Option[Int], Error] {
    match @input.next {
      case Some(v) -> {
        @offset += 1
        Result.Ok(Option.Some(v))
      }
      case _ -> Result.Ok(Option.None)
    }
  }

  fn mut expect(byte: Int, skip_whitespace: Bool) -> Result[Nil, Error] {
    if skip_whitespace { try self.skip_whitespace }

    match try advance {
      case Some(val) if val == byte -> Result.Ok(nil)
      case Some(val) -> {
        let exp = char(byte)
        let got = char(val)

        throw generic_error(
          "the character '${exp}' is expected but '${got}' was found instead",
        )
      }
      case _ -> throw missing_input
    }
  }

  fn mut peek_next -> Result[Option[Int], Error] {
    Result.Ok(@input.peek)
  }

  fn mut peek -> Result[Option[Int], Error] {
    loop {
      match peek_next {
        case Ok(Some(SPACE or CR or TAB or LF)) -> advance
        case Ok(Some(byte)) -> return Result.Ok(Option.Some(byte))
        case Ok(None) -> return Result.Ok(Option.None)
        case Error(e) -> throw e
      }
    }
  }

  fn mut identifier(name: String) -> Result[Nil, Error] {
    try skip_whitespace

    let mut index = 0
    let max = name.size

    while index < max {
      try expect(name.byte(index := index + 1), skip_whitespace: false)
    }

    Result.Ok(nil)
  }

  fn mut skip_whitespace -> Result[Nil, Error] {
    loop {
      match try peek_next {
        case Some(SPACE or CR or TAB or LF) -> try advance
        case _ -> return Result.Ok(nil)
      }
    }
  }

  fn mut separator(closing: Int) -> Result[Nil, Error] {
    match try peek {
      case Some(byte) if byte == closing -> return Result.Ok(nil)
      case Some(COMMA) -> try advance
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    match try peek {
      case Some(byte) if byte == closing -> throw unexpected(byte)
      case _ -> Result.Ok(nil)
    }
  }

  fn unexpected(byte: Int) -> Error {
    generic_error("the character '${char(byte)}' is unexpected")
  }

  fn missing_input -> Error {
    generic_error('all input is consumed but more input is expected')
  }

  fn generic_error(message: String) -> Error {
    error(ErrorKind.Generic(message))
  }

  fn error(kind: ErrorKind) -> Error {
    Error(kind, offset: @offset)
  }
}

# A type for parsing an object with a known set of keys.
class pub ObjectParser {
  # The parser this `ObjectParser` instance uses to process input.
  let pub @parser: mut PullParser

  # The keys to parse along with the closures that parse their values.
  let @keys: Map[String, fn -> Result[Nil, Error]]

  # Returns a new `ObjectParser` that uses the given `PullParser` to parse an
  # input stream.
  fn static new(parser: mut PullParser) -> ObjectParser {
    ObjectParser(parser, keys: Map.new)
  }

  # Parses the key `name` as a custom value.
  #
  # It's expected that the `value` closure parses the value, advancing the
  # parser in the process.
  fn pub mut key(
    name: String,
    value: fn -> Result[Nil, Error],
  ) -> mut ObjectParser {
    @keys.set(name, value)
    self
  }

  # Parses the key `name` as a `String`, passing the parsed value to the `value`
  # closure.
  fn pub mut string(name: String, value: fn (String)) -> mut ObjectParser {
    key(name, fn move { @parser.string.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as an `Int`, passing the parsed value to the `value`
  # closure.
  fn pub mut int(name: String, value: fn (Int)) -> mut ObjectParser {
    key(name, fn move { @parser.int.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as a `Float`, passing the parsed value to the `value`
  # closure.
  fn pub mut float(name: String, value: fn (Float)) -> mut ObjectParser {
    key(name, fn move { @parser.float.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as a `Bool`, passing the parsed value to the `value`
  # closure.
  fn pub mut bool(name: String, value: fn (Bool)) -> mut ObjectParser {
    key(name, fn move { @parser.bool.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as an object without a known structure, passing each
  # key to the `value` closure. It's expected that the `value` closure parses
  # the value, advancing the parser in the process.
  fn pub mut keys(
    name: String,
    value: fn (String) -> Result[Nil, Error],
  ) -> mut ObjectParser {
    key(name, fn move { @parser.keys(fn (key) { value.call(key) }) })
  }

  # Parses the key `name` as an array of arbitrary values, using the `value`
  # closure to parse the values and advance the parser.
  fn pub mut values(
    name: String,
    value: fn -> Result[Nil, Error],
  ) -> mut ObjectParser {
    key(name, fn move { @parser.values(fn { value.call }) })
  }

  # Parses the key `name` as an array of strings, passing each `String` to the
  # `value` closure.
  fn pub mut strings(name: String, value: fn (String)) -> mut ObjectParser {
    values(name, fn move { @parser.string.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as an array of integers, passing each `Int` to the
  # `value` closure.
  fn pub mut ints(name: String, value: fn (Int)) -> mut ObjectParser {
    values(name, fn move { @parser.int.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as an array of integers, passing each `Int` to the
  # `value` closure.
  fn pub mut floats(name: String, value: fn (Float)) -> mut ObjectParser {
    values(name, fn move { @parser.float.map(fn (v) { value.call(v) }) })
  }

  # Parses the current object according to the rules in `self`.
  #
  # When encountering a key for which no rule is defined, its value is
  # (recursively) skipped.
  fn pub mut parse -> Result[Nil, Error] {
    # We need to skip any leading whitespace such that the offset points to the
    # "{" and not any whitespace before it.
    # try @parser.skip_whitespace
    #
    # let start = @parser.offset

    @parser.keys(fn (key) {
      match @keys.opt_mut(key) {
        case Some(func) -> func.call
        case _ -> @parser.skip
      }
    })
  }

  # Parses the current object according to the rules in `self`, while requiring
  # the given keys to be present.
  #
  # This method returns a `Result.Error` for the first missing key that it
  # encounters.
  fn pub mut require(keys: ref Array[String]) -> Result[Nil, Error] {
    let mut found = Set.new

    try @parser.keys(fn (key) {
      match @keys.opt_mut(key) {
        case Some(func) -> {
          found.insert(key)
          func.call
        }
        case _ -> @parser.skip
      }
    })

    keys.iter.try_each(fn (key) {
      if found.contains?(key) {
        Result.Ok(nil)
      } else {
        let pos = @parser.offset

        Result.Error(
          Error(ErrorKind.Generic('the key "${key}" is required'), pos),
        )
      }
    })
  }

  # Parses the current object according to the rules in `self`, and requires all
  # keys to be present.
  #
  # See `ObjectParser.require` and `ObjectParser.parse` for more details.
  fn pub mut require_all -> Result[Nil, Error] {
    require(@keys.keys.to_array)
  }
}

# A DOM parser for turning a stream of bytes into a JSON document.
#
# This parser only supports parsing `ByteArray` values as input. If you need to
# parse very large documents, it's best to separate the objects on a per line
# basis, then parse the document one line at a time.
#
# # Nested arrays and objects
#
# This parser enforces a limit on the number of nested arrays and objects. The
# default is sufficiently large that most documents won't result in an error
# being thrown. This limit is controlled by the field `Parser.max_depth`.
class pub Parser {
  let @pull: PullParser
  let @depth: Int

  # The maximum number of nested values.
  #
  # When parsing an array or object that exceeds this depth, an error is thrown.
  let pub @max_depth: Int

  # Returns a new parser that will parse the given `Bytes` value.
  fn pub static new[T: Bytes](input: ref T) -> Parser {
    Parser(PullParser.new(input), depth: 0, max_depth: 100)
  }

  # Parses the input into a JSON object.
  #
  # If the input is invalid JSON, this method throws an `Error`.
  #
  # # Examples
  #
  #     import std.json (Parser)
  #
  #     let parser = Parser.new('[10, 20]')
  #
  #     parser.parse.get # => Json.Array([Json.Int(10), Json.Int(20)])
  fn pub move parse -> Result[Json, Error] {
    let result = try value

    # Only trailing whitespace is allowed.
    match try @pull.peek {
      case Some(val) -> throw @pull.unexpected(val)
      case _ -> {}
    }

    Result.Ok(result)
  }

  fn mut value -> Result[Json, Error] {
    match try @pull.value_type {
      case Number -> number
      case Array -> array
      case Object -> object
      case Bool -> bool
      case Null -> null
      case String -> string
    }
  }

  fn mut string -> Result[Json, Error] {
    @pull.string.map(fn (val) { Json.String(val) })
  }

  fn mut bool -> Result[Json, Error] {
    @pull.bool.map(fn (v) { Json.Bool(v) })
  }

  fn mut null -> Result[Json, Error] {
    @pull.null.map(fn (_) { Json.Null })
  }

  fn mut array -> Result[Json, Error] {
    try check_depth

    let values = []

    @depth += 1
    try @pull.values(fn { Result.Ok(values.push(try value)) })
    @depth -= 1
    Result.Ok(Json.Array(values))
  }

  fn mut object -> Result[Json, Error] {
    try check_depth

    let map = Map.new

    @depth += 1
    try @pull.keys(fn (k) {
      map.set(k, try value)
      Result.Ok(nil)
    })
    @depth -= 1
    Result.Ok(Json.Object(map))
  }

  fn mut number -> Result[Json, Error] {
    match @pull.number {
      case Ok(Int(v)) -> Result.Ok(Json.Int(v))
      case Ok(Float(v)) -> Result.Ok(Json.Float(v))
      case Error(e) -> Result.Error(e)
    }
  }

  fn check_depth -> Result[Nil, Error] {
    if @depth < @max_depth {
      Result.Ok(nil)
    } else {
      Result.Error(@pull.error(ErrorKind.RecursionLimitExceeded(@max_depth)))
    }
  }
}

# A type for turning a `Json` value into a JSON string.
#
# This type is used by `Json.to_string` and `Json.to_pretty_string`. Unless you
# want to use custom indentation, it's recommended to use these methods instead
# of using `Generator` directly.
class pub Generator {
  let @pretty: Bool
  let @spaces: String
  let @depth: Int
  let @buffer: StringBuffer

  # Returns a new `Generator` using the given indentation level.
  #
  # The `indent` argument specifies the number of spaces to use per indentation
  # level. If this value is less than or equal to zero, no indentation is
  # applied.
  fn pub static new(indent: Int) -> Generator {
    Generator(
      pretty: indent > 0,
      spaces: ' '.repeat(indent),
      depth: 0,
      buffer: StringBuffer.new,
    )
  }

  # Generates a JSON string for the given `Json` value.
  #
  # # Examples
  #
  #     import std.json (Generator)
  #
  #     Generator.new(indent: 2).generate(Json.Array([Json.Int(1)])) # => '[1]'
  fn pub mut generate(value: ref Json) -> String {
    generate_value(value)
    @buffer.to_string
  }

  fn mut generate_value(value: ref Json) {
    match value {
      case Int(val) -> @buffer.push(val.to_string)
      case Float(val) -> @buffer.push(val.to_string)
      case String(val) -> {
        @buffer.push('"')
        @buffer.push(val.escaped)
        @buffer.push('"')
      }
      case Array(vals) -> {
        @buffer.push('[')

        if vals.size > 0 {
          enter(fn {
            vals.iter.each_with_index(fn (index, val) {
              if index > 0 { separator }

              indent
              generate_value(val)
            })
          })
        }

        indent
        @buffer.push(']')
      }
      case Object(vals) -> {
        @buffer.push('{')

        if vals.size > 0 {
          enter(fn {
            vals.iter.each_with_index(fn (index, pair) {
              if index > 0 { separator }

              indent
              @buffer.push('"')
              @buffer.push(pair.key.escaped)
              @buffer.push('": ')
              generate_value(pair.value)
            })
          })
        }

        indent
        @buffer.push('}')
      }
      case Bool(val) -> @buffer.push(val.to_string)
      case Null -> @buffer.push('null')
    }
  }

  fn mut enter(block: fn) {
    newline
    @depth += 1
    block.call
    @depth -= 1
    newline
  }

  fn mut indent {
    if @pretty { @depth.times(fn (_) { @buffer.push(@spaces) }) }
  }

  fn mut newline {
    if @pretty { @buffer.push('\n') }
  }

  fn mut separator {
    @buffer.push(if @pretty { ',\n' } else { ', ' })
  }
}
