# The Int type.
import std.clone.Clone
import std.cmp.(Compare, Equal, Ordering)
import std.float.ToFloat
import std.fmt.(Format, Formatter)
import std.hash.(Hash, Hasher)
import std.ops.(
  Add, BitAnd, BitOr, BitXor, Divide, Modulo, Multiply, Power,
  ShiftLeft, ShiftRight, Subtract, UnsignedShiftRight
)
import std.range.(ExclusiveRange, InclusiveRange)
import std.string.(ToString, StringBuffer)

# A type that can be converted to a Int.
trait pub ToInt {
  # Converts `self` to a `Int`
  fn pub to_int -> Int
}

# The minimum value an `Int` can represent.
let pub MIN = -9_223_372_036_854_775_808

# The maximum value an `Int` can represent.
let pub MAX = 9_223_372_036_854_775_807

let BITS = 64

class extern IntResult {
  let @tag: Int
  let @value: Int
}

# The type returned by checked integer builtin functions, such as
# `int_checked_add()`.
#
# This is the `{i64, i1}` type returned by the LLVM checked arithmetic
# intrinsics, and must match its layout.
class builtin CheckedIntResult {
  let @value: Int64
  let @tag: Int8
}

fn extern inko_string_to_int(
  state: Pointer[Int8],
  process: Pointer[Int8],
  bytes: Pointer[Int8],
  size: Int,
  radix: Int,
) -> IntResult

fn extern inko_int_checked_pow(left: Int, right: Int) -> CheckedIntResult
fn extern inko_int_to_string(state: Pointer[Int8], value: Int) -> String

fn overflow(left: Int, op: String, right: Int) -> Never {
  panic("'{left} {op} {right}' overflowed")
}

# A 64-bits signed integer type.
#
# `Int` values can represent values in the range
# `-9223372036854775808 <= value <= 9223372036854775807`.
#
# # Panics
#
# Integer operations that would result in an overflow produce a panic.
class builtin Int {
  # Parses an `Int` from a `String`, using base 2.
  #
  # The `String` may start with `+` or `-`. Leading and/or trailing whitespace
  # is considered invalid.
  #
  # # Examples
  #
  #     Int.from_base2('11') # => Option.Some(3)
  #     Int.from_base2('ff') # => Option.None
  fn pub static from_base2(string: String) -> Option[Int] {
    match inko_string_to_int(
      _INKO.state, _INKO.process, string.to_pointer, string.size, 2
    ) {
      case { @tag = 0, @value = v } -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Parses an `Int` from a `String`, using base 10.
  #
  # The `String` may start with `+` or `-`. Leading and/or trailing whitespace
  # is considered invalid.
  #
  # # Examples
  #
  #     Int.from_base10('12') # => Option.Some(12)
  #     Int.from_base10('ff') # => Option.None
  fn pub static from_base10(string: String) -> Option[Int] {
    match inko_string_to_int(
      _INKO.state, _INKO.process, string.to_pointer, string.size, 10
    ) {
      case { @tag = 0, @value = v } -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Parses an `Int` from a `String`, using base 16.
  #
  # The `String` may start with `+` or `-`. Leading and/or trailing whitespace
  # is considered invalid.
  #
  # This method doesn't remove the usual `0x` prefix used for hexadecimal
  # numbers. If your string starts with such a prefix (e.g. `0xFF`), you must
  # remove it yourself.
  #
  # # Examples
  #
  #     Int.from_base16('ef') # => Option.Some(239)
  #     Int.from_base16('zz') # => Option.None
  fn pub static from_base16(string: String) -> Option[Int] {
    match inko_string_to_int(
      _INKO.state, _INKO.process, string.to_pointer, string.size, 16
    ) {
      case { @tag = 0, @value = v } -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Formats `self` as a `String` using base 2.
  #
  # # Examples
  #
  #     3.to_base2  # => '11'
  #     -3.to_base2 # => '-11'
  fn pub to_base2 -> String {
    if self == MIN {
      # to_base() uses absolute(), which can't represent MIN as a positive
      # value.
      '-1000000000000000000000000000000000000000000000000000000000000000'
    } else {
      to_base(2)
    }
  }

  # Formats `self` as a `String` using base 16.
  #
  # # Examples
  #
  #     123.to_base16  # => '7b'
  #     -123.to_base16 # => '-7b'
  fn pub to_base16 -> String {
    if self == MIN {
      # to_base() uses absolute(), which can't represent MIN as a positive
      # value.
      '-8000000000000000'
    } else {
      to_base(16)
    }
  }

  # Calls the supplied closure `self` times.
  #
  # # Examples
  #
  #     4.times fn (i) {
  #       i # => 0, 1, 2, 3
  #     }
  fn pub times(block: fn (Int)) {
    let mut index = 0

    while index < self {
      block.call(index)

      index += 1
    }
  }

  # Returns the absolute value of `self`.
  #
  # # Examples
  #
  #     -4.absolute # => 4
  #     4.absolute  # => 4
  fn pub absolute -> Int {
    if self < 0 { 0 - self } else { clone }
  }

  # Returns a value with the opposite sign of `self`.
  #
  # # Examples
  #
  #     -42.opposite # => 42
  #     42.opposite  # => -42
  fn pub opposite -> Int {
    0 - self
  }

  # Returns a `Range` from `self` up to but excluding `other`.
  fn pub until(other: Int) -> ExclusiveRange {
    ExclusiveRange.new(clone, other)
  }

  # Returns a `Range` from `self` up to and including `other`.
  fn pub to(other: Int) -> InclusiveRange {
    InclusiveRange.new(clone, other)
  }

  # Returns the number of digits of `self`.
  #
  # # Examples
  #
  #     0.digits    # => 1
  #     10.digits   # => 2
  #     100.digits  # => 3
  #     -100.digits # => 3
  fn pub digits -> Int {
    if self == 0 { return 1 }

    let mut digits = 0
    let mut number = absolute

    while number > 0 {
      number /= 10
      digits += 1
    }

    digits
  }

  # Rounds `self` to the nearest power of two.
  #
  # If `self <= 0`, this method returns zero.
  #
  # # Examples
  #
  #     0.nearest_power_of_two # => 0
  #     1.nearest_power_of_two # => 1
  #     2.nearest_power_of_two # => 2
  #     3.nearest_power_of_two # => 4
  fn pub nearest_power_of_two -> Int {
    if self <= 0 { return 0 }

    let mut rounded = clone

    rounded -= 1
    rounded |= rounded >> 1
    rounded |= rounded >> 2
    rounded |= rounded >> 4
    rounded |= rounded >> 8
    rounded |= rounded >> 16
    rounded |= rounded >> 32
    rounded += 1

    rounded
  }

  # Formats `self` as a `String` in the given base.
  #
  # This method only supports a limited number of bases, and is marked as
  # private so we have more control over what bases we publicly support.
  fn to_base(base: Int) -> String {
    if self == 0 { return '0' }

    let alphabet = '0123456789abcdef'
    let bytes = ByteArray.new
    let mut int = absolute

    while int > 0 {
      bytes.push(alphabet.byte(int % base))
      int /= base
    }

    if self < 0 { bytes.push(0x2D) }

    bytes.reverse
    bytes.into_string
  }

  # Returns the result of performing a bitwise `NOT` on `self`.
  #
  # As Inko doesn't support unary operators besides `not` (which only supports
  # booleans), this is just a regular method.
  #
  # # Examples
  #
  #     12.not # => -13
  fn pub not -> Int {
    _INKO.int_bit_not(self)
  }

  # Shifts the bits to the left, wrapping the truncated bits to the end of the
  # resulting integer.
  #
  # # Examples
  #
  #     0xaa00000000006e1.rotate_left(12) # => 0x6e10aa
  fn pub rotate_left(amount: Int) -> Int  {
    _INKO.int_rotate_left(self, amount)
  }

  # Shifts the bits to the right, wrapping the truncated bits to the end of the
  # resulting integer.
  #
  # # Examples
  #
  #     0x6e10aa.rotate_right(12) # => 0xaa00000000006e1
  fn pub rotate_right(amount: Int) -> Int  {
    _INKO.int_rotate_right(self, amount)
  }

  # Adds `other` to `self`, wrapping around when overflowing.
  #
  # # Examples
  #
  #     import std.int.(MAX, MIN)
  #
  #     1.wrapping_add(1)   # => 2
  #     MAX.wrapping_add(1) # => MIN
  fn pub wrapping_add(other: Int) -> Int {
    _INKO.int_wrapping_add(self, other)
  }

  # Subtracts `other` from `self`, wrapping around when overflowing.
  #
  # # Examples
  #
  #     import std.int.(MAX, MIN)
  #
  #     1.wrapping_sub(1)   # => 0
  #     MIN.wrapping_sub(1) # => MAX
  fn pub wrapping_sub(other: Int) -> Int {
    _INKO.int_wrapping_sub(self, other)
  }

  # Multiplies `other` with `self`, wrapping around when overflowing.
  #
  # # Examples
  #
  #     import std.int.MAX
  #
  #     1.wrapping_mul(2)   # => 2
  #     MAX.wrapping_mul(2) # => -2
  fn pub wrapping_mul(other: Int) -> Int {
    _INKO.int_wrapping_mul(self, other)
  }

  # Adds `other` to `self`, returning a `None` when overflowing.
  #
  # # Examples
  #
  #     import std.int.(MAX)
  #
  #     1.checked_add(5)   # => Option.Some(6)
  #     MAX.checked_add(1) # => Option.None
  fn pub checked_add(other: Int) -> Option[Int] {
    let res = _INKO.int_checked_add(self, other)

    if res.tag as Int == 0 {
      Option.Some(res.value as Int)
    } else {
      Option.None
    }
  }

  # Subtracts `other` from `self`, returning a `None` when overflowing.
  #
  # # Examples
  #
  #     import std.int.(MAX, MIN)
  #
  #     1.checked_sub(1)   # => Option.Some(0)
  #     MIN.checked_sub(1) # => Option.None
  fn pub checked_sub(other: Int) -> Option[Int] {
    let res = _INKO.int_checked_sub(self, other)

    if res.tag as Int == 0 {
      Option.Some(res.value as Int)
    } else {
      Option.None
    }
  }

  # Multiplies `other` with `self`, returning a `None` when overflowing.
  #
  # # Examples
  #
  #     import std.int.MAX
  #
  #     1.checked_mul(2)   # => Option.Some(2)
  #     MAX.checked_mul(2) # => Option.None
  fn pub checked_mul(other: Int) -> Option[Int] {
    let res = _INKO.int_checked_mul(self, other)

    if res.tag as Int == 0 {
      Option.Some(res.value as Int)
    } else {
      Option.None
    }
  }

  # Divides `self` by `other`, returning a `None` when overflowing or if `other`
  # is zero.
  #
  # # Examples
  #
  #     import std.int.MAX
  #
  #     10.checked_div(0) # => Option.None
  #     10.checked_div(2) # => Option.Some(5)
  fn pub checked_div(other: Int) -> Option[Int] {
    if other == 0 or (self == MIN and other == -1) {
      Option.None
    } else {
      Option.Some(unchecked_div(other))
    }
  }

  # Raises `self` to the power of `other`, returning a `None` when overflowing.
  #
  # # Examples
  #
  #     import std.int.MAX
  #
  #     2.checked_pow(2)   # => Option.Some(4)
  #     MAX.checked_pow(2) # => Option.None
  fn pub checked_pow(other: Int) -> Option[Int] {
    let res = inko_int_checked_pow(self, other)

    if res.tag as Int == 0 {
      Option.Some(res.value as Int)
    } else {
      Option.None
    }
  }

  fn unchecked_div(other: Int) -> Int {
    # This implements floored division, rather than rounding towards zero. This
    # makes division work more natural when using negative numbers.
    #
    # This code is based on the upcoming div_floor() implementation of the Rust
    # standard library: https://github.com/rust-lang/rust/pull/88582.
    let d = _INKO.int_div(self, other)
    let r = _INKO.int_rem(self, other)

    if (r > 0 and other < 0) or (r < 0 and other > 0) { d - 1 } else { d }
  }
}

impl ToInt for Int {
  fn pub to_int -> Int {
    clone
  }
}

impl ToFloat for Int {
  fn pub to_float -> Float {
    self as Float
  }
}

impl Compare[Int] for Int {
  fn pub cmp(other: ref Int) -> Ordering {
    if self > other {
      Ordering.Greater
    } else if self < other {
      Ordering.Less
    } else {
      Ordering.Equal
    }
  }

  fn pub <(other: ref Int) -> Bool {
    _INKO.int_lt(self, other)
  }

  fn pub <=(other: ref Int) -> Bool {
    _INKO.int_le(self, other)
  }

  fn pub >(other: ref Int) -> Bool {
    _INKO.int_gt(self, other)
  }

  fn pub >=(other: ref Int) -> Bool {
    _INKO.int_ge(self, other)
  }
}

impl Equal[Int] for Int {
  fn pub ==(other: ref Int) -> Bool {
    _INKO.int_eq(self, other)
  }
}

impl Clone[Int] for Int {
  fn pub clone -> Int {
    self
  }
}

impl ToString for Int {
  fn pub to_string -> String {
    inko_int_to_string(_INKO.state, self)
  }
}

impl Add[Int, Int] for Int {
  fn pub +(other: ref Int) -> Int {
    let res = _INKO.int_checked_add(self, other)

    if res.tag as Int == 0 {
      res.value as Int
    } else {
      overflow(self, '+', other)
    }
  }
}

impl Subtract[Int, Int] for Int {
  fn pub -(other: ref Int) -> Int {
    let res = _INKO.int_checked_sub(self, other)

    if res.tag as Int == 0 {
      res.value as Int
    } else {
      overflow(self, '-', other)
    }
  }
}

impl Divide[Int, Int] for Int {
  fn pub /(other: ref Int) -> Int {
    if other == 0 or (self == MIN and other == -1) {
      overflow(self, '-', other)
    }

    unchecked_div(other)
  }
}

impl Multiply[Int, Int] for Int {
  fn pub *(other: ref Int) -> Int {
    let res = _INKO.int_checked_mul(self, other)

    if res.tag as Int == 0 {
      res.value as Int
    } else {
      overflow(self, '*', other)
    }
  }
}

impl Modulo[Int, Int] for Int {
  fn pub %(other: ref Int) -> Int {
    if other == 0 or (self == MIN and other == -1) {
      overflow(self, '%', other)
    }

    let sum = _INKO.int_checked_add(_INKO.int_rem(self, other), other)

    if sum.tag as Int == 0 {
      _INKO.int_rem(sum.value as Int, other)
    } else {
      overflow(self, '%', other)
    }
  }
}

impl BitAnd[Int, Int] for Int {
  fn pub &(other: ref Int) -> Int {
    _INKO.int_bit_and(self, other)
  }
}

impl BitOr[Int, Int] for Int {
  fn pub |(other: ref Int) -> Int {
    _INKO.int_bit_or(self, other)
  }
}

impl BitXor[Int, Int] for Int {
  fn pub ^(other: ref Int) -> Int {
    _INKO.int_bit_xor(self, other)
  }
}

impl ShiftLeft[Int, Int] for Int {
  fn pub <<(other: ref Int) -> Int {
    if other >= BITS { overflow(self, '<<', other) }

    _INKO.int_shl(self, other)
  }
}

impl ShiftRight[Int, Int] for Int {
  fn pub >>(other: ref Int) -> Int {
    if other >= BITS { overflow(self, '>>', other) }

    _INKO.int_shr(self, other)
  }
}

impl UnsignedShiftRight[Int, Int] for Int {
  fn pub >>>(other: ref Int) -> Int {
    if other >= BITS { overflow(self, '>>>', other) }

    _INKO.int_unsigned_shr(self, other)
  }
}

impl Power[Int, Int] for Int {
  fn pub **(other: ref Int) -> Int {
    let res = inko_int_checked_pow(self, other)

    if res.tag as Int == 0 {
      res.value as Int
    } else {
      overflow(self, '**', other)
    }
  }
}

impl Hash for Int {
  fn pub hash(hasher: mut Hasher) {
    hasher.write(clone)
  }
}

impl Format for Int {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write(to_string)
  }
}
