# An ordered, integer-indexed generic collection of values.
import std::clone::Clone
import std::cmp::(Compare, Contains, Equal, Ordering, min)
import std::drop::Drop
import std::fmt::(Format, Formatter)
import std::hash::(Hash, Hasher)
import std::iter::(Enum, Iter)
import std::option::Option
import std::rand::Shuffle
import std::libc::unix::alloc::(self as alloc_imp) if unix

class extern AnyResult {
  let @tag: Int
  let @value: Any
}

# The size of each value in an Array.
#
# Inko values stored in an Array are always heap allocated, thus each value is
# the size of a pointer, or 8 bytes.
let VALUE_SIZE = 8

# The capacity to use when resizing an array for the first time.
let START_CAPACITY = 4

fn stable_sort[T: Compare[T]](
  array: mut Array[T],
  compare: mut fn (ref T, ref T) -> Bool,
) {
  let len = array.length

  # The algorithm here is the recursive merge sort algorithm. While faster
  # algorithms exist (e.g. Timsort, at least in certain cases), merge sort is
  # the easiest to implement and still offers good performance.
  if len <= 1 { return }

  # We don't set a length for `tmp` so we don't drop any of the temporary
  # values in it, as that would result in `self` being left with invalid
  # values. This works because merge_sort() doesn't perform any bounds checking.
  let tmp: Array[T] = Array.with_capacity(len)

  len.times fn (i) {
    tmp.write_to(i, array.read_from(i))
  }

  merge_sort(tmp, array, start: 0, end: len, compare: compare)
}

fn merge_sort[T: Compare[T]](
  a: mut Array[T],
  b: mut Array[T],
  start: Int,
  end: Int,
  compare: mut fn (ref T, ref T) -> Bool
) {
  if end - start <= 1 { return }

  # https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html
  let mid = start.wrapping_add(end) >>> 1

  merge_sort(b, a, start, mid, compare)
  merge_sort(b, a, mid, end, compare)

  let mut i = start
  let mut j = mid
  let mut k = start

  while k < end {
    if i < mid
      and (j >= end or compare.call(a.get_unchecked(i), a.get_unchecked(j)))
    {
      b.write_to(k, a.read_from(i))
      i += 1
    } else {
      b.write_to(k, a.read_from(j))
      j += 1
    }

    k += 1
  }
}

# Checks if `index` is in the range of zero up to (but excluding) `length`.
#
# # Panics
#
# This method panics if the index is out of bounds.
fn pub bounds_check(index: Int, length: Int) {
  if index >= 0 and index < length { return }

  _INKO.panic("The index {index} is out of bounds (length: {length})")
}

# An ordered, integer-indexed generic collection of values.
#
# Accessing values in an `Array` is a constant-time operation.
#
# Arrays are created using the array literal syntax, instead of using a method.
# Here's how you'd create an empty Array:
#
#     []
#
# And here's how you'd create an Array with values:
#
#     [10, 20, 30]
#
# All values in an array must be of the same type, and the array's value type is
# based on the type of the first value.
class builtin Array[T] {
  # The compiler depends on the order of these fields, so don't change it
  # without also updating the compiler.

  let @length: Int
  let @capacity: Int
  let @buffer: Pointer[Int8]

  # Returns a new `Array` with enough space for at least `amount` values.
  #
  # The actual capacity may be greater than the given value.
  fn pub static with_capacity(amount: Int) -> Array[T] {
    let buffer = alloc_imp
      .resize(0x0 as Pointer[Int8], size: amount * VALUE_SIZE)

    Array { @length = 0, @capacity = amount, @buffer = buffer }
  }

  # Returns an array filled with a certain amount of values.
  #
  # The `times` argument specifies how many times the `with` argument must
  # exist in the array.
  #
  # # Examples
  #
  #     Array.filled(with: 0, times: 4) # => [0, 0, 0, 0]
  fn pub static filled[V: Clone[V]](with: V, times: Int) -> Array[V] {
    if times == 0 { return [] }

    let array = with_capacity(times)
    let temp = ref with

    (times - 1).times fn (_) { array.push(temp.clone) }
    array.push(with)
    array
  }

  # Removes all values in the Array.
  #
  # # Examples
  #
  #     let array = [10, 20, 30]
  #
  #     array.clear
  #     array.empty? # => true
  fn pub mut clear {
    let mut index = 0
    let max = @length

    while index < max {
      read_from(index := index + 1)
    }

    @length = 0
  }

  # Pushes a value to the back of the Array.
  #
  # # Examples
  #
  # Pushing a value into an Array:
  #
  #     let array = []
  #
  #     array.push(10) # => Nil
  #     array[0]       # => 10
  fn pub mut push(value: T) {
    grow_buffer
    write_to(@length, value)
    @length += 1
  }

  # Removes a value from the back of the Array, returning the removed value.
  #
  # If no value was found, a None is returned instead.
  #
  # # Examples
  #
  # Popping an existing value:
  #
  #     let array = [10]
  #
  #     array.pop    # => Option.Some(10)
  #     array.empty? # => true
  #
  # Popping a value when the Array is empty:
  #
  #     let array = []
  #
  #     array.pop # => Option.None
  fn pub mut pop -> Option[T] {
    if @length == 0 { return Option.None }

    @length -= 1
    Option.Some(read_from(@length))
  }

  # Removes the value at the given index, returning the removed value.
  #
  # Values to the right of the index are shifted to the left.
  #
  # # Examples
  #
  # Removing an existing value will result in the value being removed from the
  # Array and returned:
  #
  #     let array = [10]
  #
  #     array.remove_at(0) # => 10
  #     array.empty?       # => true
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  fn pub mut remove_at(index: Int) -> T {
    let len = length

    bounds_check(index, len)

    let addr = address_of(index)
    let val = addr.0 as Any as T

    alloc_imp.copy(
      from: addr as Int + VALUE_SIZE as Pointer[Int8],
      to: addr as Pointer[Int8],
      size: len - index - 1 * VALUE_SIZE,
    )

    @length = len - 1
    val
  }

  # Returns an optional immutable reference to the value at the given index.
  #
  # # Examples
  #
  # Retrieving an existing value:
  #
  #     let numbers = [10, 20]
  #
  #     numbers.opt(0) # => Option.Some(ref 10)
  #
  # Retrieving a value from a non-existing index:
  #
  #     let numbers = [10, 20]
  #
  #     numbers.opt(5) # => Option.None
  fn pub opt(index: Int) -> Option[ref T] {
    if index < 0 or index >= @length { return Option.None }

    Option.Some(get_unchecked(index))
  }

  # Returns an immutable reference to the value at the given index.
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  #
  # # Examples
  #
  #     let numbers = [10, 20]
  #
  #     numbers.get(0) # => 10
  fn pub get(index: Int) -> ref T {
    bounds_check(index, @length)
    get_unchecked(index)
  }

  # Stores a value at the given index.
  #
  # If a value is already present at the given index, it's dropped before the
  # new value overwrites it.
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  #
  # # Examples
  #
  # Setting an index to a value:
  #
  #     let array = []
  #
  #     array.set(0, 10)
  #     array # => [10]
  fn pub mut set(index: Int, value: T) {
    bounds_check(index, @length)

    # This drops the old value, then writes the new value.
    read_from(index)
    write_to(index, value)
  }

  # Inserts the value at the given index, returning the old value.
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  #
  # # Examples
  #
  #     let numbers = [10, 20, 30]
  #
  #     numbers.swap(index: 1, with: 40) # => 20
  #     numbers                          # => [10, 40, 30]
  fn pub mut swap(index: Int, with: T) -> T {
    bounds_check(index, @length)

    let old = read_from(index)

    write_to(index, with)
    old
  }

  # Swaps the values at the given indexes.
  #
  # # Examples
  #
  #     let numbers = [10, 20, 30]
  #
  #     numbers.swap_indexes(index: 0, with: 2)
  #
  #     numbers # => [30, 20, 10]
  fn pub mut swap_indexes(index: Int, with: Int) {
    bounds_check(index, @length)
    bounds_check(with, @length)

    let a = read_from(index)
    let b = read_from(with)

    write_to(index, b)
    write_to(with, a)
  }

  # Returns an iterator that yields immutable references to the values in
  # `self`.
  fn pub iter -> Iter[ref T] {
    Enum.indexed(@length) fn (index) { get(index) }
  }

  # Returns an `Iter` that iterates over all values in `self`, returning them
  # by value.
  #
  # # Examples
  #
  #     let numbers = [10, 20, 30]
  #     let iter = numbers.into_iter
  #
  #     iter.next # => Option.Some(10)
  #     iter.next # => Option.Some(20)
  #     iter.next # => Option.Some(30)
  #     iter.next # => Option.None
  fn pub move into_iter -> IntoIter[T] {
    IntoIter { @array = self, @index = 0 }
  }

  # Returns an `Iter` that iterates over all values in `self` in reverse
  # order.
  #
  # # Examples
  #
  # Iterating over an `Array` in reverse order:
  #
  #     let numbers = [10, 20, 30]
  #     let iter = numbers.reverse_iter
  #
  #     iter.next # => Option.Some(30)
  #     iter.next # => Option.Some(20)
  #     iter.next # => Option.Some(10)
  #     iter.next # => Option.None
  fn pub reverse_iter -> Iter[ref T] {
    let mut index = length - 1

    Enum.new fn move {
      if index > -1 {
        Option.Some(get(index := index - 1))
      } else {
        Option.None
      }
    }
  }

  # Appends the values of the given `Array` to `self`.
  #
  # # Examples
  #
  # Appending one `Array` to another:
  #
  #     let numbers = [10, 20, 30]
  #
  #     numbers.append([40, 50])
  #
  #     numbers.length # => 5
  fn pub mut append(other: Array[T]) {
    other.into_iter.each fn (v) { push(v) }
  }

  # Returns the number of values in this Array.
  #
  # # Examples
  #
  # Getting the length of an empty Array:
  #
  #     [].length # => 0
  #
  # Getting the length of an Array with values:
  #
  #     [10].length # => 1
  fn pub length -> Int {
    @length
  }

  # Returns the number of values that can be stored in `self` before `self`
  # needs to be resized.
  #
  # # Examples
  #
  #     Array.with_capacity(2).capacity # => 4
  fn pub capacity -> Int {
    @capacity
  }

  # Returns `true` if `self` is empty.
  #
  # # Examples
  #
  #     [10].empty? # => false
  #     [].empty?     # => true
  fn pub empty? -> Bool {
    @length == 0
  }

  # Sorts the values in `self` such that they are in a random order.
  #
  # # Examples
  #
  #     let a = [10, 20]
  #
  #     a.shuffle
  #     a # => [20, 10]
  fn pub mut shuffle {
    Shuffle.new.sort(self)
  }

  # Reverses `self` in-place
  #
  # # Examples
  #
  #     let a = [10, 20, 30]
  #
  #     a.reverse
  #
  #     a # => [30, 20, 10]
  fn pub mut reverse {
    let mut a = 0
    let mut b = @length - 1

    while a < b {
      let a_val = read_from(a)
      let b_val = read_from(b)

      write_to(b, a_val)
      write_to(a, b_val)
      a += 1
      b -= 1
    }
  }

  # Returns a pointer to the underlying memory buffer.
  fn pub as_pointer -> Pointer[Int8] {
    @buffer
  }

  fn get_unchecked(index: Int) -> ref T {
    let val = read_from(index)
    let ret = ref val

    _INKO.moved(val)
    ret
  }

  fn read_from(index: Int) -> T {
    address_of(index).0 as Any as T
  }

  fn mut write_to(index: Int, value: T) {
    address_of(index).0 = value as Any as Int64
  }

  fn address_of(index: Int) -> Pointer[Int64] {
    @buffer as Int + (index * VALUE_SIZE) as Pointer[Int64]
  }

  fn mut grow_buffer {
    if @capacity > @length { return }

    @capacity = if @capacity == 0 { START_CAPACITY } else { @capacity * 2 }
    @buffer = alloc_imp.resize(@buffer, @capacity * VALUE_SIZE)
  }
}

impl Array if T: mut {
  # Returns an optional mutable reference to the value at the given index.
  #
  # # Examples
  #
  # Retrieving an existing value:
  #
  #     let numbers = [10, 20]
  #
  #     numbers.opt_mut(0) # => Option.Some(mut 10)
  #
  # Retrieving a value from a non-existing index:
  #
  #     let numbers = [10, 20]
  #
  #     numbers.opt_mut(5) # => Option.None
  fn pub mut opt_mut(index: Int) -> Option[mut T] {
    if index < 0 or index >= @length { return Option.None }

    Option.Some(get_unchecked_mut(index))
  }

  # Returns a mutable reference to the value at the given index.
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  #
  # # Examples
  #
  #     let numbers = [10, 20]
  #
  #     numbers.get_mut(0) # => 10
  fn pub mut get_mut(index: Int) -> mut T {
    bounds_check(index, @length)
    get_unchecked_mut(index)
  }

  # Returns an iterator that yields mutable references to the values in `self`.
  fn pub mut iter_mut -> Iter[mut T] {
    Enum.indexed(@length) fn (index) { get_mut(index) }
  }

  fn mut get_unchecked_mut(index: Int) -> mut T {
    let val = read_from(index)
    let ret = mut val

    _INKO.moved(val)
    ret
  }
}

impl Drop for Array {
  fn mut drop {
    clear
    alloc_imp.free(@buffer)
  }
}

impl Contains[T] for Array if T: Equal[T] {
  # Returns `true` if `self` contains the given value.
  #
  # # Examples
  #
  # Checking if an `Array` contains a value:
  #
  #     [10, 20, 30].contains?(10) # => true
  fn pub contains?(value: ref T) -> Bool {
    iter.any? fn (ours) { ours == value }
  }
}

impl Clone[Array[T]] for Array if T: Clone[T] {
  fn pub clone -> Array[T] {
    let len = @length
    let copy = Array.with_capacity(len)
    let mut index = 0

    while index < len { copy.push(get(index := index + 1).clone) }

    copy
  }
}

impl Equal[Array[T]] for Array if T: Equal[T] {
  # Returns `true` if `self` and the given `Array` are identical.
  #
  # # Examples
  #
  # Comparing two identical arrays:
  #
  #     [10, 20, 30] == [10, 20, 30] # => true
  #
  # Comparing two arrays with a different length:
  #
  #     [10] == [10, 20] # => false
  #
  # Comparing two arrays with the same length but with different values:
  #
  #     [10, 20] == [20, 10] # => false
  fn pub ==(other: ref Array[T]) -> Bool {
    if @length != other.length { return false }

    let mut index = 0
    let max = @length

    while index < max {
      let ours = get(index)
      let theirs = other.get(index)

      if ours != theirs { return false }

      index += 1
    }

    true
  }
}

impl Hash for Array if T: Hash {
  fn pub hash(hasher: mut Hasher) {
    let mut index = 0
    let max = @length

    while index < max { get(index := index + 1).hash(hasher) }
  }
}

impl Format for Array if T: Format {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write('[')

    iter.each_with_index fn (index, value) {
      if index > 0 { formatter.write(', ') }

      value.fmt(formatter)
    }

    formatter.write(']')
  }
}

impl Array if T: Compare[T] {
  # Sorts the values in `self` in ascending order.
  #
  # This method performs a stable sort, meaning it maintains the relative order
  # of duplicate values.
  #
  # # Examples
  #
  #     let nums = [0, 3, 3, 5, 9, 1]
  #
  #     nums.sort
  #     nums # => [0, 1, 3, 3, 5, 9]
  fn pub mut sort {
    stable_sort(self) fn (a, b) { a <= b }
  }

  # Sorts the values in `self` using a custom comparison closure.
  #
  # Like `Array.sort`, this method performs a stable sort.
  #
  # # Examples
  #
  #     let nums = [0, 3, 3, 5, 9, 1]
  #
  #     nums.sort_by fn (a, b) { b.cmp(a) }
  #     nums # => [9, 5, 3, 3, 1, 0]
  fn pub mut sort_by(block: fn (ref T, ref T) -> Ordering) {
    stable_sort(self) fn (a, b) {
      match block.call(a, b) {
        case Less or Equal -> true
        case _ -> false
      }
    }
  }
}

# An iterator that moves values out of an `Array`.
#
# When this iterator is dropped, any values not yet moved out of the `Array` are
# dropped.
class pub IntoIter[T] {
  let @array: Array[T]
  let @index: Int

  fn mut take_next -> T {
    @array.read_from(@index := @index + 1)
  }

  fn length -> Int {
    @array.length
  }
}

impl Drop for IntoIter {
  fn mut drop {
    while @index < length { take_next }

    # This is needed so we don't try to drop the values a second time when
    # dropping the array itself.
    @array.length = 0
  }
}

impl Iter[T] for IntoIter {
  fn pub mut next -> Option[T] {
    if @index < length { Option.Some(take_next) } else { Option.None }
  }
}
