# Cross-platform path manipulation.
import std.clone (Clone)
import std.cmp (Equal)
import std.fmt (Format, Formatter)
import std.fs (DirectoryEntry)
import std.hash (Hash, Hasher)
import std.io (Error, Size)
import std.iter (Iter, Stream)
import std.libc.unix.dir (ReadDirectory as ReadDirectoryInner) if unix
import std.string (IntoString, StringBuffer, ToString)
import std.sys
import std.time (DateTime)

class extern IntResult {
  let @tag: Int
  let @value: Int
}

class extern AnyResult {
  let @tag: Int
  let @value: UInt64
}

fn extern inko_file_remove(process: Pointer[UInt8], path: String) -> AnyResult

fn extern inko_file_copy(
  process: Pointer[UInt8],
  from: String,
  to: String,
) -> AnyResult

fn extern inko_directory_remove(
  process: Pointer[UInt8],
  path: String,
) -> AnyResult

fn extern inko_directory_create(
  process: Pointer[UInt8],
  path: String,
) -> AnyResult

fn extern inko_directory_create_recursive(
  process: Pointer[UInt8],
  path: String,
) -> AnyResult

fn extern inko_directory_remove_recursive(
  process: Pointer[UInt8],
  path: String,
) -> AnyResult

fn extern inko_file_size(process: Pointer[UInt8], path: String) -> IntResult

fn extern inko_path_accessed_at(
  process: Pointer[UInt8],
  path: String,
) -> AnyResult

fn extern inko_path_created_at(
  process: Pointer[UInt8],
  path: String,
) -> AnyResult

fn extern inko_path_modified_at(
  process: Pointer[UInt8],
  path: String,
) -> AnyResult

fn extern inko_path_exists(process: Pointer[UInt8], path: String) -> Bool

fn extern inko_path_is_file(process: Pointer[UInt8], path: String) -> Bool

fn extern inko_path_is_directory(process: Pointer[UInt8], path: String) -> Bool

fn extern inko_path_expand(state: Pointer[UInt8], path: String) -> AnyResult

fn extern inko_time_system_offset -> Int64

# The byte used to represent a single dot/period.
let DOT_BYTE = 46

# The character used to separate components in a file path.
let pub SEPARATOR = '/'

# The byte used to represent the path separator.
let SEPARATOR_BYTE = 47

# Returns the number of bytes leading up to the last path separator.
#
# If no separator could be found, `-1` is returned.
fn bytes_before_last_separator(path: String) -> Int {
  if path.empty? { return -1 }

  let mut index = path.size - 1

  # Trailing separators should be ignored, so we'll skip over them until the
  # first non-separator byte.
  while index > 0 and path.byte(index) == SEPARATOR_BYTE { index -= 1 }

  let mut in_separator = false

  while index > -1 {
    let byte = path.byte(index)

    if byte == SEPARATOR_BYTE {
      in_separator = true
    } else if in_separator {
      return index + 1
    }

    index -= 1
  }

  if in_separator { 1 } else { -1 }
}

# Returns `true` if the given file path is an absolute path.
fn absolute_path?(path: String) -> Bool {
  path.byte(0) == SEPARATOR_BYTE
}

fn join_strings(base: ref String, with: ref String) -> String {
  if base.empty? { return with.clone }

  if with.empty? { return base.clone }

  if absolute_path?(with) {
    with
  } else if base.byte(base.size - 1) == SEPARATOR_BYTE {
    '${base}${with}'
  } else {
    '${base}${SEPARATOR}${with}'
  }
}

# An iterator over the entries in a directory.
#
# See the documentation of `std.fs.path.Path.list` for more details.
class pub ReadDirectory {
  let @path: String
  let @inner: ReadDirectoryInner
}

impl Iter[Result[DirectoryEntry, Error]] for ReadDirectory {
  fn pub mut next -> Option[Result[DirectoryEntry, Error]] {
    let ret = match try { @inner.next } {
      case Ok((path, type)) -> {
        Result.Ok(
          DirectoryEntry(
            path: Path.new(join_strings(@path, with: path)),
            type: type,
          ),
        )
      }
      case Error(e) -> Result.Error(e)
    }

    Option.Some(ret)
  }
}

# An iterator over the components in a `Path`.
class pub Components {
  let @path: ref Path
  let @index: Int
  let @size: Int
  let @root: Bool

  fn static new(path: ref Path) -> Components {
    let size = path.path.size
    let root = size > 0 and path.path.byte(0) == SEPARATOR_BYTE
    let comp = Components(path: path, index: 0, size: size, root: root)

    # If we start with a sequence such as `.//././.`, we skip over those. We
    # only need to do this once, so we take care of that here instead of
    # performing this check every time `next` is called.
    comp.skip_relative_start
    comp
  }

  fn byte(index: Int) -> Int {
    @path.path.byte(index)
  }

  fn separator?(index: Int) -> Bool {
    byte(index) == SEPARATOR_BYTE
  }

  fn mut skip_relative_start {
    if
      @size > 0
        and byte(@index) == DOT_BYTE
        and @index + 1 < @size
        and separator?(@index + 1)
    {
      @index += 1
      advance_separator
    }
  }

  fn mut advance_separator {
    while @index < @size and separator?(@index) {
      @index += 1

      # This turns sequences such as `a/./././b` into `a/b`, while leaving
      # `a/../b` alone.
      while
        @index < @size
          and byte(@index) == DOT_BYTE
          and (
            @index + 1 < @size and separator?(@index + 1) or @index + 1 == @size
          )
      {
        @index += 2
      }
    }
  }
}

impl Iter[String] for Components {
  fn pub mut next -> Option[String] {
    if @index >= @size { return Option.None }

    if @index == 0 and @root {
      advance_separator
      return Option.Some(SEPARATOR)
    }

    let start = @index
    let mut size = 0

    while @index < @size and separator?(@index).false? {
      @index += 1
      size += 1
    }

    if size > 0 {
      advance_separator
      Option.Some(@path.path.slice(start, size).into_string)
    } else {
      Option.None
    }
  }
}

# A path to a file or directory.
#
# A `Path` can be used to retrieve information about a path to a file or
# directory such as the size or file type. `Path` objects can be created by
# either using `Path.new` or by sending `to_path` to a `String`.
#
# # Examples
#
# Creating a new `Path` using a `String`:
#
#     import std.fs.path (Path)
#
#     Path.new('/tmp/hello.txt')
#
# Converting a `String` to a `Path`:
#
#     import std.fs.path (Path)
#
#     '/tmp/hello.txt'.to_path
class pub Path {
  # The raw file path.
  let @path: String

  fn pub static new(path: String) -> Path {
    Path(path)
  }

  # Returns `true` if the path points to a file.
  fn pub file? -> Bool {
    inko_path_is_file(_INKO.process, @path)
  }

  # Returns `true` if the path points to a directory.
  fn pub directory? -> Bool {
    inko_path_is_directory(_INKO.process, @path)
  }

  # Returns `true` if the path points to an existing file or directory.
  fn pub exists? -> Bool {
    inko_path_exists(_INKO.process, @path)
  }

  # Returns the creation time of `self`.
  #
  # The target platform may not supported getting the creation time, in which
  # case an `Error` is returned. musl targets are an example of such a platform.
  #
  # # Examples
  #
  # Obtaining the creation time of a `Path`:
  #
  #     import std.fs.path (Path)
  #
  #     let path = Path.new('README.md')
  #
  #     path.created_at.get # => DateTime(...)
  fn pub created_at -> Result[DateTime, Error] {
    match inko_path_created_at(_INKO.process, @path) {
      case { @tag = 0, @value = val } -> {
        Result.Ok(
          DateTime.from_timestamp(
            Float.from_bits(val as Int),
            inko_time_system_offset as Int,
          ),
        )
      }
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Returns the modification time of `self`.
  #
  # The target platform may not supported getting the creation time, in which
  # case an `Error` is returned.
  #
  # # Examples
  #
  # Obtaining the modification time of a `Path`:
  #
  #     import std.fs.path (Path)
  #
  #     let path = Path.new('README.md')
  #
  #     path.modified_at.get # => DateTime(...)
  fn pub modified_at -> Result[DateTime, Error] {
    match inko_path_modified_at(_INKO.process, @path) {
      case { @tag = 0, @value = val } -> {
        Result.Ok(
          DateTime.from_timestamp(
            Float.from_bits(val as Int),
            inko_time_system_offset as Int,
          ),
        )
      }
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Returns the access time of `self`.
  #
  # The target platform may not supported getting the creation time, in which
  # case an `Error` is returned.
  #
  # # Examples
  #
  # Obtaining the access time of a `Path`:
  #
  #     import std.fs.path (Path)
  #
  #     let path = Path.new('README.md')
  #
  #     path.accessed_at.get # => DateTime(...)
  fn pub accessed_at -> Result[DateTime, Error] {
    match inko_path_accessed_at(_INKO.process, @path) {
      case { @tag = 0, @value = val } -> {
        Result.Ok(
          DateTime.from_timestamp(
            Float.from_bits(val as Int),
            inko_time_system_offset as Int,
          ),
        )
      }
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Returns `true` if this `Path` is an absolute path.
  #
  # # Examples
  #
  # Checking if a `Path` is absolute:
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('foo').absolute?  # => false
  #     Path.new('/foo').absolute? # => true
  fn pub absolute? -> Bool {
    absolute_path?(@path)
  }

  # Returns `true` if this `Path` is a relative path.
  #
  # # Examples
  #
  # Checking if a `Path` is relative:
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('foo').relative?  # => true
  #     Path.new('../').relative?  # => true
  #     Path.new('/foo').relative? # => false
  fn pub relative? -> Bool {
    absolute?.false?
  }

  # Joins `self` and the given path together to form a new `Path`.
  #
  # # Examples
  #
  # Joining a `Path` with a `String`:
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('foo/bar').join('baz').to_string # => 'foo/bar/baz'
  #
  # Joining a `Path` with another `Path`:
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('foo/bar').join(Path.new('bar')).to_string # => 'foo/bar/baz'
  fn pub join[T: ToString](path: ref T) -> Path {
    Path.new(join_strings(@path, with: path.to_string))
  }

  # Returns a `Path` to the directory of the current `Path`.
  #
  # This method does not touch the filesystem, and thus does not resolve paths
  # like `..` and symbolic links to their real paths.
  #
  # This method normalizes the returned `Path` similar to `Path.components`.
  # Refer to the documentation of `Path.components` for more details.
  #
  # # Examples
  #
  # Obtaining the directory of a path:
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('/foo/bar').directory # => Path.new('/foo')
  #
  # Obtaining the directory of the root directory:
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('/').directory # Path.new('/')
  fn pub directory -> Path {
    let buf = StringBuffer.new
    let comp = Components.new(self).peekable
    let mut root = false

    loop {
      match comp.next {
        case Some(SEPARATOR) -> {
          root = true
          buf.push(SEPARATOR)
        }
        case Some(v) if comp.peek.some? -> {
          let any = buf.size > 0

          if any and root { root = false } else if any { buf.push(SEPARATOR) }

          buf.push(v)
        }
        case _ -> break
      }
    }

    if buf.size == 0 { Path.new('.') } else { Path.new(buf.into_string) }
  }

  # Returns the last component in `self`.
  #
  # If `self` is a file, then the tail will be the file name including its
  # extension. If `self` is a directory, the directory name is returned.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('foo/bar/baz.txt') # => 'baz.txt'
  fn pub tail -> String {
    let comp = Components.new(self)
    let mut start = -1
    let mut size = 0

    # This finds the range of the last component, taking into account path
    # normalization.
    while comp.index < comp.size {
      comp.advance_separator

      if comp.index < comp.size {
        start = comp.index
        size = 0
      }

      while comp.index < comp.size and comp.separator?(comp.index).false? {
        comp.index += 1
        size += 1
      }
    }

    if start == -1 { '' } else { @path.slice(start, size).into_string }
  }

  # Returns the file extension of this path (without the leading `.`), if there
  # is any.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('foo.txt').extension # => Option.Some('txt')
  #     Path.new('foo').extension     # => Option.None
  fn pub extension -> Option[String] {
    let size = @path.size
    let mut min = match bytes_before_last_separator(@path) {
      case -1 -> 0
      case n -> n + 1
    }

    if min >= size { return Option.None }

    # If the name starts with a dot, we work our way backwards until the _next_
    # byte. This way we don't treat `.foo` as having the extension `foo`.
    if @path.byte(min) == DOT_BYTE { min += 1 }

    let max = size - 1
    let mut idx = max

    # We consider something an extension if it has at least one non-dot byte,
    # meaning `foo.` is a path _without_ an extension. Different languages
    # handle this differently:
    #
    #     Language     Path      Extension    Leading dot included
    #     ---------------------------------------------------------
    #     Elixir       'foo.'    '.'          Yes
    #     Go           'foo.'    '.'          Yes
    #     Node.js      'foo.'    '.'          Yes
    #     Python       'foo.'    NONE         No
    #     Ruby         'foo.'    '.'          Yes
    #     Rust         'foo.'    NONE         No
    #     Vimscript    'foo.'    NONE         No
    #
    # Things get more inconsistent for paths such as `...`, with some treating
    # it as a file called `..` with the extension `.`, while others consider it
    # a path without an extension.
    while idx > min {
      if @path.byte(idx) == DOT_BYTE { break } else { idx -= 1 }
    }

    if idx < max and idx > min {
      Option.Some(@path.slice(idx + 1, size).into_string)
    } else {
      Option.None
    }
  }

  # Returns a copy of `self` with the given extension.
  #
  # If `self` already has an extension, it's overwritten the given extension. If
  # the given extension is an empty `String`, the new `Path` contains no
  # extension.
  #
  # # Panics
  #
  # This method panics if the extension contains a path separator.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('a').with_extension('txt')    # => Path.new('a.txt')
  #     Path.new('a.txt').with_extension('md') # => Path.new('a.md')
  fn pub with_extension(name: String) -> Path {
    if name.contains?(SEPARATOR) {
      panic("file extensions can't contain path separators")
    }

    if @path.empty? { return clone }

    let raw = match extension {
      case Some(v) if name.empty? -> {
        @path.slice(start: 0, size: @path.size - v.size - 1).into_string
      }
      case Some(v) -> {
        '${@path.slice(start: 0, size: @path.size - v.size - 1)}.${name}'
      }
      case _ if name.empty? or @path.ends_with?(SEPARATOR) -> @path
      case _ -> '${@path}.${name}'
    }

    Path.new(raw)
  }

  # Returns the canonical, absolute version of `self`.
  #
  # # Errors
  #
  # This method may return an `Error` for cases such as when `self` doesn't
  # exist, or when a component that isn't the last component is _not_ a
  # directory.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('/foo/../bar').expand.get # => Path.new('/bar')
  fn pub expand -> Result[Path, Error] {
    match inko_path_expand(_INKO.state, @path) {
      case { @tag = 0, @value = v } -> Result.Ok(Path.new(v as String))
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Returns an iterator yielding the entries in the directory `self` points to.
  #
  # The iterator yields values of type `Result[DirectoryEntry, Error]`, as
  # errors may be produced during iteration (e.g. file permissions are changed
  # such that we can no longer read the directory contents).
  #
  # # Errors
  #
  # This method returns an `Error` if any of the following conditions are met:
  #
  # 1. The user lacks the necessary permissions to read the contents of the
  #    directory.
  # 2. The path isn't a valid directory (i.e. it's a file or doesn't exist).
  #
  # # Examples
  #
  # This prints the files in the current working directory while ignoring
  # directories:
  #
  #     import std.fs.path (Path)
  #     import std.stdio (STDOUT)
  #
  #     let out = STDOUT.new
  #     let path = Path.new('.')
  #     let iter = path.list.or_panic('failed to create the iterator')
  #
  #     iter.each fn (result) {
  #       match result {
  #         case Ok({ @path = path, @type = File }) -> {
  #           out.print(path.to_string)
  #           nil
  #         }
  #         case Ok(_) -> {}
  #         case Error(err) -> panic(err.to_string)
  #       }
  #     }
  fn pub list -> Result[ReadDirectory, Error] {
    ReadDirectoryInner.new(@path).map(fn (inner) {
      ReadDirectory(path: @path, inner: inner)
    })
  }

  # Returns an iterator that yields all non-directory entries in `self` and in
  # any sub directories.
  #
  # The order in which entries are returned is unspecified and shouldn't be
  # relied upon, and may change at any given point.
  #
  # If this iterator fails to read a sub directory (e.g. `bar` in `./foo/bar`
  # isn't readable) a `Some(Error(std.io.Error))` is returned. Because a `Some`
  # is returned the iterator can advance when encountering an error, similar to
  # the iterator returned by `Path.list`.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('/tmp').list_all.get.next
  #     # => Option.Some(Result.Ok(DirectoryEntry(...)))
  fn pub list_all -> Result[Stream[Result[DirectoryEntry, Error]], Error] {
    list.map(fn (iter) {
      let dirs = []
      let mut current = iter

      Stream.new(fn move {
        loop {
          match current.next {
            case Some(Ok({ @path = p, @type = Directory })) -> dirs.push(p)
            case Some(Ok(entry)) -> return Option.Some(Result.Ok(entry))
            case Some(Error(e)) -> return Option.Some(Result.Error(e))
            case None -> {
              match dirs.pop {
                case Some(dir) -> {
                  match dir.list {
                    case Ok(iter) -> current = iter
                    case Error(e) -> return Option.Some(Result.Error(e))
                  }
                }
                case _ -> return Option.None
              }
            }
          }
        }
      })
    })
  }

  # Removes the file `self` points to.
  #
  # If `self` points to a directory, an error is returned.
  #
  # # Examples
  #
  #     import std.fs.file (WriteOnlyFile)
  #     import std.fs.path (Path)
  #
  #     let path = Path.new('/tmp/test.txt')
  #     let handle = WriteOnlyFile.new(path).get
  #
  #     handle.write_string('hello').get
  #     path.remove_file.get
  fn pub remove_file -> Result[Nil, Error] {
    match inko_file_remove(_INKO.process, @path) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Removes the directory `self` points to.
  #
  # If `self` points to a file, an error is returned.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     let path = Path.new('/tmp/foo')
  #
  #     path.create_directory.get
  #     path.remove_directory.get
  fn pub remove_directory -> Result[Nil, Error] {
    match inko_directory_remove(_INKO.process, @path) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Removes the directory and its contents `self` points to.
  #
  # # Errors
  #
  # This method returns an `Error` if any of the following conditions are met:
  #
  # 1. The user lacks the necessary permissions to remove the directory.
  # 2. The directory does not exist.
  #
  # # Examples
  #
  # Removing a directory:
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('/tmp/foo/bar').create_directory_all.get
  #     Path.new('/tmp/foo').remove_directory_all.get
  fn pub remove_directory_all -> Result[Nil, Error] {
    match inko_directory_remove_recursive(_INKO.process, @path) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Creates a new empty directory at the path `self` points to.
  #
  # # Errors
  #
  # This method returns an `Error` if any of the following conditions are met:
  #
  # 1. The user lacks the necessary permissions to create the directory.
  # 2. The directory already exists.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('/tmp/test').create_directory.get
  fn pub create_directory -> Result[Nil, Error] {
    match inko_directory_create(_INKO.process, @path) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Creates a new empty directory at the path `self` points to, while also
  # creating any intermediate directories.
  #
  # # Errors
  #
  # This method returns an `Error` if any of the following conditions are met:
  #
  # 1. The user lacks the necessary permissions to create the directory.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('/tmp/foo/bar/test').create_directory_all.get
  fn pub create_directory_all -> Result[Nil, Error] {
    match inko_directory_create_recursive(_INKO.process, @path) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Copies the file `self` points to the file `to` points to, returning the
  # number of copied bytes.
  #
  # If `self` or `to` points to a directory, an error is returned.
  #
  # # Examples
  #
  #     import std.fs.file (WriteOnlyFile)
  #     import std.fs.path (Path)
  #
  #     let path = Path.new('/tmp/test.txt')
  #     let file = WriteOnlyFile.new(path).get
  #
  #     file.write_string('hello').get
  #     path.copy(to: '/tmp/test2.txt').get
  fn pub copy[T: ToString](to: ref T) -> Result[Int, Error] {
    match inko_file_copy(_INKO.process, @path, to.to_string) {
      case { @tag = 0, @value = v } -> Result.Ok(v as Int)
      case { @tag = _, @value = e } -> {
        Result.Error(Error.from_os_error(e as Int))
      }
    }
  }

  # Returns an iterator over the components in `self`.
  #
  # When parsing the path as part of the iteration, the following normalization
  # is applied:
  #
  # - Repeated separators are treated as a single separator, such as `a/b` and
  #   `a//b` produce the same components
  # - Instances of `.` are normalized away except at the start, such that
  #   `a/./b` and `a/b` produce the same components
  # - Trailing separators are removed, such that `a/b//` and `a/b` produce the
  #   same components
  #
  # If the path starts with the path separator (e.g. `/` on Unix), the first
  # component returned by the iterator is the separator itself.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('a/b/c').components.to_array  # => ['a', 'b', 'c']
  #     Path.new('/a/b/c').components.to_array # => ['/', 'a', 'b', 'c']
  fn pub components -> Components {
    Components.new(self)
  }

  # Returns a new `Path` with the prefix `prefix` removed from it.
  #
  # If `self` doesn't start with `prefix`, a `None` is returned.
  #
  # This method operates on the in-memory representation of `self`, and doesn't
  # expand the path, follow symbolic links, etc.
  #
  # # Examples
  #
  #     import std.fs.path (Path)
  #
  #     Path.new('a/b').strip_prefix(Path.new('a'))   # => Path.new('b')
  #     Path.new('/a/b').strip_prefix(Path.new('/a')) # => Path.new('b')
  fn pub strip_prefix(prefix: ref Path) -> Option[Path] {
    let comp = components
    let valid = prefix.components.all?(fn (theirs) {
      match comp.next {
        case Some(ours) -> ours == theirs
        case _ -> false
      }
    })

    if valid {
      Option.Some(Path.new(String.join(comp, SEPARATOR)))
    } else {
      Option.None
    }
  }
}

# A type from which a new `Path` can be created.
trait pub ToPath {
  # Returns a new `Path` based on `self`.
  fn pub to_path -> Path
}

impl Equal[ref Path] for Path {
  # Returns `true` if `self` is equal to the given `Path`.
  #
  # # Examples
  #
  # Comparing two paths:
  #
  #     import std.fs.path (Path)
  #
  #     let path1 = Path.new('foo')
  #     let path2 = Path.new('foo')
  #
  #     path1 == path2 # => true
  fn pub ==(other: ref Path) -> Bool {
    @path == other.to_string
  }
}

impl ToString for Path {
  # Converts a `Path` to a `String`.
  #
  # # Examples
  #
  # Converting a `Path`:
  #
  #     import std.fs.path (Path)
  #
  #     let path = Path.new('/dev/null')
  #
  #     path.to_string # => '/dev/null'
  fn pub to_string -> String {
    @path
  }
}

impl IntoString for Path {
  fn pub move into_string -> String {
    @path
  }
}

impl Size for Path {
  # Returns the size of the path in bytes.
  #
  # # Examples
  #
  # Getting the size of a path:
  #
  #     import std.fs.path (Path)
  #
  #     let path = Path.new('/dev/null')
  #
  #     path.size.get # => 0
  fn pub size -> Result[Int, Error] {
    match inko_file_size(_INKO.process, @path) {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Clone[Path] for Path {
  fn pub clone -> Path {
    Path.new(@path)
  }
}

impl ToPath for Path {
  fn pub to_path -> Path {
    clone
  }
}

impl Format for Path {
  fn pub fmt(formatter: mut Formatter) {
    @path.fmt(formatter)
  }
}

impl Hash for Path {
  fn pub hash[H: mut + Hasher](hasher: mut H) {
    @path.hash(hasher)
  }
}
