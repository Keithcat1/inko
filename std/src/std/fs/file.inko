# Types and methods for manipulating files on a filesystem.
#
# Rather than using a single "File" type for all different file modes, Inko uses
# three separate file types:
#
# - `ReadOnlyFile`: read-only file operations
# - `WriteOnlyFile`: write-only file operations
# - `ReadWriteFile`: read-write file operations
#
# Using different types per file mode allows for a type-safe file API.
#
# Files are automatically closed when they are dropped. Any errors that may
# occur when closing a file are ignored.
#
# The `WriteOnlyFile` and `ReadWriteFile` _don't_ explicitly flush any writes
# upon being dropped, as any errors produced by this call would be ignored. It's
# _highly_ recommended to call `WriteOnlyFile.flush` / `ReadWriteFile.flush`
# before dropping a file if you need to guarantee any pending writes are flushed
# to the underlying storage medium.
import std.drop (Drop)
import std.fs (Metadata)
import std.fs.path (Path)
import std.io (Error, Read, Seek, Write, WriteInternal)
import std.sys.unix.fs (self as sys) if unix

# A file that can only be used for reads.
#
# `ReadOnlyFile` is allocated on the heap as this allows one to cast it to a
# trait, such as the `Read` trait.
type pub ReadOnlyFile {
  let @fd: Int32

  # The path of the file.
  let pub @path: Path

  # Returns a new `ReadOnlyFile`.
  #
  # # Errors
  #
  # This method returns a `std.io.Error` if opening of the file fails.
  #
  # # Examples
  #
  # ```inko
  # import std.fs.file (ReadOnlyFile)
  #
  # ReadOnlyFile.new('/dev/null'.to_path)
  # ```
  fn pub static new(path: Path) -> Result[ReadOnlyFile, Error] {
    match
      sys.open_file(
        path.to_string,
        read: true,
        write: false,
        append: false,
        truncate: false,
      )
    {
      case Ok(fd) -> Result.Ok(ReadOnlyFile(fd: fd, path: path))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns a metadata about the current file, such as its size and creation
  # time.
  #
  # # Errors
  #
  # This method returns an `Error` if the underlying system call fails, such as
  # when the file no longer exists.
  #
  # # Examples
  #
  # ```inko
  # import std.fs.file (ReadOnlyFile)
  #
  # ReadOnlyFile
  #   .new('/test.txt')
  #   .or_panic('failed to open the file')
  #   .metadata
  #   .or_panic('failed to get the metadata')
  #   .size # => 1234
  # ```
  fn pub metadata -> Result[Metadata, Error] {
    sys.file_metadata(@fd)
  }
}

impl Drop for ReadOnlyFile {
  fn mut drop {
    sys.close_file(@fd)
  }
}

impl Read for ReadOnlyFile {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    sys.read_file(@fd, into, size)
  }
}

impl Seek for ReadOnlyFile {
  fn pub mut seek(position: Int) -> Result[Int, Error] {
    sys.seek_to(@fd, position)
  }
}

# A file that can only be used for writes.
#
# `WriteOnlyFile` is allocated on the heap as this allows one to cast it to a
# trait, such as the `Write` trait.
type pub WriteOnlyFile {
  let @fd: Int32

  # The path of the file.
  let pub @path: Path

  # Opens a file in write-only mode.
  #
  # # Examples
  #
  # ```inko
  # import std.fs.file (WriteOnlyFile)
  #
  # WriteOnlyFile.new('/dev/null'.to_path)
  # ```
  fn pub static new(path: Path) -> Result[WriteOnlyFile, Error] {
    match
      sys.open_file(
        path.to_string,
        read: false,
        write: true,
        append: false,
        truncate: true,
      )
    {
      case Ok(fd) -> Result.Ok(WriteOnlyFile(fd: fd, path: path))
      case Error(e) -> Result.Error(e)
    }
  }

  # Opens a file in append-only mode.
  #
  # # Examples
  #
  # ```inko
  # import std.fs.file (WriteOnlyFile)
  #
  # WriteOnlyFile.append('/dev/null'.to_path)
  # ```
  fn pub static append(path: Path) -> Result[WriteOnlyFile, Error] {
    match
      sys.open_file(
        path.to_string,
        read: false,
        write: true,
        append: true,
        truncate: false,
      )
    {
      case Ok(fd) -> Result.Ok(WriteOnlyFile(fd: fd, path: path))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns a metadata about the current file, such as its size and creation
  # time.
  #
  # # Errors
  #
  # This method returns an `Error` if the underlying system call fails, such as
  # when the file no longer exists.
  #
  # # Examples
  #
  # ```inko
  # import std.fs.file (WriteOnlyFile)
  #
  # WriteOnlyFile
  #   .new('/test.txt')
  #   .or_panic('failed to open the file')
  #   .metadata
  #   .or_panic('failed to get the metadata')
  #   .size # => 1234
  # ```
  fn pub metadata -> Result[Metadata, Error] {
    sys.file_metadata(@fd)
  }
}

impl Drop for WriteOnlyFile {
  fn mut drop {
    sys.close_file(@fd)
  }
}

impl WriteInternal for WriteOnlyFile {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    sys.write_file(@fd, data, size)
  }
}

impl Write for WriteOnlyFile {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    write_all_internal(bytes.to_pointer, bytes.size)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    write_all_internal(string.to_pointer, string.size)
  }

  fn pub mut flush -> Result[Nil, Error] {
    sys.flush_file(@fd)
  }
}

impl Seek for WriteOnlyFile {
  fn pub mut seek(position: Int) -> Result[Int, Error] {
    sys.seek_to(@fd, position)
  }
}

# A file that can be used for both reads and writes.
#
# `ReadWriteFile` is allocated on the heap as this allows one to cast it to a
# trait, such as the `Write` trait.
type pub ReadWriteFile {
  let @fd: Int32

  # The path of the file.
  let pub @path: Path

  # Opens a file for both reading and writing:
  #
  # # Examples
  #
  # ```inko
  # import std.fs.file (ReadWriteFile)
  #
  # ReadWriteFile.new('/dev/null'.to_path)
  # ```
  fn pub static new(path: Path) -> Result[ReadWriteFile, Error] {
    match
      sys.open_file(
        path.to_string,
        read: true,
        write: true,
        append: false,
        truncate: false,
      )
    {
      case Ok(fd) -> Result.Ok(ReadWriteFile(fd: fd, path: path))
      case Error(e) -> Result.Error(e)
    }
  }

  # Opens a file for both reading and appending:
  #
  # # Examples
  #
  # ```inko
  # import std.fs.file (ReadWriteFile)
  #
  # ReadWriteFile.append('/dev/null'.to_path)
  # ```
  fn pub static append(path: Path) -> Result[ReadWriteFile, Error] {
    match
      sys.open_file(
        path.to_string,
        read: true,
        write: true,
        append: true,
        truncate: false,
      )
    {
      case Ok(fd) -> Result.Ok(ReadWriteFile(fd: fd, path: path))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns a metadata about the current file, such as its size and creation
  # time.
  #
  # # Errors
  #
  # This method returns an `Error` if the underlying system call fails, such as
  # when the file no longer exists.
  #
  # # Examples
  #
  # ```inko
  # import std.fs.file (ReadWriteFile)
  #
  # ReadWriteFile
  #   .new('/test.txt')
  #   .or_panic('failed to open the file')
  #   .metadata
  #   .or_panic('failed to get the metadata')
  #   .size # => 1234
  # ```
  fn pub metadata -> Result[Metadata, Error] {
    sys.file_metadata(@fd)
  }
}

impl Drop for ReadWriteFile {
  fn mut drop {
    sys.close_file(@fd)
  }
}

impl Read for ReadWriteFile {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    sys.read_file(@fd, into, size)
  }
}

impl WriteInternal for ReadWriteFile {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    sys.write_file(@fd, data, size)
  }
}

impl Write for ReadWriteFile {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    write_all_internal(bytes.to_pointer, bytes.size)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    write_all_internal(string.to_pointer, string.size)
  }

  fn pub mut flush -> Result[Nil, Error] {
    sys.flush_file(@fd)
  }
}

impl Seek for ReadWriteFile {
  fn pub mut seek(position: Int) -> Result[Int, Error] {
    sys.seek_to(@fd, position)
  }
}
