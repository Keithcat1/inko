# Formatting of Inko values for debugging purposes.
import std.string.(IntoString, StringBuffer)

# The value to use for objects if the nesting is too great.
let PLACEHOLDER = '...'

# The maximum number of objects to recurse into when formatting an object,
# before returning a placeholder.
let MAX_DEPTH = 16

# Formats a value using the default formatter.
#
# Examples
#
#     import std.fmt.(fmt)
#
#     fmt('hello') # => "hello"
#     fmt([10, 20]) # => '[10, 20]'
fn pub fmt[T: Format](value: ref T) -> String {
  let formatter = Formatter.new

  value.fmt(formatter)
  formatter.into_string
}

# The default formatter to use when formatting an object.
class pub Formatter {
  let @buffer: StringBuffer
  let @nesting: Int

  # Returns a new `Formatter` with its default settings.
  fn pub static new -> Formatter {
    Formatter { @buffer = StringBuffer.new, @nesting = 0 }
  }

  # Writes the given `String` into the underlying buffer.
  fn pub mut write(string: String) {
    @buffer.push(string)
  }

  # Descends into a child object, running the supplied block if our nesting is
  # not too great.
  #
  # If nesting _is_ too great, a placeholder value is added to the buffer, and
  # the supplied block is not executed.
  fn pub mut descend(block: fn) {
    if @nesting >= MAX_DEPTH {
      write(PLACEHOLDER)
      return
    }

    @nesting += 1
    block.call
    @nesting -= 1
  }
}

impl IntoString for Formatter {
  # Moves `self` into a `String`, containing the formatted data.
  fn pub move into_string -> String {
    @buffer.into_string
  }
}

# A type that can be formatted into a human-readable format for debugging
# purposes.
trait pub Format {
  # Formats `self` in a human-readable format for debugging purposes.
  fn pub fmt(formatter: mut Formatter)
}
